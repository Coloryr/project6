<!DOCTYPE html>
<html lang="zh-CN">

<style type="text/css">
    html,
    body {
        width: 400px;
        height: 300px;
        margin: 0;
        overflow: hidden;
    }
</style>

<head>
    <meta charset="utf-8">
    <title>异步加载地图</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <style>
        body,
        html,
        #container {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            font-family: "微软雅黑";
        }
    </style>
</head>

<body>
    <div id="container"></div>
</body>

</html>
<script type="text/javascript">
    window.TILE_VERSION = {
        "ditu": {
            "normal": {
                "version": "088",
                "updateDate": "20210119"
            },
            "satellite": {
                "version": "009",
                "updateDate": "20210119"
            },
            "normalTraffic": {
                "version": "081",
                "updateDate": "20210119"
            },
            "satelliteTraffic": {
                "version": "083",
                "updateDate": "20210119"
            },
            "mapJS": {
                "version": "104",
                "updateDate": "20210119"
            },
            "satelliteStreet": {
                "version": "083",
                "updateDate": "20210119"
            },
            "earthVector": {
                "version": "001",
                "updateDate": "20210119"
            }
        },
        "webapp": {
            "high_normal": {
                "version": "001",
                "updateDate": "20210119"
            },
            "lower_normal": {
                "version": "002",
                "updateDate": "20210119"
            }
        },
        "api_for_mobile": {
            "vector": {
                "version": "002",
                "updateDate": "20210119"
            },
            "vectorIcon": {
                "version": "002",
                "updateDate": "20210119"
            }
        }
    };
    window.MSV = {};
    window.BMAP_AUTHENTIC_KEY = "dreuI9roYFEZv2u0kRBbWsriknnzlhZp";
    window.BMapGL = window.BMapGL || {};
    function Start(bl, ex) {
        var C = C || {
            version: "20150702",
            emptyFn: function () { }
        };
        (function () {
            C._log = [];
            var i = 0;
            var T = {};
            C.BaseClass = function (hN) {
                T[(this.hashCode = (hN || C.BaseClass.guid()))] = this
            };
            C.BaseClass.guid = function () {
                return "mz_" + (i++).toString(36)
            };
            C.BaseClass.create = function () {
                var hN = new C.BaseClass();
                hN.decontrol();
                return hN
            };
            var e = C.instance = C.I = function (hN) {
                return T[hN]
            };
            C.BaseClass.prototype.dispose = function () {
                if (this.hashCode) {
                    delete T[this.hashCode]
                }
                for (var hN in this) {
                    if (typeof this[hN] != "function") {
                        delete this[hN]
                    }
                }
            };
            C.BaseClass.prototype.getHashCode = function () {
                if (!this.hashCode) {
                    T[(this.hashCode = C.BaseClass.guid())] = this
                }
                return this.hashCode
            };
            C.BaseClass.prototype.decontrol = function () {
                delete T[this.hashCode]
            };
            C.BaseClass.prototype.toString = function () {
                return "[object " + (this._className || "Object") + "]"
            };
            C.BaseClass.prototype._wlog = function (hO, hP) {
                var hN = C._log;
                if (hN.length > 100) {
                    hN.reverse().length = 50;
                    hN.reverse()
                }
                hN[hN.length] = "[" + hO + "][" + (this._className || "Object") + " " + this.hashCode + "] " + hP
            }
        })();
        Function.prototype.inherits = function (hN, T) {
            var e, hO, hQ = this.prototype,
                hP = function () { };
            hP.prototype = hN.prototype;
            hO = this.prototype = new hP();
            if (typeof (T) == "string") {
                hO._className = T
            }
            for (e in hQ) {
                hO[e] = hQ[e]
            }
            this.prototype.constructor = hQ.constructor;
            hQ = hP = null;
            return hO
        };
        C.BaseEvent = function (e, i) {
            this.type = e;
            this.returnValue = true;
            this.target = i || null;
            this.currentTarget = this.srcElement = null;
            this.cancelBubble = false;
            this.domEvent = null
        };
        C.BaseClass.prototype.on = C.BaseClass.prototype.addEventListener = function (T, i) {
            if (typeof i !== "function") {
                return this._wlog("error", "addEventListener:" + i + " is not a function")
            }
            if (!this._listeners) {
                this._listeners = {}
            }
            var e = this._listeners;
            if (T.indexOf("on") !== 0) {
                T = "on" + T
            }
            if (typeof e[T] !== "object") {
                e[T] = {}
            }
            var hN = i.hashCode || C.BaseClass.guid();
            i.hashCode = hN;
            if (e[T][hN]) {
                this._wlog("warning", "repeat key:" + hN)
            }
            e[T][hN] = i
        };
        C.BaseClass.prototype.off = C.BaseClass.prototype.removeEventListener = function (T, i) {
            if (typeof i == "function") {
                i = i.hashCode
            } else {
                if (typeof i !== "string" && typeof i !== "undefined") {
                    return
                }
            } if (!this._listeners) {
                this._listeners = {}
            }
            if (T.indexOf("on") != 0) {
                T = "on" + T
            }
            var e = this._listeners;
            if (!e[T]) {
                return
            }
            if (i === undefined) {
                e[T] = {};
                return
            }
            if (e[T][i]) {
                delete e[T][i]
            }
        };
        C.BaseClass.prototype.fire = C.BaseClass.prototype.dispatchEvent = function (hN) {
            if (!this._listeners) {
                this._listeners = {}
            }
            var T, e = this._listeners,
                hO = hN.type;
            hN.target = hN.srcElement = hN.target || hN.srcElement || this;
            hN.currentTarget = this;
            if (typeof this[hO] == "function") {
                this[hO](hN)
            }
            if (typeof e[hO] == "object") {
                for (T in e[hO]) {
                    if (typeof e[hO][T] == "function") {
                        e[hO][T].call(this, hN)
                    }
                }
            }
            return hN.returnValue
        };
        C.BaseEvent.prototype.inherit = function (T) {
            var i = this;
            this.domEvent = T = window.event || T;
            i.clientX = T.clientX || T.pageX;
            i.clientY = T.clientY || T.pageY;
            i.offsetX = T.offsetX || T.layerX;
            i.offsetY = T.offsetY || T.layerY;
            i.screenX = T.screenX;
            i.screenY = T.screenY;
            i.ctrlKey = T.ctrlKey || T.metaKey;
            i.shiftKey = T.shiftKey;
            i.altKey = T.altKey;
            return i
        };
        C.Browser = (function () {
            var T = navigator.userAgent;
            var hO = 0;
            var e = 0;
            var hP = 0;
            var i = 0;
            var hT = 0;
            var hR = 0;
            var hS = 0;
            var hQ = 0;
            var hN = 0;
            var hU = 0;
            if (typeof window.opera === "object" && /Opera(\s|\/)(\d+(\.\d+)?)/.test(T)) {
                hP = parseFloat(RegExp.$2)
            } else {
                if (/OPR(\/(\d+)(\..?)?)/.test(T)) {
                    hP = parseInt(RegExp.$2, 10)
                } else {
                    if (/Edge\/((\d+)\.\d+)/.test(T)) {
                        hO = parseInt(RegExp.$2, 10)
                    } else {
                        if (/MSIE (\d+(\.\d+)?)/.test(T)) {
                            e = parseFloat(RegExp.$1)
                        } else {
                            if (T.indexOf("Trident") > -1 && /rv:(\d+(\.\d+)?)/.test(T)) {
                                e = parseInt(RegExp.$1, 10)
                            } else {
                                if (/Firefox(\s|\/)(\d+(\.\d+)?)/.test(T)) {
                                    hT = parseFloat(RegExp.$2)
                                } else {
                                    if (navigator.vendor === "Netscape" && /Netscape(\s|\/)(\d+(\.\d+)?)/.test(T)) {
                                        hS = parseFloat(RegExp.$2)
                                    } else {
                                        if (T.indexOf("Safari") > -1 && /Version\/(\d+(\.\d+)?)/.test(T)) {
                                            i = parseFloat(RegExp.$1)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } if (T.indexOf("Trident") > -1 && /Trident\/(\d+(\.\d+)?)/.test(T)) {
                hQ = parseInt(RegExp.$1, 10)
            } else {
                if (!e && !hO && T.indexOf("Gecko") > -1 && T.indexOf("KHTML") === -1 && /rv\:(\d+(\.\d+)?)/.test(T)) {
                    hN = parseFloat(RegExp.$1)
                } else {
                    if (!hO && /chrome\/(\d+(\.\d+)?)/i.test(T)) {
                        hR = parseFloat(RegExp.$1)
                    } else {
                        if (!hO && /AppleWebKit\/(\d+(\.\d+)?)/.test(T)) {
                            hU = parseInt(RegExp.$1, 10)
                        }
                    }
                }
            }
            var hV = {
                edge: hO,
                ie: e,
                firefox: hT,
                netscape: hS,
                opera: hP,
                safari: i,
                chrome: hR,
                gecko: hN,
                trident: hQ,
                webkit: hU
            };
            return hV
        })();
        window.FeBrowser = C.Browser;
        C.Dom = {};
        C.Dom.createDom = function (i, e) {
            if (C.isIE && e && e.name) {
                i = "<" + i + ' name="' + C.String.escapeHTML(e.name) + '">'
            }
            var T = document.createElement(i);
            if (e) {
                C.Dom.setProperties(T, e)
            }
            return T
        };
        C.Dom.getOffset = function (hN) {
            var hQ = C.Dom.getOwnerDocument(hN);
            var hP = C.isGecko > 0 && hQ.getBoxObjectFor && C.Dom.getStyle(hN, "position") == "absolute" && (hN.style.top === "" || hN.style.left === "");
            var hR = {
                left: 0,
                top: 0
            };
            var i = (C.isIE && !C.isStrict) ? hQ.body : hQ.documentElement;
            if (hN == i) {
                return hR
            }
            var T = null;
            var hO;
            if (hN.getBoundingClientRect) {
                hO = hN.getBoundingClientRect();
                hR.left = hO.left + Math.max(hQ.documentElement.scrollLeft, hQ.body.scrollLeft);
                hR.top = hO.top + Math.max(hQ.documentElement.scrollTop, hQ.body.scrollTop);
                hR.left -= hQ.documentElement.clientLeft;
                hR.top -= hQ.documentElement.clientTop;
                if (C.isIE && !C.isStrict) {
                    hR.left -= 2;
                    hR.top -= 2
                }
            } else {
                if (hQ.getBoxObjectFor && !hP) {
                    hO = hQ.getBoxObjectFor(hN);
                    var e = hQ.getBoxObjectFor(i);
                    hR.left = hO.screenX - e.screenX;
                    hR.top = hO.screenY - e.screenY
                } else {
                    T = hN;
                    do {
                        hR.left += T.offsetLeft;
                        hR.top += T.offsetTop;
                        if (C.isWebkit > 0 && C.Dom.getStyle(T, "position") == "fixed") {
                            hR.left += hQ.body.scrollLeft;
                            hR.top += hQ.body.scrollTop;
                            break
                        }
                        T = T.offsetParent
                    } while (T && T != hN);
                    if (C.isOpera > 0 || (C.isWebkit > 0 && C.Dom.getStyle(hN, "position") == "absolute")) {
                        hR.top -= hQ.body.offsetTop
                    }
                    T = hN.offsetParent;
                    while (T && T != hQ.body) {
                        hR.left -= T.scrollLeft;
                        if (!C.isOpera || T.tagName != "TR") {
                            hR.top -= T.scrollTop
                        }
                        T = T.offsetParent
                    }
                }
            }
            return hR
        };
        C.Dom.getOwnerDocument = function (e) {
            return e.nodeType == 9 ? e : e.ownerDocument || e.document
        };
        C.Dom.setProperties = function (i, e) {
            C.each(e, function (hN, T) {
                C.Dom._setProperty(i, T, hN)
            })
        };
        C.Dom._setProperty = function (i, e, T) {
            if (e == "style") {
                i.style.cssText = T
            } else {
                if (e == "class") {
                    i.className = T
                } else {
                    if (e == "for") {
                        i.htmlFor = T
                    } else {
                        if (e in C.Dom._DIRECT_ATTRIBUTE_MAP) {
                            i.setAttribute(C.Dom._DIRECT_ATTRIBUTE_MAP[e], T)
                        } else {
                            i[e] = T
                        }
                    }
                }
            }
        };
        C.Dom._DIRECT_ATTRIBUTE_MAP = {
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            colspan: "colSpan",
            rowspan: "rowSpan",
            valign: "vAlign",
            height: "height",
            width: "width",
            usemap: "useMap",
            frameborder: "frameBorder"
        };
        C.G = function () {
            for (var T = [], hN = arguments.length - 1; hN > -1; hN--) {
                var hO = arguments[hN];
                T[hN] = null;
                if (typeof hO == "object" && hO && hO.dom) {
                    T[hN] = hO.dom
                } else {
                    if ((typeof hO == "object" && hO && hO.tagName) || hO == window || hO == document) {
                        T[hN] = hO
                    } else {
                        if (typeof hO == "string" && (hO = document.getElementById(hO))) {
                            T[hN] = hO
                        }
                    }
                }
            }
            return T.length < 2 ? T[0] : T
        };
        C.ac = function (e, i) {
            if (!(e = this.G(e))) {
                return
            }
            i = this.trim(i);
            if (!new RegExp("(^| )" + i.replace(/(\W)/g, "\\$1") + "( |$)").test(e.className)) {
                e.className = e.className.split(/\s+/).concat(i).join(" ")
            }
        };
        C.addClassName = C.ac;
        C.each = function (hP, e) {
            if (typeof e != "function") {
                return hP
            }
            if (hP) {
                if (hP.length === undefined) {
                    for (var T in hP) {
                        e.call(hP[T], hP[T], T)
                    }
                } else {
                    for (var hN = 0, hO = hP.length; hN < hO; hN++) {
                        e.call(hP[hN], hP[hN], hN)
                    }
                }
            }
            return hP
        };
        C.extend = function (hP, hN) {
            if (hP && hN && typeof (hN) == "object") {
                for (var hO in hN) {
                    hP[hO] = hN[hO]
                }
                var T = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
                for (var e = 0, i; e < T.length; e++) {
                    i = T[e];
                    if (Object.prototype.hasOwnProperty.call(hN, i)) {
                        hP[i] = hN[i]
                    }
                }
            }
            return hP
        };
        C.hide = function () {
            C.each(arguments, function (e) {
                if (e = C.G(e)) {
                    e.style.display = "none"
                }
            })
        };
        C.inherit = function (hR, hN, T) {
            var hQ = hR.prototype;
            var hP = function () { };
            hP.prototype = hN.prototype;
            var hO = hR.prototype = new hP();
            if (typeof T == "string") {
                hO._className = T
            }
            for (var e in hQ) {
                hO[e] = hQ[e]
            }
            hR.prototype.constructor = hQ.constructor;
            hQ = null;
            return hO
        };
        C.isIE = 0;
        (function () {
            if (navigator.userAgent.indexOf("MSIE") > 0 && !window.opera) {
                /MSIE (\d+(\.\d+)?)/.test(navigator.userAgent);
                C.isIE = parseFloat(RegExp.$1)
            }
        })();
        C.rc = function (e, i) {
            if (!(e = this.G(e))) {
                return
            }
            i = this.trim(i);
            var T = e.className.replace(new RegExp("(^| +)" + i.replace(/(\W)/g, "\\$1") + "( +|$)", "g"), "$2");
            if (e.className != T) {
                e.className = T
            }
        };
        C.removeClassName = C.rc;
        C.show = function () {
            this.each(arguments, function (e) {
                if (e = C.G(e)) {
                    e.style.display = ""
                }
            })
        };
        C.trim = function (e) {
            return e.replace(/(^[\s\t\xa0\u3000]+)|([\u3000\xa0\s\t]+$)/g, "")
        };
        C.getElementsByClassName = function (e, i) {
            if (e.getElementsByClassName) {
                return e.getElementsByClassName(i)
            } else {
                return (function T(hU, hS) {
                    if (hS == null) {
                        hS = document
                    }
                    var hR = [],
                        hQ = hS.getElementsByTagName("*"),
                        hN = hQ.length,
                        hT = new RegExp("(^|\\s)" + hU + "(\\s|$)"),
                        hP, hO;
                    for (hP = 0, hO = 0; hP < hN; hP++) {
                        if (hT.test(hQ[hP].className)) {
                            hR[hO] = hQ[hP];
                            hO++
                        }
                    }
                    return hR
                })(i, e)
            }
        };
        C.toggleClass = function (e, i) {
            if (C.hasClass(e, i)) {
                C.removeClassName(e, i)
            } else {
                C.addClassName(e, i)
            }
        };
        C.hasClass = function (hN, T) {
            if (!hN || !hN.className || typeof hN.className != "string") {
                return false
            }
            var i = -1;
            try {
                i = hN.className == T || hN.className.search(new RegExp("(\\s|^)" + T + "(\\s|$)"))
            } catch (hO) {
                return false
            }
            return i > -1
        };
        C.insertHTML = function (hN, e, T) {
            hN = C.G(hN);
            if (hN === null) {
                return hN
            }
            var i, hO;
            if (hN.insertAdjacentHTML) {
                hN.insertAdjacentHTML(e, T)
            } else {
                i = hN.ownerDocument.createRange();
                e = e.toUpperCase();
                if (e == "AFTERBEGIN" || e == "BEFOREEND") {
                    i.selectNodeContents(hN);
                    i.collapse(e == "AFTERBEGIN")
                } else {
                    hO = e == "BEFOREBEGIN";
                    i[hO ? "setStartBefore" : "setEndAfter"](hN);
                    i.collapse(hO)
                }
                i.insertNode(i.createContextualFragment(T))
            }
            return hN
        };
        if (typeof HTMLElement != "undefined" && HTMLElement.prototype.__lookupGetter__ && !HTMLElement.prototype.__lookupGetter__("children") && !window.opera) {
            try {
                HTMLElement.prototype.__defineGetter__("children", function () {
                    for (var T = [], hN = 0, hP, hO = 0, e = this.childNodes.length; hO < e; hO++) {
                        hP = this.childNodes[hO];
                        if (hP.nodeType == 1) {
                            T[hN++] = hP;
                            if (hP.name) {
                                if (!T[hP.name]) {
                                    T[hP.name] = []
                                }
                                T[hP.name][T[hP.name].length] = hP
                            }
                            if (hP.id) {
                                T[hP.id] = hP
                            }
                        }
                    }
                    return T
                })
            } catch (gs) { }
        }
        if (typeof (HTMLElement) != "undefined" && !window.opera && HTMLElement.prototype && !HTMLElement.prototype.insertAdjacentHTML) {
            HTMLElement.prototype.insertAdjacentHTML = function (i, T) {
                var hN = this.ownerDocument.createRange();
                hN.setStartBefore(this);
                hN = hN.createContextualFragment(T);
                switch (i) {
                    case "beforeBegin":
                        this.parentNode.insertBefore(hN, this);
                        break;
                    case "afterBegin":
                        this.insertBefore(hN, this.firstChild);
                        break;
                    case "beforeEnd":
                        this.appendChild(hN);
                        break;
                    case "afterEnd":
                        if (!this.nextSibling) {
                            this.parentNode.appendChild(hN)
                        } else {
                            this.parentNode.insertBefore(hN, this.nextSibling)
                        }
                        break
                }
            }
        }
        if (typeof HTMLElement != "undefined" && !window.opera) {
            HTMLElement.prototype.contains = function (e) {
                if (e == this) {
                    return true
                }
                while (e = e.parentNode) {
                    if (e == this) {
                        return true
                    }
                }
                return false
            }
        }
        if (!C.Browser.ie && typeof Event != "undefined" && !window.opera) {
            Event.prototype.__defineSetter__("returnValue", function (e) {
                if (!e) {
                    this.preventDefault()
                }
                return e
            });
            Event.prototype.__defineSetter__("cancelBubble", function (e) {
                if (e) {
                    this.stopPropagation()
                }
                return e
            })
        }
        C.each = function (hO, hN) {
            if (bS(hN)) {
                for (var T = 0, e = hO.length; T < e; T++) {
                    if (hN.call(hO, hO[T], T) === false) {
                        break
                    }
                }
            }
            return hO
        };
        C.Platform = {
            x11: 0,
            macintosh: 0,
            windows: 0,
            android: 0,
            iphone: 0,
            ipad: 0
        };
        for (var go in C.Platform) {
            if (C.Platform.hasOwnProperty(go)) {
                C.Platform[go] = new RegExp(go, "i").test(window.navigator.userAgent) ? 1 : 0
            }
        }
        if (typeof (C.Dom) === "undefined") {
            C.Dom = {}
        }
        C.Dom.getComputedStyle = function (i, e) {
            var hN = i.nodeType == 9 ? i : i.ownerDocument || i.document,
                T;
            if (hN.defaultView && hN.defaultView.getComputedStyle) {
                T = hN.defaultView.getComputedStyle(i, null);
                if (T) {
                    return T[e] || T.getPropertyValue(e)
                }
            } else {
                if (i.currentStyle) {
                    return i.currentStyle[e] || ""
                }
            }
            return ""
        };
        var a8 = C.BaseEvent;
        var ea = C.BaseClass;
        ea.prototype.toString = function () {
            return this._className || ""
        };
        C.on = function (T, i, e) {
            if (!(T = C.G(T))) {
                return T
            }
            i = i.replace(/^on/, "");
            if (T.addEventListener) {
                T.addEventListener(i, e, false)
            } else {
                if (T.attachEvent) {
                    T.attachEvent("on" + i, e)
                }
            }
            return T
        };
        C.un = function (T, i, e) {
            if (!(T = C.G(T))) {
                return T
            }
            i = i.replace(/^on/, "");
            if (T.removeEventListener) {
                T.removeEventListener(i, e, false)
            } else {
                if (T.detachEvent) {
                    T.detachEvent("on" + i, e)
                }
            }
            return T
        };
        C.hc = function (hN, T) {
            if (!hN || !hN.className || typeof hN.className != "string") {
                return false
            }
            var i = -1;
            try {
                i = hN.className == T || hN.className.search(new RegExp("(\\s|^)" + T + "(\\s|$)"))
            } catch (hO) {
                return false
            }
            return i > -1
        };
        C.isEmptyObject = function (T) {
            if (Object.prototype.toString.call(T) === "[object Object]") {
                for (var e in T) {
                    return false
                }
                return true
            } else {
                return false
            }
        };
        var eS = {
            fontFamily: 'Arial,Helvetica,"PingFang SC","Hiragino Sans GB",STHeiti,sans-serif',
            mapStyleNameIdPair: {
                "default": 0,
                "grayed-out": 1
            },
            mapHost: "https://map.baidu.com",
            apiHost: "https://api.map.baidu.com",
            apiIMG: "https://api.map.baidu.com/images",
            staticHost: "https://webmap0.bdimg.com",
            imgPath: "https://webmap0.bdimg.com/image/api/",
            tileDomain: ["https://maponline0.bdimg.com", "https://maponline1.bdimg.com", "https://maponline2.bdimg.com", "https://maponline3.bdimg.com"],
            optDomain: "http://10.120.25.45:8017",
            rasterTilePath: "/tile/",
            vectorTilePath: "/pvd/",
            originTilePath: ["https://pcor.baidu.com"],
            getIconSetPath: function (e) {
                var i = "map_icons2x/";
                if (typeof e === "string" && this.mapStyleNameIdPair[e] > 0) {
                    i = "map_icons2x_" + (this.mapStyleNameIdPair[e] - 1) + "/"
                }
                return "https://maponline0.bdimg.com/sty/" + i
            },
            getMapStyleFiles: function (T) {
                var hO = true;
                if (typeof T === "string" && T !== "default") {
                    hO = false
                }
                var hP = hO ? "" : "_" + (this.mapStyleNameIdPair[T] - 1);
                var i = fw();
                var hN = "udt=" + i.udt + "&v=" + i.ver;
                var e = "https://maponline0.bdimg.com/sty/";
                return [e + "icons_2x" + hP + ".js?" + hN, e + "fs" + hP + ".js?" + hN, e + "indoor_fs.js?" + hN]
            },
            tvc: {
                ditu: {
                    normal: {
                        version: "088",
                        updateDate: "20190618"
                    },
                    satellite: {
                        version: "009",
                        updateDate: "20190618"
                    },
                    normalTraffic: {
                        version: "081",
                        updateDate: "20190618"
                    },
                    satelliteTraffic: {
                        version: "083",
                        updateDate: "20190618"
                    },
                    mapJS: {
                        version: "104",
                        updateDate: "20190618"
                    },
                    satelliteStreet: {
                        version: "083",
                        updateDate: "20190618"
                    },
                    panoClick: {
                        version: "1033",
                        updateDate: "20180108"
                    },
                    panoUdt: {
                        version: "20180108",
                        updateDate: "20180108"
                    },
                    panoSwfAPI: {
                        version: "20150123",
                        updateDate: "20150123"
                    },
                    panoSwfPlace: {
                        version: "20141112",
                        updateDate: "20141112"
                    },
                    earthVector: {
                        version: "001",
                        updateDate: "20190618"
                    }
                }
            },
            msv: {
                mapstyle: {
                    updateDate: "20190108",
                    version: "001"
                }
            }
        };
        eS.imgResources = {
            blankGIF: eS.staticHost + "/res/litemapapi/v1d1/images/blank.gif?20170501",
            markerPng: eS.staticHost + "/res/litemapapi/v1d1/images/marker.png?20170501",
            locPng: eS.staticHost + "/res/litemapapi/v1d1/images/loc.png?20180918",
            locNewPng: eS.staticHost + "/res/litemapapi/v1d1/images/loc_new.png?20190314",
            zoomPng: eS.staticHost + "/res/litemapapi/v1d1/images/zoombtn.png?20180918",
            mapLogoPng: eS.staticHost + "/res/litemapapi/v1d1/images/logo-2x.png?20190226"
        };
        var e0 = eS;
        var a0 = "ruler.cur";
        if (C.Browser.ie || C.Browser.edge) {
            C.extend(e0, {
                distCursor: "url(" + e0.imgPath + a0 + "),crosshair",
                defaultCursor: "url(" + e0.imgPath + "openhand.cur),default",
                draggingCursor: "url(" + e0.imgPath + "closedhand.cur),move"
            })
        } else {
            if (C.Browser.firefox) {
                C.extend(e0, {
                    distCursor: "url(" + e0.imgPath + a0 + "),crosshair",
                    defaultCursor: "-moz-grab",
                    draggingCursor: "-moz-grabbing"
                })
            } else {
                if (C.Browser.chrome || C.Browser.safari) {
                    C.extend(e0, {
                        distCursor: "url(" + e0.imgPath + a0 + ") 2 6,crosshair",
                        defaultCursor: "url(" + e0.imgPath + "openhand.cur) 8 8,default",
                        draggingCursor: "url(" + e0.imgPath + "closedhand.cur) 8 8,move"
                    });
                    if (C.Platform.macintosh) {
                        e0.defaultCursor = "-webkit-grab";
                        e0.draggingCursor = "-webkit-grabbing"
                    }
                } else {
                    C.extend(e0, {
                        distCursor: "url(" + e0.imgPath + a0 + "),crosshair",
                        defaultCursor: "url(" + e0.imgPath + "openhand.cur),default",
                        draggingCursor: "url(" + e0.imgPath + "closedhand.cur),move"
                    })
                }
            }
        }
        bl = bl || {};
        bl.version = "3.0";
        bl._register = [];
        bl.register = function (e) {
            this._register[this._register.length] = e
        };
        bl.guid = 1;
        bl.getGUID = function (e) {
            return (e || "") + bl.guid++
        };
        var ga = window.BMAP_AUTHENTIC_KEY || "";
        bl.bmapVerifyCbk = function (e) {
            if (e && e.error !== 0) {
                if (typeof map !== "undefined") {
                    map.getContainer().innerHTML = "";
                    map.__listeners = {}
                }
                bl = null;
                var i = "百度未授权使用地图API，可能是因为您提供的密钥不是有效的百度LBS开放平台密钥，或此密钥未对本应用的百度地图JavaScriptAPI授权。您可以访问如下网址了解如何获取有效的密钥：http://lbsyun.baidu.com/apiconsole/key#。";
                switch (e.error) {
                    case 101:
                        i = "开发者禁用了该ak的jsapi服务权限。您可以访问如下网址了解如何获取有效的密钥：http://lbsyun.baidu.com/apiconsole/key#。";
                        break;
                    case 102:
                        i = "开发者Referer不正确。您可以访问如下网址了解如何获取有效的密钥：http://lbsyun.baidu.com/apiconsole/key#。";
                        break
                }
                alert(i)
            }
        };
        bl.verify = function () {
            var e = e0.apiHost + "/?qt=verify&ak=" + ga + "&callback=" + ex + ".bmapVerifyCbk";
            hi.load(e)
        };
        bl.apiLoad = bl.apiLoad || function () { };

        function fH(i, e) {
            this._size = i;
            this._cache = [];
            this._totalGetTimes = 0;
            this._totalHitTimes = 0;
            this._options = {
                clearCallback: null,
                removeOldCallback: null
            };
            e = e || {};
            for (var T in e) {
                if (e.hasOwnProperty(T)) {
                    this._options[T] = e[T]
                }
            }
        }
        fH.prototype.setData = function (T, hN) {
            var e = this._cache;
            var i = this._size;
            if (i === 0) {
                return
            }
            if (e.length > i) {
                this._removeOld()
            }
            if (!e[T]) {
                e.push(hN)
            }
            e[T] = hN;
            hN._key_ = T
        };
        fH.prototype.getHitRate = function () {
            return Math.round(this._totalHitTimes / this._totalGetTimes * 1000) / 1000
        };
        fH.prototype.getData = function (i) {
            var e = this._cache[i];
            if (e) {
                this._totalHitTimes++
            }
            this._totalGetTimes++;
            return e
        };
        fH.prototype.removeData = function (hO) {
            if (this._options.clearCallback) {
                this._options.clearCallback(this._cache[hO])
            }
            var T = this._cache;
            var hP = T[hO];
            for (var hN = 0, e = T.length; hN < e; hN++) {
                if (T[hN] === hP) {
                    T.splice(hN, 1);
                    break
                }
            }
            delete T[hO]
        };
        fH.prototype._removeOld = function () {
            var e = this._cache;
            var hO = Math.round(this._size * 0.6);
            for (var hN = 0; hN < hO; hN++) {
                var T = e[hN]._key_;
                if (this._options.clearCallback) {
                    this._options.clearCallback(e[T])
                }
                delete e[T]
            }
            e.splice(0, hO);
            if (this._options.removeOldCallback) {
                this._options.removeOldCallback()
            }
        };
        fH.prototype.clear = function () {
            var T = this._cache;
            for (var hO = 0, e = T.length; hO < e; hO++) {
                var hN = T[hO]._key_;
                if (this._options.clearCallback) {
                    this._options.clearCallback(T[hN])
                }
                delete T[hN]
            }
            this._cache = T = []
        };
        fH.prototype.forEach = function (hN) {
            var T = this._cache;
            for (var hP = 0, e = T.length; hP < e; hP++) {
                var hO = T[hP]._key_;
                hN(T[hO])
            }
        };
        fH.prototype.getBatch = function (hO) {
            var e = [];
            for (var hN = 0, T = hO.length; hN < T; hN++) {
                if (this.getData(hO[hN])) {
                    e[e.length] = this.getData(hO[hN])
                }
            }
            return e
        };
        fH.prototype.clearExcept = function (hP) {
            var T = this._cache;
            for (var e = T.length, hO = e - 1; hO >= 0; hO--) {
                var hN = this._cache[hO]._key_;
                if (!hP[hN]) {
                    T.splice(hO, 1);
                    if (this._options.clearCallback) {
                        this._options.clearCallback(T[hN])
                    }
                    delete T[hN]
                }
            }
        };
        fH.prototype.getDataCount = function () {
            return this._cache.length
        };

        function am() { }
        C.extend(am.prototype, {
            centerAndZoomIn: function (hS, T, hT) {
                var hQ = this;
                if (!hS && !T) {
                    return
                }
                hS = hS || this.centerPoint;
                T = T || this.zoomLevel;
                T = this._getProperZoom(T).zoom;
                if (this.mapType === BMAP_EARTH_MAP) {
                    if (!this._earth) {
                        this.mapType = BMAPGL_NORMAL_MAP;
                        this.temp.originMapType = BMAP_EARTH_MAP;

                        function hR() {
                            hQ._earth = new bl.Earth(hQ, {
                                showRealSunlight: hQ.config.showRealSunlight,
                                showMilkyway: hQ.config.showMilkyway,
                                earthBackground: hQ.config.earthBackground
                            });
                            hQ._proxyEarthEvents();
                            hQ._changeEarthMapType(BMAP_EARTH_MAP);
                            C.extend(hQ, bl.EarthView.prototype);
                            if (!hQ._navigationCtrl && hQ.config.showControls) {
                                hQ._navigationCtrl = new bl.NavigationControl3D(hQ)
                            }
                            delete hQ.temp.originMapType
                        }
                        d7.load("earth", function () {
                            if (bl["FeatureStyle" + hQ.config.style]) {
                                hR()
                            } else {
                                hQ.loadMapStyleFiles(function () {
                                    hR()
                                })
                            }
                        })
                    }
                }
                this.lastLevel = this.zoomLevel || T;
                this.zoomLevel = T;
                var hO = new a8("onload");
                hO.point = hS;
                hO.zoom = T;
                this.centerPoint = this.restrictCenter(new ho(hS.lng, hS.lat));
                if (this.centerPoint.zoom) {
                    this.zoomLevel = this.centerPoint.zoom
                }
                this.defaultZoomLevel = this.defaultZoomLevel || this.zoomLevel;
                this.defaultCenter = this.defaultCenter || this.centerPoint;
                if (!this.loaded && !(this.temp.originMapType === BMAP_EARTH_MAP)) {
                    var i = this.config.defaultMaxBounds;
                    var hP = new c1(i, "baidu", this.mapType);
                    var hN = new cO({
                        mapType: this.mapType,
                        copyright: hP,
                        customLayer: false,
                        baseLayer: true,
                        tileTypeName: "web"
                    });
                    hN._isInnerLayer = true;
                    this.addTileLayer(hN);
                    if (this.mapType === BMAP_SATELLITE_MAP && this._isHybridShow === true) {
                        this._addHybirdMap()
                    }
                }
                this.dispatchEvent(hO);
                this.loaded = true;
                hT = hT || {};
                hT.callback && hT.callback()
            },
            _setPlatformPosition: function (hT, hS, hW) {
                hW = hW || {};
                if (hT === 0 && hS === 0 && !hW.point) {
                    return
                }
                if (isNaN(hW.initMapOffsetX)) {
                    hW.initMapOffsetX = this.offsetX
                }
                if (isNaN(hW.initMapOffsetY)) {
                    hW.initMapOffsetY = this.offsetY
                }
                var hU = hT + hW.initMapOffsetX;
                var hR = hS + hW.initMapOffsetY;
                if (hW.point) {
                    var i = this.restrictCenter(hW.point);
                    if (!i.equals(this.centerPoint)) {
                        this.centerPoint = i.clone();
                        this.fire(new a8("oncenter_changed"))
                    }
                } else {
                    var hN = this.offsetX - hU;
                    var e = this.offsetY - hR;
                    var T = this.getZoomUnits();
                    var hQ = this.centerPoint.lng;
                    var hP = this.centerPoint.lat;
                    var hO = new ho(hQ, hP);
                    this.centerPoint = this.restrictCenter(new ho(hO.lng + hN * T, hO.lat - e * T), T);
                    this.fire(new a8("oncenter_changed"));
                    if (this.zoomLevel < 10) {
                        hU = this.offsetX - (this.centerPoint.lng - hO.lng) / T;
                        hR = this.offsetY + (this.centerPoint.lat - hO.lat) / T
                    }
                }
                this.offsetX = hU;
                this.offsetY = hR;
                var hV = this.platform.style;
                hV.left = hU + "px";
                hV.top = hR + "px";
                this.maskLayer.style.left = -hU + "px";
                this.maskLayer.style.top = -hR + "px";
                if (hW.dispatchEvent !== false) {
                    this.dispatchEvent(new a8("onmoving"))
                }
            },
            zoomTo: function (e, hQ, hU) {
                hU = hU || {};
                hU.zoomCenter = hQ;
                if (hU.noAnimation !== true) {
                    this.deepZoomTo(e, hU);
                    return
                }
                if (typeof e !== "number") {
                    return
                }
                var hO = b3[this.mapType];
                if (!hO) {
                    return
                }
                var T = e;
                e = this._getProperZoom(e).zoom;
                if (e === this.zoomLevel) {
                    var hR = new a8("onzoomexceeded");
                    hR.targetZoom = T;
                    this.dispatchEvent(hR);
                    hU.callback && hU.callback();
                    return
                }
                this.lastLevel = this.zoomLevel;
                if (hQ) {
                    this.temp._cPoint = hQ;
                    this.temp._cPixel = this.pointToPixelIn(hQ)
                } else {
                    if (this.getInfoWindow()) {
                        var hT = this.getInfoWindow().getPoint();
                        this.temp._cPixel = this.pointToPixelIn(hT);
                        this.temp._cPoint = hT
                    }
                } if (this.config.zoomCenter) {
                    hQ = this.config.zoomCenter;
                    this.temp._cPoint = hQ;
                    this.temp._cPixel = this.pointToPixelIn(hQ)
                }
                if (hQ || this.temp.infoWin && this.temp.infoWin.isOpen()) {
                    var i = this.temp._cPoint;
                    var hS = this.temp._cPixel;
                    var hN = this.getZoomUnits(e);
                    var hP = new ho(i.lng + hN * (this.width / 2 - hS.x), i.lat - hN * (this.height / 2 - hS.y));
                    this.centerPoint = this.restrictCenter(hP, hN, e);
                    if (this.centerPoint.zoom) {
                        e = this.centerPoint.zoom
                    }
                }
                if (hU.fireEvent !== false) {
                    this.dispatchEvent(new a8("onzoomstart"))
                }
                if (e !== this.zoomLevel) {
                    this.zoomLevel = e;
                    this.dispatchEvent(new a8("onzooming"));
                    this.dispatchEvent(new a8("onzoomstartcode"))
                }
                if (hU.fireEvent !== false) {
                    this.dispatchEvent(new a8("onzoomend"))
                }
                if (hU.callback) {
                    hU.callback()
                }
            },
            deepZoomMedia: function (e) {
                var i = this;
                if (!i.temp.isStdCtrlBusy) {
                    i.temp.isStdCtrlBusy = true;
                    i.deepZoomTo(i.zoomLevel + e);
                    setTimeout(function () {
                        i.temp.isStdCtrlBusy = false
                    }, 400)
                }
            },
            deepZoomTo: function (hR, hN) {
                hN = hN || {};
                var hP = hR - this.zoomLevel;
                var hO = this._getProperZoom(hR);
                if (hO.exceeded) {
                    var e = new a8("onzoomexceeded");
                    e.targetZoom = hR;
                    this.dispatchEvent(e);
                    return
                }
                var i;
                if (hN.zoomCenter) {
                    i = this.pointToPixelIn(hN.zoomCenter)
                } else {
                    if (this.getInfoWindow()) {
                        i = this.pointToPixelIn(this.getInfoWindow().getPoint(), {
                            zoom: this.lastLevel
                        })
                    } else {
                        var i = new eg(this.width / 2, this.height / 2)
                    }
                }
                this.lastLevel = this.zoomLevel;
                var hQ = this.deepZoom || new bB(this);
                var T = hP > 0 ? 1 : -1;
                hQ.zoomMap(i, hP, T, null, hN)
            },
            flyToIn: function (hS, e) {
                if (e === this.zoomLevel) {
                    this.panToIn(hS);
                    return
                }
                var hP = this._getProperZoom(e);
                if (hP.exceeded) {
                    var hT = new a8("onzoomexceeded");
                    hT.targetZoom = e;
                    this.dispatchEvent(hT);
                    return
                }
                var hR = e - this.zoomLevel;
                var T = new eg(this.width / 2, this.height / 2);
                var i = this.pointToPixelIn(hS);
                var hQ = new d6(i.x - T.x, i.y - T.y);
                this.lastLevel = this.zoomLevel;
                if (Math.abs(hR) >= 4 || Math.abs(hQ.width) > this.width || Math.abs(hQ.height) > this.height) {
                    this.centerAndZoomIn(hS, e);
                    return
                }
                var hO = this.deepZoom || new bB(this);
                var hN = hR > 0 ? 1 : -1;
                hO.zoomMap(i, hR, hN, hQ)
            },
            panToIn: function (i, T) {
                T = T || {};
                if (!i || i.equals(this.centerPoint)) {
                    T.callback && T.callback();
                    return
                }
                var hN = this.pointToPixelIn(i);
                var e = Math.round(this.width / 2);
                var hO = Math.round(this.height / 2);
                if (Math.abs(e - hN.x) > this.width || Math.abs(hO - hN.y) > this.height || T.noAnimation === true) {
                    this._panToIn(e - hN.x, hO - hN.y, i);
                    T.callback && T.callback()
                } else {
                    this._panBy(e - hN.x, hO - hN.y, T)
                }
            },
            _panToIn: function (i, e, hN) {
                var T = this.temp;
                if (T.operating === true) {
                    return
                }
                if (T.dragAni) {
                    T.dragAni.stop();
                    T.dragAni = null;
                    this.dispatchEvent(new a8("onmoveend"))
                }
                this.dispatchEvent(new a8("onmovestart"));
                this._setPlatformPosition(i, e, {
                    point: hN
                });
                this.dispatchEvent(new a8("onmoveend"))
            },
            panBy: function (i, e, T) {
                T = T || {};
                i = Math.round(i) || 0;
                e = Math.round(e) || 0;
                if (Math.abs(i) <= this.width && Math.abs(e) <= this.height && T.noAnimation !== true) {
                    this._panBy(i, e, T)
                } else {
                    this._panToIn(i, e);
                    T.callback && T.callback()
                }
            },
            _panBy: function (i, e, hO) {
                if (this.temp.operating === true) {
                    return
                }
                hO = hO || {};
                this.dispatchEvent(new a8("onmovestart"));
                var hN = this;
                var T = hN.temp;
                T.pl = hN.offsetX;
                T.pt = hN.offsetY;
                if (T.tlPan) {
                    T.tlPan.cancel()
                }
                if (T.dragAni) {
                    T.dragAni.stop();
                    T.dragAni = null;
                    this.dispatchEvent(new a8("onmoveend"))
                }
                T.tlPan = new o({
                    fps: hO.fps || hN.config.fps,
                    duration: hO.duration || hN.config.actionDuration,
                    transition: hO.transition || ck.easeInOutQuad,
                    render: function (hP) {
                        this.terminative = hN.temp.operating;
                        if (hN.temp.operating) {
                            return
                        }
                        hN._setPlatformPosition(Math.ceil(i * hP), Math.ceil(e * hP), {
                            initMapOffsetX: T.pl,
                            initMapOffsetY: T.pt
                        })
                    },
                    finish: function (hP) {
                        hN.dispatchEvent(new a8("onmoveend"));
                        hN.temp.tlPan = false;
                        if (hN.temp.stopArrow === true) {
                            hN.temp.stopArrow = false;
                            if (hN.temp.arrow !== 0) {
                                hN._arrow()
                            }
                        }
                        hO.callback && hO.callback()
                    }
                })
            },
            getCenterIn: function () {
                return this.centerPoint
            },
            getZoom: function () {
                return this.zoomLevel
            },
            setTilt: function () { },
            getTilt: function () {
                return this._tilt
            },
            setHeading: function () { },
            getHeading: function () {
                return this._heading
            },
            restrictCenter: function (hR, hO, hS) {
                this.isRestrict = false;
                hO = hO || this.getZoomUnits();
                hS = hS || this.zoomLevel;
                var T = this.pixelToPointIn(new eg(0, 0), {
                    center: hR,
                    zoom: hS
                });
                var hP = this.pixelToPointIn(new eg(0, this.height), {
                    center: hR,
                    zoom: hS
                });
                if (this.zoomLevel < 5) {
                    if (T.lat > c5.MAX_LAT && hP.lat < c5.MIN_LAT) {
                        this.isRestrict = true;
                        var i = c5.MAX_LAT - hR.lat;
                        var e = hR.lat - c5.MIN_LAT;
                        var hQ;
                        if (i < e) {
                            hQ = i / (this.height / 2)
                        } else {
                            hQ = e / (this.height / 2)
                        }
                        var hN = 18 - ez(hQ);
                        this.zoomLevel = Math.ceil(hN);
                        hR.zoom = Math.ceil(hN);
                        return hR
                    }
                }
                if (T.lat > c5.MAX_LAT) {
                    this.isRestrict = true;
                    hR.lat = c5.MAX_LAT - this.height / 2 * hO
                } else {
                    if (hP.lat < c5.MIN_LAT) {
                        this.isRestrict = true;
                        hR.lat = c5.MIN_LAT + this.height / 2 * hO
                    }
                }
                return hR
            }
        });

        function c5(e, T) {
            if (typeof e === "string") {
                e = document.getElementById(e)
            }
            ea.call(this);
            this.container = e;
            this.width = e.clientWidth;
            this.height = e.clientHeight;
            this.offsetX = 0;
            this.offsetY = 0;
            this._setStyle(e);
            e.unselectable = "on";
            e.innerHTML = "";
            C.ac(e, "bmap-container");
            e.appendChild(this.render());
            this._initDate = new Date();
            this.platform = e.children[0];
            this.maskLayer = this.platform.children[0];
            this._panes = {};
            this.centerPoint = new ho(0, 0);
            this.zoomLevel = 0;
            this._heading = 0;
            this._tilt = 0;
            this._bounds = new dP();
            this.lastLevel = 0;
            this._lock = false;
            this._enableTiltZoom = 7;
            this._enableHeadingZoom = 7;
            this.defaultZoomLevel = null;
            this.defaultCenter = null;
            this.zoomEventStatus = "idle";
            this.currentOperation = dR.idle;
            this._setConfig(T);
            this._initMapRenderType();
            this._animationInfo = {};
            this._animationInfoUnstopable = {};
            this.suspendLoad = false;
            this._customTileLabels = [];
            if (this._renderType === "webgl") {
                this._workerMgr = new f5(this);
                this._featureMgr = new c9();
                C.extend(this, c4.prototype);
                this.jobScheduler = new fL(this);
                this.benchmark = new ac();
                this._setupWebGLMap();
                this.deviceInfo = {
                    hardwareInfo: {
                        renderer: "",
                        vendor: ""
                    }
                };
                if (a5.ifSupportWebGL._renderer) {
                    this.deviceInfo.hardwareInfo.renderer = a5.ifSupportWebGL._renderer;
                    this.deviceInfo.hardwareInfo.vendor = a5.ifSupportWebGL._vendor
                }
            } else {
                C.extend(this, am.prototype)
            } if (!b3[this.config.mapType]) {
                this.config.mapType = BMAPGL_NORMAL_MAP
            }
            if (this.config.mapType === BMAP_EARTH_MAP && !this.config.enableEarth) {
                if (this.forceEnableEarth() === false) {
                    this.config.mapType = BMAPGL_NORMAL_MAP
                }
            }
            this.mapType = this.config.mapType;
            this.preMapType = null;
            if (this.config.enableEarth) {
                var hP = this.maskLayer.style;
                hP.opacity = 0;
                hP.background = "#000";
                if (this.config.mapType === BMAP_EARTH_MAP) {
                    hP.opacity = 1
                }
                setTimeout(function () {
                    hP.WebkitTransition = hP.transition = "opacity .4s"
                }, 100)
            }
            this._isHybridShow = this.config.showStreetLayer;
            this.temp = {
                operating: false,
                arrow: 0,
                lastDomMoveTime: 0,
                lastLoadTileTime: 0,
                lastMovingTime: 0,
                canKeyboard: false,
                I: function (i) {
                    return C.I(i)
                },
                curSpots: [],
                curSpotsArray: [],
                curAreaSpot: null,
                spotsGuid: 1,
                registerIndex: -1,
                hoverOnSpot: null,
                isStdCtrlBusy: false
            };
            window.InstanceCore = this.temp.I;
            this.platform.style.cursor = this.config.defaultCursor;
            this._bind();
            for (var hN = 0; hN < bl._register.length; hN++) {
                bl._register[hN](this)
            }
            this.temp.registerIndex = hN;
            var hO = this;
            if (this._renderType === "webgl") {
                d7.load("oppcgl", function () {
                    hO._asyncRegister()
                })
            } else {
                d7.load("oppc", function () {
                    hO._asyncRegister()
                })
            } if (this.config.mapType === "B_EARTH_MAP") {
                if (!bl.Earth) {
                    d7.load("earth", function () { })
                } else {
                    hO._syncAndChangeMapType("B_EARTH_MAP")
                }
            }
        }
        c5.MAX_TILT = 87;
        c5.MAX_DRAG_TILT = 73;
        c5.MAX_DRAG_TILT_L2 = 50;
        c5.MIN_TILT = 0;
        c5.MAX_LAT = 19431424;
        c5.MIN_LAT = -16023552;
        c5.WORLD_SIZE_MC_HALF = 20037726.372307256;
        c5.WORLD_SIZE_MC = c5.WORLD_SIZE_MC_HALF * 2;
        c5.RIGHT_EDGE_POINT = new ho(c5.WORLD_SIZE_MC_HALF, 0);
        c5.LEFT_EDGE_POINT = new ho(-c5.WORLD_SIZE_MC_HALF, 0);
        c5.inherits(ea, "Map");
        C.extend(c5.prototype, {
            render: function () {
                var e = S("div", {
                    id: "platform"
                });
                var hN = e.style;
                hN.overflow = "visible";
                hN.position = "absolute";
                hN.zIndex = 5;
                hN.top = hN.left = "0px";
                var i = S("div", {
                    id: "mask",
                    "class": "BMap_mask"
                });
                var T = i.style;
                T.position = "absolute";
                T.top = T.left = "0px";
                T.zIndex = "9";
                T.overflow = "hidden";
                T.WebkitUserSelect = "none";
                T.width = this.width + "px";
                T.height = this.height + "px";
                e.appendChild(i);
                return e
            },
            _initMapRenderType: function () {
                var e = this.config.forceRenderType;
                if (e === "dom") {
                    this._renderType = "dom";
                    return
                } else {
                    if (e === "canvas") {
                        if (a5.isModernBrowser && !a5.ifCanvas2dInBlackList()) {
                            this._renderType = "canvas";
                            return
                        } else {
                            this._renderType = "dom";
                            return
                        }
                    } else {
                        if (e === "webgl") {
                            if (a5.ifSupportWebGL()) {
                                this._renderType = "webgl";
                                return
                            }
                        }
                    }
                } if (a5.ifSupportWebGL() && a5.ifEnableWebGLMap()) {
                    this._renderType = "webgl";
                    return
                }
                if (a5.isModernBrowser && a5.ifEnableCanvas2dMap()) {
                    this._renderType = "canvas";
                    return
                }
                this._renderType = "dom"
            },
            _setConfig: function (i) {
                i = i || {};
                this.config = {
                    bottomOffset: 0,
                    clickInterval: 200,
                    enableDragging: true,
                    enableRotate: true,
                    enableTilt: true,
                    enableKeyboard: false,
                    enableDblclickZoom: true,
                    enableContinuousZoom: true,
                    enableWheelZoom: false,
                    enableRotateGestures: true,
                    enableTiltGestures: true,
                    enablePinchZoom: true,
                    fixCenterWhenPinch: false,
                    enableAutoResize: true,
                    zoomCenter: null,
                    fps: C.Browser.ie ? 30 : 60,
                    zoomerDuration: 240,
                    actionDuration: 450,
                    defaultCursor: e0.defaultCursor,
                    draggingCursor: e0.draggingCursor,
                    coordType: BMAP_COORD_MERCATOR,
                    mapType: BMAPGL_NORMAL_MAP,
                    drawer: BMAP_SYS_DRAWER,
                    enableInertialDragging: true,
                    drawMargin: 500,
                    drawMarginGL: 500,
                    enableFulltimeSpotClick: false,
                    enableResizeOnCenter: false,
                    isModernBrowser: a5.isModernBrowser,
                    forceRenderType: "",
                    textRenderType: null,
                    ratio: a3() >= 1.5 ? 2 : 1,
                    enableEarth: a5.ifEnableEarth(),
                    defaultMaxBounds: new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712)),
                    showControls: false,
                    showRealSunlight: true,
                    showMilkyway: true,
                    earthBackground: null,
                    showStreetLayer: true,
                    minZoom: null,
                    maxZoom: null,
                    style: "default",
                    enableIconClick: false,
                    autoSafeArea: false,
                    ak: null,
                    webgl2: false,
                    restrictCenter: true,
                    smaa: true,
                    preserveDrawingBuffer: false
                };
                for (var T in i) {
                    if (i.hasOwnProperty(T)) {
                        this.config[T] = i[T];
                        if (T === "fixCenterWhenResize") {
                            this.config.enableResizeOnCenter = i[T]
                        }
                    }
                }
                if (i.style) {
                    if (i.style["styleId"] && i.style["styleId"].length < 32) {
                        this.config.style = i.style["styleId"]
                    } else {
                        this.config.style = i.style
                    }
                }
                this._setTextRenderType();
                this._displayOptions = {
                    poi: true,
                    poiText: true,
                    poiIcon: true,
                    overlay: true,
                    layer: true,
                    building: true,
                    indoor: true,
                    street: true,
                    skyColors: ["rgba(226, 237, 248, 0)", "rgba(186, 211, 252, 1)"],
                    isFlat: false
                };
                if (i.displayOptions) {
                    for (var e in i.displayOptions) {
                        if (i.displayOptions.hasOwnProperty(e)) {
                            this._displayOptions[e] = i.displayOptions[e]
                        }
                    }
                }
                if (this.config.restrictCenter === false) {
                    this._enableTiltZoom = 0;
                    this._enableHeadingZoom = 0
                }
            },
            getMinZoom: function () {
                var T;
                if (b3[this.mapType][this._renderType]) {
                    T = b3[this.mapType][this._renderType].minZoom
                } else {
                    T = b3[this.mapType].minZoom
                } if (this.config.minZoom !== null && this.config.minZoom >= T) {
                    T = this.config.minZoom
                }
                if (this.mapType === "B_EARTH_MAP") {
                    return T
                }
                var i = this.getSize();
                var e = this.worldSize(T);
                while (e < i.width) {
                    T++;
                    e = this.worldSize(T)
                }
                return T
            },
            getMaxZoom: function () {
                var e;
                if (b3[this.mapType][this._renderType]) {
                    e = b3[this.mapType][this._renderType].maxZoom
                } else {
                    e = b3[this.mapType].maxZoom
                } if (this.config.maxZoom !== null && this.config.maxZoom <= e) {
                    e = this.config.maxZoom
                } else {
                    if (this._renderType === "webgl") {
                        e = 21
                    }
                }
                return e
            },
            _drawFrame: function () {
                this._webglMapScene._painter.draw()
            },
            _setupWebGLMap: function () {
                var e = this;
                d7.load("mapgl", function () {
                    e._asyncRegister()
                })
            },
            _setStyle: function (i) {
                var e = i.style;
                e.overflow = "hidden";
                if (fV(i).position !== "absolute") {
                    e.position = "relative"
                }
                e.backgroundImage = "url(" + e0.imgPath + "bg.png)";
                e.textAlign = "left";
                e.touchAction = e.MSTouchAction = "none"
            },
            _bind: function () {
                var e = this;
                if (e._renderType !== "webgl") {
                    e._watchSize = function () {
                        var T = e.getContainerSize();
                        if (e.width !== T.width || e.height !== T.height) {
                            var hQ = (T.width - e.width) / 2;
                            var hS = (T.height - e.height) / 2;
                            var hN = e.getZoomUnits();
                            var hP = e.centerPoint;
                            if (hP && !e.config.enableResizeOnCenter) {
                                e.centerPoint = new ho(hP.lng + hQ * hN, hP.lat - hS * hN)
                            }
                            e.maskLayer.style.width = (e.width = T.width) + "px";
                            e.maskLayer.style.height = (e.height = T.height) + "px";
                            var hO = new a8("onresize");
                            hO.size = T;
                            e.dispatchEvent(hO);
                            e.fire(new a8("onsize_changed"));
                            var i = parseInt(e.platform.style.left, 10) || 0;
                            var hR = parseInt(e.platform.style.top, 10) || 0;
                            if (e.currentOperation !== "undefined" && e.currentOperation !== dR.idle && (e.offsetX !== i || e.offsetY !== hR)) {
                                e._setPlatformPosition(i, hR)
                            }
                        }
                    }
                } else {
                    e._watchSize = function () {
                        var i = e.getContainerSize();
                        if (e.width !== i.width || e.height !== i.height) {
                            var hN = e.getSize();
                            e.maskLayer.style.width = (e.width = i.width) + "px";
                            e.maskLayer.style.height = (e.height = i.height) + "px";
                            if (a3() !== e.config.ratio) {
                                e.config.ratio = a3()
                            }
                            var hO = new a8("onresize");
                            hO.size = i;
                            e.dispatchEvent(hO);
                            var T = new a8("onsize_changed");
                            T.size = i;
                            T.oldSize = hN;
                            e.fire(T)
                        }
                    }
                } if (e.config.enableAutoResize) {
                    e.temp.autoResizeTimer = setInterval(e._watchSize, 16)
                }
                this.on("size_changed", function () {
                    var i = e.getMinZoom();
                    if (e.zoomLevel < i) {
                        e.setZoomIn(i, {
                            noAnimation: true
                        })
                    }
                });
                this.on("zoom_changed", function () {
                    this.dispatchEvent(new a8("onzooming"))
                })
            },
            addControl: function (e) {
                if (e && bS(e._i)) {
                    e._i(this);
                    this.dispatchEvent(new a8("onaddcontrol", e))
                }
            },
            removeControl: function (e) {
                if (e && bS(e.remove)) {
                    e.remove();
                    this.dispatchEvent(new a8("onremovecontrol", e))
                }
            },
            addContextMenu: function (e) {
                if (e) {
                    e.initialize(this);
                    this.dispatchEvent(new a8("onaddcontextmenu", e))
                }
            },
            removeContextMenu: function (e) {
                if (e) {
                    this.dispatchEvent(new a8("onremovecontextmenu", e));
                    e.remove()
                }
            },
            addOverlay: function (i) {
                if (i && bS(i._i)) {
                    var T = new a8("onbeforeaddoverlay", i);
                    T.overlay = i;
                    this.dispatchEvent(T);
                    i._i(this);
                    T = new a8("onaddoverlay", i);
                    T.overlay = i;
                    this.dispatchEvent(T)
                }
            },
            removeOverlay: function (i) {
                if (i && bS(i.remove)) {
                    var T = new a8("onremoveoverlay", i);
                    T.overlay = i;
                    i.remove();
                    this.dispatchEvent(T)
                }
            },
            clearOverlays: function () {
                this.dispatchEvent(new a8("onclearoverlays"))
            },
            addTileLayer: function (hO) {
                if (!hO) {
                    return
                }
                for (var hN = 0, e = this.tileMgr.tileLayers.length; hN < e; hN++) {
                    var T = this.tileMgr.tileLayers[hN];
                    if (T === hO || T.getMapType() === hO.getMapType()) {
                        return
                    }
                }
                hO.initialize(this);
                this.dispatchEvent(new a8("onaddtilelayer", hO))
            },
            removeTileLayer: function (e) {
                if (e) {
                    e.remove();
                    this.dispatchEvent(new a8("onremovetilelayer", e))
                }
            },
            getTileLayer: function (e) {
                if (this.tileMgr) {
                    return this.tileMgr.getTileLayer(e)
                }
                return null
            },
            setMapType: function (e) {
                var i = this;
                if (this.mapType === e || this._mapTypeChanging) {
                    return
                }
                if (e === BMAP_EARTH_MAP && !this.config.enableEarth) {
                    return
                }
                if (this._earth && this._earth.getLock()) {
                    return
                }
                this._mapTypeChanging = true;
                this.preMapType = this.mapType;
                this._boundsInPreMapType = this.getBoundsIn();
                if (this.preMapType === BMAP_SATELLITE_MAP) {
                    this._preStreetLayerShow = this._isHybridShow
                }
                if (e === BMAP_EARTH_MAP) {
                    if (!bl.Earth) {
                        d7.load("earth", function () {
                            i._syncAndChangeMapType(e)
                        });
                        return
                    }
                    i._syncAndChangeMapType(e)
                } else {
                    if (this.preMapType !== BMAP_EARTH_MAP) {
                        this._changeFlatMapType(e);
                        this._mapTypeChanging = false
                    } else {
                        this._setMapTypeStatus(e, function (T, hN) {
                            var hO = i._earth.getEarthCanvas();
                            i._changeFlatMapType(e, this.preMapType);
                            if (i._mapTypeChangAni) {
                                i._mapTypeChangAni.stop()
                            }
                            i._mapTypeChangAni = fh.start({
                                el: hO,
                                style: "opacity",
                                startValue: 1,
                                endValue: 0,
                                duration: 200,
                                callback: function () {
                                    i._mapTypeChangAni = null;
                                    i._mapTypeChanging = false
                                }
                            });
                            T = ek.convertLL2MC(T);
                            if (i._renderType === "webgl") {
                                C.extend(i, c4.prototype);
                                i.setCenterIn(T, {
                                    noAnimation: true
                                });
                                i.setZoomIn(hN, {
                                    noAnimation: true
                                })
                            } else {
                                C.extend(i, am.prototype);
                                i.centerAndZoomIn(T, hN)
                            }
                        })
                    }
                }
            },
            _changeFlatMapType: function (hQ) {
                if (!hQ || !b3[hQ]) {
                    return
                }
                var hY = this.preMapType;
                this.mapType = hQ;
                var hN = this.getTileLayer(hY);
                if (hN) {
                    this.removeTileLayer(hN)
                }
                if (hY !== BMAP_EARTH_MAP || this._renderType !== "webgl" || this.baseLayerAdded !== true) {
                    var T = new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712));
                    var hV = new c1(T, "baidu", hQ);
                    var hX = this._renderType === "webgl" ? 2 : 1;
                    var hO = new cO({
                        mapType: hQ,
                        copyright: hV,
                        dataType: hX,
                        customLayer: false,
                        baseLayer: true,
                        tileTypeName: "na"
                    });
                    hO._isInnerLayer = true;
                    this.addTileLayer(hO);
                    if (this._renderType === "webgl" && !this.baseLayerAdded) {
                        this.baseLayerAdded = true
                    }
                }
                if (hY === BMAP_SATELLITE_MAP) {
                    this._preStreetLayerShow = this._isHybridShow;
                    this._removeHybirdMap()
                } else {
                    if (hQ === BMAP_SATELLITE_MAP) {
                        if (this._preStreetLayerShow === true || typeof this._preStreetLayerShow === "undefined") {
                            this._addHybirdMap()
                        }
                    }
                }
                var hS = this.tileMgr.tileLayers;
                for (var hR = 0, hP = hS.length; hR < hP; hR++) {
                    var hT = hS[hR];
                    var hW = hT.tilesDiv;
                    if (!hW) {
                        continue
                    }
                    if (!hT._isInnerLayer && hW.style.visibility === "hidden") {
                        hW.style.visibility = ""
                    }
                }
                var hU = new a8("onmaptypechange");
                hU.zoomLevel = this.zoomLevel;
                hU.mapType = hQ;
                hU.exMapType = hY;
                this.dispatchEvent(hU)
            },
            showStreetLayer: function (e) {
                e ? this._addHybirdMap() : this._removeHybirdMap()
            },
            hideStreetLayer: function (e) {
                this._hideStreetLayerOptions = e;
                this._removeHybirdMap(e)
            },
            _addHybirdMap: function () {
                this._isHybridShow = true;
                if (this.mapType === "B_EARTH_MAP") {
                    if (this._earth) {
                        this._earth.showStreetLayer()
                    }
                    return
                }
                if (this._hybridTileLayer) {
                    this.addTileLayer(this._hybridTileLayer);
                    var hP = new a8("onstreetlayer_show");
                    this.dispatchEvent(hP);
                    return
                }
                var hO = new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712));
                var T = new c1(hO, "", BMAP_HYBRID_MAP);
                var i = new cO({
                    copyright: T,
                    transparentPng: true,
                    tileTypeName: "web"
                });
                i._isInnerLayer = true;
                var hN = this.isCanvasMap();
                i.getTilesUrl = function (hQ, hV) {
                    var hT = b3.B_STREET_MAP;
                    var hU = aB("ditu", "satelliteStreet");
                    var hR = hU.ver;
                    var e = hU.udt;
                    var hS = hT.tileUrls[Math.abs(hQ.x + hQ.y) % hT.tileUrls.length] + "?qt=vtile&x=" + (hQ.x + "").replace(/-/gi, "M") + "&y=" + (hQ.y + "").replace(/-/gi, "M") + "&z=" + hV + "&styles=sl&v=" + hR + "&udt=" + e + "$scaler=" + a3() + "&showtext=" + (hN ? 0 : 1);
                    return hS
                };
                this._isHybridShow = true;
                this.addTileLayer(i);
                this._hybridTileLayer = i;
                var hP = new a8("onstreetlayer_show");
                this.dispatchEvent(hP)
            },
            _removeHybirdMap: function (i) {
                this._isHybridShow = false;
                if (this.mapType === "B_EARTH_MAP") {
                    if (this._earth) {
                        this._earth.hideStreetLayer(i)
                    }
                    return
                }
                if (this._hybridTileLayer) {
                    this.removeTileLayer(this._hybridTileLayer);
                    var T = new a8("onstreetlayer_hide");
                    this.dispatchEvent(T)
                }
            },
            isStreetLayerShow: function () {
                return this._isHybridShow
            },
            getTileId: function (e, hP) {
                var hN = b3[this.mapType];
                if (typeof hN !== "object") {
                    return null
                }
                var T = hN.baseUnits * Math.pow(2, (hN.zoomLevelBase - hP));
                var hO = parseInt(e.lng / T, 10);
                var i = parseInt(e.lat / T, 10);
                return {
                    row: hO,
                    column: i,
                    level: hP
                }
            },
            reset: function () {
                this.centerAndZoomIn(this.defaultCenter, this.defaultZoomLevel, true)
            },
            setOptions: function (e) {
                e = e || {};
                for (var T in e) {
                    if (e.hasOwnProperty(T)) {
                        var i = true;
                        if (typeof e[T] !== "object") {
                            i = e[T] !== this.config[T]
                        }
                        this.config[T] = e[T];
                        if (T === "fixCenterWhenResize") {
                            this.config.enableResizeOnCenter = e[T]
                        }
                        if (!i) {
                            continue
                        }
                        switch (T) {
                            case "style":
                                this.fire(new a8("onstyle_willchange"));
                                var hN = this;
                                this.loadMapStyleFiles(function () {
                                    hN.fire(new a8("onstyle_changed"))
                                });
                                break;
                            case "enableAutoResize":
                                if (e[T] === true) {
                                    this.enableAutoResize()
                                } else {
                                    this.disableAutoResize()
                                }
                                break;
                            case "displayOptions":
                                this.setDisplayOptions(e[T]);
                                break
                        }
                    }
                }
            },
            enableDragging: function () {
                this.config.enableDragging = true
            },
            disableDragging: function () {
                this.config.enableDragging = false
            },
            enableInertialDragging: function () {
                this.config.enableInertialDragging = true
            },
            disableInertialDragging: function () {
                this.config.enableInertialDragging = false
            },
            enableScrollWheelZoom: function () {
                this.config.enableWheelZoom = true
            },
            disableScrollWheelZoom: function () {
                this.config.enableWheelZoom = false
            },
            enableContinuousZoom: function () {
                this.config.enableContinuousZoom = true
            },
            disableContinuousZoom: function () {
                this.config.enableContinuousZoom = false
            },
            enableResizeOnCenter: function () {
                this.config.enableResizeOnCenter = true
            },
            disableResizeOnCenter: function () {
                this.config.enableResizeOnCenter = false
            },
            enableDoubleClickZoom: function () {
                this.config.enableDblclickZoom = true
            },
            disableDoubleClickZoom: function () {
                this.config.enableDblclickZoom = false
            },
            enableKeyboard: function () {
                this.config.enableKeyboard = true
            },
            disableKeyboard: function () {
                this.config.enableKeyboard = false
            },
            getSize: function () {
                return new d6(this.width, this.height)
            },
            enablePinchToZoom: function () {
                this.config.enablePinchZoom = true
            },
            disablePinchToZoom: function () {
                this.config.enablePinchZoom = false
            },
            enableTilt: function () {
                this.config.enableTilt = true
            },
            disableTilt: function () {
                this.config.enableTilt = false
            },
            enableRotate: function () {
                this.config.enableRotate = true
            },
            disableRotate: function () {
                this.config.enableRotate = false
            },
            enableAutoResize: function () {
                this.config.enableAutoResize = true;
                this._watchSize();
                if (!this.temp.autoResizeTimer) {
                    this.temp.autoResizeTimer = setInterval(this._watchSize, 16)
                }
            },
            disableAutoResize: function () {
                this.config.enableAutoResize = false;
                if (this.temp.autoResizeTimer) {
                    clearInterval(this.temp.autoResizeTimer);
                    this.temp.autoResizeTimer = null
                }
            },
            checkResize: function () {
                this._watchSize()
            },
            resize: function () {
                this._watchSize()
            },
            getContainerSize: function () {
                return new d6(this.container.clientWidth, this.container.clientHeight)
            },
            _getProperZoom: function (T) {
                if (!T) {
                    T = this.zoomLevel
                }
                var i = this.getMinZoom();
                var e = this.getMaxZoom();
                var hN = false;
                if (T < i) {
                    hN = true;
                    T = i
                }
                if (T > e) {
                    hN = true;
                    T = e
                }
                if (this._renderType !== "webgl") {
                    T = Math.round(T)
                }
                return {
                    zoom: T,
                    exceeded: hN
                }
            },
            getContainer: function () {
                return this.container
            },
            getZoomUnits: function (T) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    return Math.pow(2, 18 - this._earth.getImageZoom())
                }
                var e = b3[this.mapType];
                if (typeof e !== "object") {
                    return null
                }
                var i = T || this.zoomLevel;
                return Math.pow(2, (e.zoomLevelBase - i))
            },
            pointToPixelIn: function (hW, hY) {
                if (!hW) {
                    return
                }
                hY = hY || {};
                if (this.mapType === BMAP_EARTH_MAP) {
                    var hN;
                    if (!hW._llPt) {
                        hN = ek.convertMC2LL(hW);
                        hW._llPt = hN
                    }
                    hN = hW._llPt;
                    var hS = null;
                    var T = null;
                    if (typeof hY.zoom === "number") {
                        var hV = this._earth;
                        var hX = hV._getEarthZoomByImgZoom(hY.zoom);
                        if (hX <= 3) {
                            hS = hV._generateTmpPMatrix(hX)
                        }
                        T = hV._generateTmpMVMatrix(hV.getCenter(), hX)
                    }
                    var hO = this._earth.fromLatLngToPixel(hN, {
                        useRound: false,
                        isCalcOnBack: true,
                        matrixInfo: {
                            modelViewMatrix: T,
                            projectionMatrix: hS
                        }
                    });
                    return hO
                }
                if ((this._heading % 360 === 0 && this._tilt === 0) || !this._webglMapCamera) {
                    var hU = this.getZoomUnits(hY.zoom);
                    var hQ = hY.center || this.centerPoint;
                    var i = this.width / 2;
                    var hP = this.height / 2;
                    var hT = (hW.lng - hQ.lng) / hU + i;
                    var hR = (hQ.lat - hW.lat) / hU + hP;
                    if (hY.useRound !== false) {
                        hT = Math.round(hT);
                        hR = Math.round(hR)
                    }
                    return new eg(hT, hR)
                }
                var e = this._webglMapCamera.fromMCToScreenPixel(hW.lng, hW.lat, hY);
                if (hY.useRound === false) {
                    return e
                }
                e.x = Math.round(e.x);
                e.y = Math.round(e.y);
                return e
            },
            pixelToPointIn: function (e, hU) {
                if (!e) {
                    return
                }
                hU = hU || {};
                if (this.mapType === BMAP_EARTH_MAP) {
                    if (typeof hU.zoom === "number") {
                        var hS = this._earth;
                        var hP = null;
                        var T = null;
                        var hT = hS._getEarthZoomByImgZoom(hU.zoom);
                        if (hT <= 3) {
                            hP = hS._generateTmpPMatrix(hT)
                        }
                        T = hS._generateTmpMVMatrix(hS.getCenter(), hT)
                    }
                    var i = this._earth.fromPixelToLatLng(e, {
                        matrixInfo: {
                            modelViewMatrix: T,
                            projectionMatrix: hP
                        }
                    });
                    if (i === null) {
                        return null
                    }
                    return ek.convertLL2MC(i)
                }
                if ((this._heading % 360 !== 0 || this._tilt > 0) && this._webglMapCamera) {
                    return this._webglMapCamera.fromScreenPixelToMC(e.x, e.y, hU)
                }
                var hQ = hU.center || this.centerPoint;
                var hR = this.getZoomUnits(hU.zoom);
                var hO = hQ.lng + hR * (e.x - this.width / 2);
                var hN = hQ.lat - hR * (e.y - this.height / 2);
                return new ho(hO, hN)
            },
            pointToOverlayPixelIn: function (e, hN) {
                hN = hN || {};
                var T = this.pointToPixelIn(e, {
                    zoom: hN.zoom,
                    center: hN.center,
                    forLabel: true,
                    frustumTest: true,
                    useRound: hN.useRound
                });
                if (!T) {
                    return
                }
                if (hN.fixPosition && this.mapType !== "B_EARTH_MAP") {
                    var hO = this.getSize();
                    var i = this.worldSize(hN.zoom);
                    if (T.x > hO.width) {
                        while (T.x > hO.width) {
                            T.x -= i
                        }
                    } else {
                        if (T.x < 0) {
                            while (T.x < 0) {
                                T.x += i
                            }
                        }
                    }
                }
                if (this._renderType === "webgl") {
                    return T
                }
                T.x -= this.offsetX;
                T.y -= this.offsetY;
                return T
            },
            overlayPixelToPointIn: function (i, e) {
                if (!i) {
                    return
                }
                var T = i.clone();
                if (this._renderType !== "webgl") {
                    T.x += this.offsetX;
                    T.y += this.offsetY
                }
                return this.pixelToPointIn(T, e)
            },
            getProjection: function () {
                return new ek()
            },
            lnglatToMercator: function (e, hN) {
                var i = new ho(e, hN);
                var T = ek.convertLL2MC(i);
                return [T.lng, T.lat]
            },
            mercatorToLnglat: function (i, e) {
                if (isNaN(i) || isNaN(e)) {
                    return []
                }
                i = parseFloat(i);
                e = parseFloat(e);
                var hN = new ho(i, e);
                var T = ek.convertMC2LL(hN);
                return [T.lng, T.lat]
            },
            getBoundsIn: function () {
                var h0 = arguments[0];
                if (this.mapType === BMAP_EARTH_MAP && this._earth) {
                    var hU = this._earth.getCustomBounds();
                    if (!hU) {
                        return this.config.defaultMaxBounds
                    }
                    var hT = hU.getSouthWest();
                    var e = hU.getNorthEast();
                    if (hT.lng > e.lng) {
                        e.lng = 180
                    }
                    var ii = ek.convertLL2MC(hT);
                    var h7 = ek.convertLL2MC(e);
                    var hX = this.config.defaultMaxBounds;
                    var h6 = Math.max(ii.lng, hX.sw.lng);
                    var h5 = Math.max(ii.lat, hX.sw.lat);
                    var hZ = Math.min(h7.lng, hX.ne.lng);
                    var hY = Math.min(h7.lat, hX.ne.lat);
                    var h2 = new dP(new ho(h6, h5), new ho(hZ, hY));
                    h2.pointBottomLeft = new ho(h6, h5);
                    h2.pointBottomRight = new ho(hZ, h5);
                    h2.pointTopLeft = new ho(h6, hY);
                    h2.pointTopRight = new ho(hZ, hY);
                    h2.setMinMax();
                    h2.makeNormalizedPoint(this._earth.getHeading());
                    return h2
                }
                h0 = h0 || {};
                var hO = h0.margins || [0, 0, 0, 0];
                var ic = this.pixelToPointIn({
                    x: hO[3],
                    y: this.height - hO[2]
                }, h0);
                var ih = this.pixelToPointIn({
                    x: this.width - hO[1],
                    y: hO[0]
                }, h0);
                var h4 = typeof h0.heading === "number" ? h0.heading : (this._heading % 360);
                var T = typeof h0.tilt === "number" ? h0.tilt : this._tilt;
                var hW = this._webglMapCamera;
                if ((h4 === 0 && T === 0) || !hW) {
                    this._bounds.setSouthWest(ic);
                    this._bounds.setNorthEast(ih);
                    this._bounds.pointBottomLeft = ic;
                    this._bounds.pointBottomRight = new ho(ih.lng, ic.lat);
                    this._bounds.pointTopRight = ih;
                    this._bounds.pointTopLeft = new ho(ic.lng, ih.lat);
                    this._bounds.setMinMax();
                    this._bounds.makeNormalizedPoint(h4);
                    return this._bounds
                }
                var h3 = this.pixelToPointIn({
                    x: hO[3],
                    y: hO[0]
                }, h0);
                var hN = hW.getPosition();
                var ij = Math.sqrt(Math.pow(h3.lng - hN[0], 2) + Math.pow(h3.lat - hN[1], 2));
                var id = this.getZoomUnits();
                var il = ij / id;
                var ia = hW._frustumSideLen;
                var hS = hW._fovy;
                if (il > ia || (90 - T) < hS / 2) {
                    var ik = [h3.lng - hN[0], h3.lat - hN[1]];
                    if ((90 - T) < hS / 2) {
                        ik[0] = -ik[0];
                        ik[1] = -ik[1]
                    }
                    var ib = ia * id;
                    var hR = [ik[0] / ij * ib + hN[0], ik[1] / ij * ib + hN[1]];
                    var h8 = [ih.lng - hN[0], ih.lat - hN[1]];
                    if ((90 - T) < hS / 2) {
                        h8[0] = -h8[0];
                        h8[1] = -h8[1]
                    }
                    var hP = [h8[0] / ij * ib + hN[0], h8[1] / ij * ib + hN[1]];
                    h3.lng = hR[0];
                    h3.lat = hR[1];
                    ih.lng = hP[0];
                    ih.lat = hP[1]
                }
                var h1 = this.pixelToPointIn({
                    x: this.width - hO[1],
                    y: this.height - hO[2]
                }, h0);
                var h9 = [ic, ih, h3, h1];
                var ig = h9[0].lng;
                var im = h9[0].lat;
                var hQ = h9[0].lng;
                var hV = h9[0].lat;
                for (var ie = 1; ie < 4; ie++) {
                    if (h9[ie].lng < ig) {
                        ig = h9[ie].lng
                    }
                    if (h9[ie].lng > hQ) {
                        hQ = h9[ie].lng
                    }
                    if (h9[ie].lat < im) {
                        im = h9[ie].lat
                    }
                    if (h9[ie].lat > hV) {
                        hV = h9[ie].lat
                    }
                }
                this._bounds.setSouthWest(new ho(ig, im));
                this._bounds.setNorthEast(new ho(hQ, hV));
                this._bounds.pointTopLeft = h3;
                this._bounds.pointTopRight = ih;
                this._bounds.pointBottomRight = h1;
                this._bounds.pointBottomLeft = ic;
                this._bounds.makeNormalizedPoint(h4);
                this._bounds.setMinMax();
                return this._bounds
            },
            isLoaded: function () {
                return !!this.loaded
            },
            _getBestLevel: function (i, hW) {
                var hP = 0;
                if (this._renderType === "webgl" && !f1()) {
                    hP = 100
                }
                var hQ = hW.margins || [10, 10, 10, 10];
                var hN = hW.zoomFactor || 0;
                var hR = hQ[1] + hQ[3];
                var hO = hQ[0] + hQ[2];
                var e = this.getMinZoom();
                var hV = this.getMaxZoom();
                var hU = i.toSpan();
                var hT = hU.width / (this.width - hR - hP);
                var hS = hU.height / (this.height - hO - hP);
                var T = 18 - ez(Math.max(hT, hS));
                if (T < e) {
                    T = e
                }
                if (T > hV) {
                    T = hV
                }
                T += hN;
                if (this._renderType !== "webgl") {
                    T = Math.floor(T)
                }
                return T
            },
            getViewportIn: function (hY, h1) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    hY = hY || [];
                    var hX = [];
                    for (var hO = 0; hO < hY.length; hO++) {
                        if (!hY[hO]) {
                            continue
                        }
                        hX.push(ek.convertMC2LL(hY[hO]))
                    }
                    var hW = this._earth.getViewportIn(hX, h1);
                    var hP = hW.center;
                    var hQ = hW.zoom;
                    var hU = ek.convertLL2MC(hP);
                    return {
                        center: hU,
                        zoom: hQ
                    }
                }
                var h0 = {
                    center: this.getCenterIn(),
                    zoom: this.getZoom()
                };
                if (!hY || hY.length === 0) {
                    return h0
                }
                h1 = h1 || {};
                var T;
                if (hY instanceof dP) {
                    T = hY
                } else {
                    var hT = hY;
                    T = new dP();
                    for (var hO = hT.length - 1; hO >= 0; hO--) {
                        T.extend(hT[hO])
                    }
                    if (T.isEmpty()) {
                        return h0
                    }
                }
                var e = T.getCenter();
                var hZ = this._getBestLevel(T, h1);
                if (h1.margins) {
                    var hS = h1.margins;
                    var hR = (hS[1] - hS[3]) / 2;
                    var hV = (hS[0] - hS[2]) / 2;
                    var hN = this.getZoomUnits(hZ);
                    e.lng = e.lng + hN * hR;
                    e.lat = e.lat + hN * hV
                }
                return {
                    center: e,
                    zoom: hZ
                }
            },
            setViewportIn: function (hN, hO) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    var hS;
                    if (hN && hN.center) {
                        var T = ek.convertMC2LL(hN.center);
                        var hQ = this._earth._getEarthZoomByImgZoom(hN.zoom, T);
                        hS = {
                            center: T,
                            zoom: hQ
                        }
                    } else {
                        hS = [];
                        for (var hP = 0; hP < hN.length; hP++) {
                            var hR = ek.convertMC2LL(hN[hP]);
                            hS[hP] = new c0(hR.lat, hR.lng)
                        }
                    }
                    this._earth.setViewportIn(hS, hO);
                    return
                }
                var e;
                if (hN && hN.center) {
                    e = hN
                } else {
                    e = this.getViewportIn(hN, hO)
                }
                hO = hO || {};
                if (this._renderType === "webgl") {
                    this.centerAndZoomIn(e.center, e.zoom, hO);
                    return
                }
                if (e.zoom === this.zoomLevel && hO.enableAnimation !== false) {
                    this.panToIn(e.center, {
                        duration: 200,
                        callback: hO.callback
                    })
                } else {
                    this.centerAndZoomIn(e.center, e.zoom, hO)
                }
            },
            addSpots: function (T, i) {
                if (!T || T.length === 0) {
                    return
                }
                i = i || {};
                var hP = i.zIndex || 0;
                var hO = typeof i.enableMultiResponse === "undefined" ? true : !!i.enableMultiResponse;
                this.spotsPool = this.spotsPool || {};
                var e = "sp" + (this.temp.spotsGuid++);
                this.spotsPool[e] = {
                    spots: T.slice(0),
                    zIndex: hP,
                    enableMultiResponse: hO
                };
                var hN = this;
                d7.load("hotspot", function () {
                    hN._asyncRegister()
                });
                return e
            },
            getSpots: function (e) {
                return this.spotsPool[e] && this.spotsPool[e].spots || []
            },
            removeSpots: function (e) {
                if (!e || !this.spotsPool[e]) {
                    return
                }
                delete this.spotsPool[e]
            },
            clearSpots: function () {
                delete this.spotsPool
            },
            getIconByClickPosition: function (i) {
                if (!this.config.enableIconClick || !this._spotsMgr) {
                    return null
                }
                var e = this._spotsMgr.getSpotsByScreenPosition(i);
                if (e[0] && e[0].userdata) {
                    var T = e[0].userdata;
                    return {
                        name: T.name,
                        uid: T.uid,
                        position: T.iconPoint || e[0].pt
                    }
                }
                return null
            },
            setBounds: function (e) {
                b3[this.mapType].bounds = e.clone()
            },
            getCoordType: function () {
                return this.config.coordType
            },
            getPanes: function () {
                return this._panes
            },
            getInfoWindow: function () {
                if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
                    return this.temp.infoWin
                }
                return null
            },
            getDistanceIn: function (hO, e) {
                if (!hO || !e) {
                    return
                }
                if (hO.equals(e)) {
                    return 0
                }
                if (this.mapType === BMAP_EARTH_MAP) {
                    var hN = ek.convertMC2LL(hO);
                    var T = ek.convertMC2LL(e);
                    return this._earth.getDistance(hN, T)
                }
                var i = ek.getDistanceByMC(hO, e);
                return i
            },
            getOverlays: function () {
                var hO = [];
                var hP = this._overlays;
                var hN = this._customOverlays;
                if (hP) {
                    for (var T in hP) {
                        if (hP[T] instanceof cS) {
                            hO.push(hP[T])
                        }
                    }
                }
                if (hN) {
                    for (var T = 0, e = hN.length; T < e; T++) {
                        hO.push(hN[T])
                    }
                }
                return hO
            },
            getMapType: function () {
                return this.mapType
            },
            _asyncRegister: function () {
                for (var e = this.temp.registerIndex; e < bl._register.length; e++) {
                    bl._register[e](this)
                }
                this.temp.registerIndex = e
            },
            setDefaultCursor: function (e) {
                this.config.defaultCursor = e;
                if (this.platform) {
                    this.platform.style.cursor = this.config.defaultCursor
                }
            },
            getDefaultCursor: function () {
                return this.config.defaultCursor
            },
            setDraggingCursor: function (e) {
                this.config.draggingCursor = e
            },
            getDraggingCursor: function () {
                return this.config.draggingCursor
            },
            _syncAndChangeMapType: function (e) {
                var i = this;
                if (i._renderType === "webgl" && i.getTilt() > c5.MAX_DRAG_TILT_L2) {
                    i.setTilt(c5.MAX_DRAG_TILT_L2, {
                        callback: function () {
                            i._changeEarthMapType(e)
                        }
                    })
                } else {
                    i._changeEarthMapType(e)
                }
            },
            _changeEarthMapType: function (T) {
                var hN = this;
                var hQ = hN.tileMgr.tileLayers;
                if (this._mapTypeChangAni) {
                    this._mapTypeChangAni.stop()
                }
                var hP;
                if (this._earth) {
                    hP = this._earth.getEarthCanvas()
                }
                if (!this._earth) {
                    this.maskLayer.style.opacity = 1;
                    this.maskLayer.style.zIndex = 999;
                    this.maskLayer.style.background = "#000"
                }
                this._mapTypeChangAni = new o({
                    duration: 400,
                    render: function (e) {
                        if (!hN._earth) {
                            return
                        }
                        hP.style.opacity = e
                    },
                    finish: function () {
                        for (var e = hQ.length - 1, hR = e; hR >= 0; hR--) {
                            var hT = hQ[hR].tilesDiv;
                            if (hT) {
                                hT.style.visibility = "hidden"
                            }
                            if (hQ[hR]._isInnerLayer && hN._renderType !== "webgl") {
                                hN.removeTileLayer(hQ[hR])
                            }
                        }
                        hN._mapTypeChangAni = null;
                        hN._mapTypeChanging = false;

                        function hS() {
                            var hX = hN.getZoom() - 2;
                            var hY = hN.getCenterIn();
                            var hV = ek.convertMC2LL(hY);
                            hN._earth = new bl.Earth(hN, {
                                center: hV,
                                zoom: hX,
                                showRealSunlight: hN.config.showRealSunlight,
                                showMilkyway: hN.config.showMilkyway,
                                earthBackground: hN.config.earthBackground
                            });
                            hN._proxyEarthEvents();
                            var hU = hN.mapType;
                            hN.mapType = T;
                            var hW = new a8("onmaptypechange");
                            hW.zoomLevel = this.zoomLevel;
                            hW.mapType = T;
                            hW.exMapType = hU;
                            hN.dispatchEvent(hW);
                            hN._setMapTypeStatus(T);
                            C.extend(hN, bl.EarthView.prototype);
                            if (!hN._navigationCtrl && hN.config.showControls) {
                                hN._navigationCtrl = new eR(hN)
                            }
                        }
                        if (!hN._earth) {
                            if (bl["FeatureStyle" + hN.config.style]) {
                                hS()
                            } else {
                                hN.loadMapStyleFiles(function () {
                                    hS()
                                })
                            }
                        }
                        if (parseInt(hN.maskLayer.style.opacity, 10) === 1) {
                            setTimeout(function () {
                                hN.maskLayer.style.zIndex = 9;
                                hN.maskLayer.style.opacity = 0
                            }, 1000)
                        }
                    }
                });
                if (!this._earth) {
                    return
                }
                var i = this.mapType;
                this.mapType = T;
                var hO = new a8("onmaptypechange");
                hO.zoomLevel = this.zoomLevel;
                hO.mapType = T;
                hO.exMapType = i;
                this.dispatchEvent(hO);
                hN._setMapTypeStatus(T);
                C.extend(hN, bl.EarthView.prototype)
            },
            getMapStyleId: function () {
                if (typeof this.config.style === "string") {
                    return this.config.style
                }
                return this.config.mapStyleId || "custom"
            },
            _setMapTypeStatus: function (T) {
                var hR = arguments[1];
                if (T === BMAP_EARTH_MAP) {
                    var hP = this._earth.getEarthCanvas();
                    if (hP) {
                        hP.style.display = ""
                    }
                    var hS = {
                        noAnimation: true
                    };
                    this._earth.setCenter(ek.convertMC2LL(this.centerPoint), hS);
                    this._earth.setImageZoom(this.zoomLevel, hS);
                    this._earth.setTilt(this.getTilt(), hS);
                    this._earth.setHeading(this.getHeading(), hS)
                } else {
                    if (this.preMapType === BMAP_EARTH_MAP && this._earth) {
                        var hQ = this._earth;
                        var hN = hQ.getMapZoom();
                        var hO = hQ._imageRawZoom || hN;
                        var i = hO - hN;
                        var e = hQ.getCenter();
                        if (this._renderType === "webgl") {
                            this._tilt = hQ.getTilt();
                            if (this.zoomLevel > 7) {
                                this._heading = hQ.getHeading();
                                hR && hR(e, hN);
                                return
                            }
                            if (hQ.getHeading() !== 0) {
                                hQ.setTilt(this.getTilt());
                                hQ.setHeading(this.getHeading(), {
                                    callback: function () {
                                        hR && hR(e, hN)
                                    }
                                })
                            } else {
                                hR && hR(e, hN)
                            }
                            return
                        }
                        if (i < 0.1 && hQ.getTilt() === 0 && hQ.getHeading() === 0) {
                            hR && hR(e, hN);
                            return
                        }
                        hQ.setTilt(0);
                        hQ.setHeading(0);
                        hQ.setZoom(hQ.getZoom() - i, {
                            callback: function () {
                                hR && hR(e, hN)
                            }
                        })
                    }
                }
            },
            _proxyEarthEvents: function () {
                var hO = this;
                var hP = this._earth;
                hP.on("tilesload", function (i) {
                    hO.fire(i)
                });
                hP.on("centerandzoom", function (i) {
                    hO.dispatchEvent(new a8("onmoveend"));
                    hO.dispatchEvent(new a8("onzoomend"))
                });

                function hN(i) {
                    hO.fire(i)
                }
                var e = ["zoomstart", "zoomend", "tilesload", "sunlighttime_change", "sunlighttime_clear", "centerandzoom", "animation_start", "animation_stop", "movestart", "moveend", "moving", "dragstart", "dragend", "dragging"];
                for (var T = 0; T < e.length; T++) {
                    hP.on(e[T], hN)
                }
            },
            forceEnableEarth: function () {
                this.config.forceEnableEarth = true;
                this.config.enableEarth = a5.ifEnableEarth(true);
                this.dispatchEvent(new a8("forceenableearth"));
                return this.config.enableEarth
            },
            setLock: function (e) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    this._earth.setLock(e)
                }
                this._lock = e
            },
            getLock: function () {
                if (this.mapType === BMAP_EARTH_MAP) {
                    return this._earth.getLock()
                }
                return this._lock
            },
            getEarth: function () {
                return this._earth
            },
            isSupportEarth: function () {
                return this.config.enableEarth
            },
            isCanvasMap: function () {
                return !!(this._renderType === "canvas" && this.getMapType() !== "B_EARTH_MAP")
            },
            getCanvasMapCoordByUid: function (hO) {
                if (this._renderType === "webgl") {
                    var hP = this.tileMgr.tileLayers;
                    for (var hN = 0; hN < hP.length; hN++) {
                        if (hP[hN].labelProcessor) {
                            return hP[hN].labelProcessor.getLabelByUid(hO, "")
                        }
                    }
                    return null
                }
                var e = this.canvas2dMapMgr._labelClick;
                var T = e.findLabelByUid(hO);
                return T ? new ho(T.iconPos.geoX, T.iconPos.geoY) : null
            },
            loadBizData: function (i) {
                var e = new a8("onloadbizdata");
                e.data = i;
                this.dispatchEvent(e)
            },
            unloadBizData: function () {
                var e = new a8("onunloadbizdata");
                this.dispatchEvent(e)
            },
            zoomIn: function (e) {
                this.setZoomIn(this.zoomLevel + 1, {
                    zoomCenter: e
                })
            },
            zoomOut: function (e) {
                this.setZoomIn(this.zoomLevel - 1, {
                    zoomCenter: e
                })
            },
            setMaxZoom: function (e) {
                if (this._renderType === "webgl") {
                    this.config.maxZoom = e <= 21 ? e : 21
                } else {
                    this.config.maxZoom = e <= 19 ? e : 19
                }
            },
            setMinZoom: function (e) {
                this.config.minZoom = e >= 3 ? e : 3
            },
            setCenterIn: function (e, i) {
                this.panToIn(e, i)
            },
            getRenderType: function () {
                return this._renderType
            },
            getSolarInfo: function (hN) {
                hN = hN || this._initDate;
                var T = bw(hN);
                var e = ek.convertLL2MC(new ho(T[0], T[1]));
                var hV = e.latLng;
                var hQ = bl.Projection.convertMC2LL(this.centerPoint);
                var hS = hN.getUTCHours();
                var hU = hS + 24 * hQ.lng / 360;
                var hT = hU - 12;
                var hR = hT * 60 * 0.25;
                var hP = Math.asin(Math.sin(dH(hQ.lat)) * Math.sin(dH(hV.lat)) + Math.cos(dH(hQ.lat)) * Math.cos(dH(hV.lat)) * Math.cos(dH(hR)));
                var hO = Math.asin(Math.sin(dH(hR)) * Math.cos(dH(hV.lat)) / Math.cos(hP));
                var i = "north";
                if (hQ.lat < hV.lat) {
                    i = "south"
                }
                return {
                    zenith: e,
                    solarAltitude: hP,
                    solarAzimuth: hO,
                    centerPosition: i,
                    position: e
                }
            },
            setDisplayOptions: function (T) {
                if (!T) {
                    return
                }
                for (var e in this._displayOptions) {
                    if (this._displayOptions.hasOwnProperty(e)) {
                        if (typeof T[e] === "boolean" || (e === "skyColors" && typeof T.skyColors === "object")) {
                            this._displayOptions[e] = T[e]
                        }
                    }
                }
                var i = this.getMapType();
                if (i === c7.NORMAL) {
                    this.fire(new a8("ondisplayoptions_changed"))
                } else {
                    if (i === c7.EARTH && this._earth) {
                        this._earth.fire(new a8("ondisplayoptions_changed"))
                    }
                }
            },
            getHorizonPosY: function (e) {
                if (!e || !this._webglMapCamera) {
                    return null
                }
                var i = this._webglMapCamera.fromMCToScreenPixel(e.lng, e.lat, {
                    heading: 0
                });
                return i.y
            },
            getIndoorInfo: function () {
                if (!this._indoorMgr) {
                    return
                }
                return this._indoorMgr.getData()
            },
            showIndoor: function (e, T) {
                var i = new a8("onindoor_status_changed");
                i.uid = e;
                i.floor = T;
                this.fire(i)
            },
            addAreaSpot: function (e, T) {
                if (!e || e.length === 0) {
                    return
                }
                T = T || {};
                this.areaSpots = this.areaSpots || {};
                var i = T.id || ("sp" + (this.temp.spotsGuid++));
                this.areaSpots[i] = {
                    spot: e,
                    userData: T.userData
                };
                var hN = this;
                d7.load("hotspot", function () {
                    hN._asyncRegister()
                });
                return i
            },
            getAreaSpot: function (e) {
                if (this.areaSpots && this.areaSpots[e]) {
                    return this.areaSpots[e]
                }
                return null
            },
            removeAreaSpot: function (e) {
                if (!e || !this.areaSpots[e]) {
                    return
                }
                delete this.areaSpots[e]
            },
            clearAreaSpots: function () {
                this.areaSpots = {}
            },
            resetSpotStatus: function () {
                this.fire(new a8("onspot_status_reset"))
            },
            hightlightSpotByUid: function (e, T) {
                var i = new a8("onspot_highlight");
                i.uid = e;
                i.tilePosStr = T;
                this.fire(i)
            },
            setZoomIn: function (i, e) {
                e = e || {};
                this.zoomTo(i, e.zoomCenter || null, e)
            },
            getCurrentMaxTilt: function () {
                var e = this.zoomLevel;
                if (this.mapType === "B_EARTH_MAP") {
                    return c5.MAX_DRAG_TILT_L2
                }
                if (this.config.restrictCenter === false) {
                    return c5.MAX_DRAG_TILT
                }
                if (e >= 19) {
                    return c5.MAX_DRAG_TILT
                } else {
                    if (e <= 18) {
                        if (e < this._enableTiltZoom) {
                            if (e >= this._enableTiltZoom - 2) {
                                return (1 - (this._enableTiltZoom - e) / 2) * c5.MAX_DRAG_TILT_L2
                            }
                            return 0
                        }
                        return c5.MAX_DRAG_TILT_L2
                    } else {
                        return (c5.MAX_DRAG_TILT - c5.MAX_DRAG_TILT_L2) * (e - 18) + c5.MAX_DRAG_TILT_L2
                    }
                }
            },
            worldSize: function (i) {
                var e = i || this.zoomLevel;
                return c5.WORLD_SIZE_MC / this.getZoomUnits(e)
            },
            setTrafficOn: function () {
                this.addTileLayer(cb)
            },
            setTrafficOff: function () {
                this.removeTileLayer(cb)
            },
            showOverlayContainer: function () {
                this.setDisplayOptions({
                    overlay: true
                })
            },
            hideOverlayContainer: function () {
                this.setDisplayOptions({
                    overlay: false
                })
            },
            addLabelsToMapTile: function (T) {
                for (var e = 0; e < T.length; e++) {
                    if (typeof T[e].type === "undefined") {
                        T[e].type = "fixed"
                    }
                    if (typeof T[e].rank !== "number") {
                        T[e].rank = 50000
                    }
                    T[e].pt = T[e].position;
                    T[e].custom = true;
                    T[e].processedInZoom = 0;
                    this._customTileLabels.push(T[e])
                }
                this.dispatchEvent(new a8("onadd_tile_labels"))
            },
            removeLabelsFromMapTile: function (T) {
                for (var hN = 0; hN < T.length; hN++) {
                    for (var e = 0; e < this._customTileLabels.length; e++) {
                        if (this._customTileLabels[e].uid === T[hN]) {
                            this._customTileLabels.splice(e, 1)
                        }
                    }
                }
                this.dispatchEvent(new a8("onremove_tile_labels"))
            },
            clearLabels: function () {
                this._customTileLabels.length = 0;
                this.dispatchEvent(new a8("onclear_labels"))
            },
            loadMapStyleFiles: function (hN) {
                var i = this.config.style;
                var T = this;
                this._setTextRenderType();
                if (typeof i === "string") {
                    if (bl["FeatureStyle" + i]) {
                        T.fire(new a8("onstyle_loaded"));
                        hN();
                        return
                    }
                    hi.load(e0.getMapStyleFiles(i), function () {
                        if (T.config.style === i) {
                            bl["FeatureStyle" + i] = window.FeatureStyle;
                            bl["iconSetInfo" + i] = window.iconSetInfo_high;
                            bl.indoorStyle = window.indoorStyle;
                            T.fire(new a8("onstyle_loaded"));
                            hN()
                        }
                    })
                } else {
                    var e = i;
                    f.init(T);
                    f.getStyleJson(e, function (hP) {
                        var hU = ga;
                        var hW = bl.getGUID("custom");
                        T.config.mapStyleId = hW;
                        var hS = {};
                        C.extend(hS, hP);
                        var hQ = Math.floor(T.getZoom());
                        window.styleCbk = function (hX, hY) {
                            if (hY !== hT) {
                                return
                            }
                            hX = JSON.parse(hX);
                            f.onStyleDataBack(hX, hQ, hW, hS, hU);
                            bl.customStyleLoaded = true;
                            T.fire(new a8("onstyle_loaded"));
                            hN()
                        };
                        bl.customStyleInfo = {
                            zoomRegion: {},
                            zoomStyleBody: [],
                            zoomFrontStyle: {}
                        };
                        var hV = f.getStyleUrl(hP, hU, "styleCbk", hQ);
                        var hO = hV.split("?")[0];
                        var hT = hV.split("?")[1];
                        if (!bl.iconSetInfoCustom) {
                            var hR = e0.getMapStyleFiles("default");
                            hR.splice(1, 1);
                            hi.load(hR, function () {
                                bl.iconSetInfoCustom = window.iconSetInfo_high;
                                bl.indoorStyle = window.indoorStyle;
                                bl.customStyleInfo.xhr = gw.post(hO, hT, styleCbk)
                            })
                        } else {
                            bl.customStyleInfo.xhr = gw.post(hO, hT, styleCbk)
                        }
                    })
                }
            },
            setCopyrightOffset: function (hN, i) {
                var T = new a8("oncopyrightoffsetchange", {
                    logo: hN,
                    cpy: i
                });
                this.dispatchEvent(T)
            },
            _setTextRenderType: function (e) {
                if (e) {
                    this.config.textRenderType = e;
                    return
                }
                if (this.config.textRenderType !== null) {
                    return
                }
                if (f1()) {
                    this.config.textRenderType = "canvas"
                } else {
                    if (typeof this.config.style === "string") {
                        this.config.textRenderType = "image"
                    } else {
                        this.config.textRenderType = "canvas"
                    }
                }
            },
            destroy: function () {
                this._destroyed = true;
                this.fire(new a8("ondestroy"))
            },
            centerAndZoom: function (e, hP, T) {
                if (Object.prototype.toString.call(hP) !== "[object Undefined]") {
                    hP = parseInt(hP)
                }
                if (typeof e === "string") {
                    var hN = this;
                    var hO = new V();
                    hO.getPoint(e, function (hQ) {
                        e = hQ;
                        var hR = ek.convertLL2MC(e);
                        hN.centerAndZoomIn(hR, hP, T)
                    })
                } else {
                    var i = ek.convertLL2MC(e);
                    this.centerAndZoomIn(i, hP, T)
                }
            },
            pointToPixel: function (e, T) {
                var i = ek.convertLL2MC(e);
                var hN = {};
                C.extend(hN, T);
                if (hN && hN.center) {
                    hN.center = ek.convertLL2MC(hN.center)
                }
                return this.pointToPixelIn(i, hN)
            },
            pixelToPoint: function (T, i) {
                var hN = {};
                C.extend(hN, i);
                if (hN && hN.center) {
                    hN.center = ek.convertLL2MC(hN.center)
                }
                var e = this.pixelToPointIn(T, hN);
                return ek.convertMC2LL(e)
            },
            pointToOverlayPixel: function (e, T) {
                var i = ek.convertLL2MC(e);
                var hN = {};
                C.extend(hN, T);
                if (hN && hN.center) {
                    hN.center = ek.convertLL2MC(hN.center)
                }
                return this.pointToOverlayPixelIn(i, hN)
            },
            overlayPixelToPoint: function (T, i) {
                var hN = {};
                C.extend(hN, i);
                if (hN && hN.center) {
                    hN.center = ek.convertLL2MC(hN.center)
                }
                var e = this.overlayPixelToPointIn(T, hN);
                return ek.convertMC2LL(e)
            },
            setViewport: function (T, hN) {
                var e;
                if (T && T.center) {
                    e = {};
                    C.extend(e, T);
                    e.center = ek.convertLL2MC(e.center)
                } else {
                    e = [];
                    for (var hO = 0; hO < T.length; hO++) {
                        e[hO] = ek.convertLL2MC(T[hO])
                    }
                }
                this.setViewportIn(e, hN)
            },
            getViewport: function (hP, hN) {
                var T;
                if (hP && hP.length) {
                    T = [];
                    for (var hO = 0; hO < hP.length; hO++) {
                        T[hO] = ek.convertLL2MC(hP[hO])
                    }
                } else {
                    if (hP instanceof dP) {
                        T = new dP(ek.convertLL2MC(hP.getSouthWest()), ek.convertLL2MC(hP.getNorthEast()));
                        T.setMinMax()
                    }
                }
                var e = this.getViewportIn(T, hN);
                e.center = ek.convertMC2LL(e.center);
                return e
            },
            getDistance: function (hO, T) {
                var i = ek.convertLL2MC(hO);
                var hN = ek.convertLL2MC(T);
                var e = this.getDistanceIn(i, hN);
                return e
            },
            setCenter: function (e, T) {
                if (typeof e === "string") {
                    var hN = this;
                    var hO = new V();
                    hO.getPoint(e, function (hP) {
                        e = hP;
                        var hQ = ek.convertLL2MC(e);
                        hN.setCenterIn(hQ, T)
                    })
                } else {
                    var i = ek.convertLL2MC(e);
                    this.setCenterIn(i, T)
                }
            },
            setZoom: function (T, e) {
                var i = {};
                C.extend(i, e);
                if (i && i.zoomCenter) {
                    i.zoomCenter = ek.convertLL2MC(i.zoomCenter)
                }
                this.setZoomIn(T, i)
            },
            flyTo: function (e, T) {
                var i = ek.convertLL2MC(e);
                this.flyToIn(i, T)
            },
            panTo: function (e, T) {
                var i = ek.convertLL2MC(e);
                this.panToIn(i, T)
            },
            getCenter: function () {
                var e = this.getCenterIn();
                return ek.convertMC2LL(e)
            },
            getBounds: function () {
                var e = this.getBoundsIn();
                var i = new dP(ek.convertMC2LL(e.getSouthWest()), ek.convertMC2LL(e.getNorthEast()));
                return i
            },
            setMapStyleV2: function (e) {
                this._setTextRenderType("canvas");
                this.setOptions({
                    style: e
                })
            },
            startViewAnimation: function (T) {
                var e = T._options.delay;
                var i = this;
                setTimeout(function () {
                    T._start(i)
                }, e)
            },
            pauseViewAnimation: function (e) {
                e._pause(this)
            },
            continueViewAnimation: function (e) {
                e._continue(this)
            },
            cancelViewAnimation: function (e) {
                e._cancel(this)
            },
            getMapScreenshot: function () {
                return this._webglMapScene._painter._canvas.toDataURL()
            }
        });
        var c7 = {
            NORMAL: "B_NORMAL_MAP",
            EARTH: "B_EARTH_MAP",
            SATELLITE: "B_STREET_MAP"
        };
        bl.MapTypeId = c7;
        window.BMAP_NORMAL_MAP = "B_NORMAL_MAP";
        window.BMAPGL_NORMAL_MAP = "B_NORMAL_MAP";
        window.BMAP_SATELLITE_MAP = "B_SATELLITE_MAP";
        window.BMAP_HYBRID_MAP = "B_STREET_MAP";
        window.BMAP_EARTH_MAP = "B_EARTH_MAP";
        window.BMAP_COORD_MERCATOR = 1;
        window.BMAP_SYS_DRAWER = 0;
        window.BMAP_SVG_DRAWER = 1;
        window.BMAP_VML_DRAWER = 2;
        window.BMAP_CANVAS_DRAWER = 3;
        var f = {
            environment: "jsapi",
            map: null,
            ontilesloaded: false,
            onstyle_loaded: false,
            init: function (i) {
                var e = this;
                e.map = i;
                this.changeCopyright();
                this.setEnvironment(e.map.config.style);
                this.resetEventListener()
            },
            resetEventListener: function () {
                var e = this;
                this.ontilesloaded = false;
                this.onstyle_loaded = false;
                e.map.addEventListener("ontilesloaded", e.checkLoadedStatus);
                e.map.addEventListener("onstyle_loaded", e.checkLoadedStatus)
            },
            checkLoadedStatus: function (i) {
                f[i.type] = true;
                if (f.ontilesloaded && f.onstyle_loaded) {
                    this.dispatchEvent(new a8("onstylechangetilesloaded"));
                    this.removeEventListener("ontilesloaded", f.checkLoadedStatus);
                    this.removeEventListener("onstyle_loaded", f.checkLoadedStatus)
                }
            },
            changeCopyright: function () {
                var e = this;
                if (e.map.cpyCtrl) {
                    e.map.cpyCtrl.hide();
                    if (e.environment !== "customEditor") {
                        e.map.setCopyrightOffset(new d6(1, 1))
                    }
                } else {
                    e.map.addEventListener("oncopyrightaddend", function () {
                        e.map.cpyCtrl.hide();
                        if (e.environment !== "customEditor") {
                            e.map.setCopyrightOffset(new d6(1, 1))
                        }
                    })
                }
            },
            setEnvironment: function (e) {
                if (e.customEditor) {
                    this.environment = "customEditor";
                    bG.map = this.map
                } else {
                    if (e.sharing) {
                        this.environment = "sharing"
                    } else {
                        if (e.preview) {
                            this.environment = "preview"
                        } else {
                            this.environment = "jsapi"
                        }
                    }
                }
            },
            getStyleJson: function (hN, hP) {
                var hO = this;
                if (hN.styleJson) {
                    hP && hP(hN.styleJson)
                } else {
                    if (hN.styleId) {
                        var i = hN.styleId;
                        var e = (Math.random() * 100000).toFixed(0);
                        bl["_cbk_si_phpui" + e] = function (hR) {
                            var hQ = [];
                            if (hR.result && hR.result["error"] === 0 && hR.content && hR.content["status"] === 0) {
                                hQ = hO.parseJson(hR.content["data"]["json"]);
                                hP && hP(hQ)
                            } else {
                                hP && hP("default")
                            }
                        };
                        bl["_cbk_si_api" + e] = function (hR) {
                            var hQ = [];
                            if (hR.status === 0) {
                                if (hR.info) {
                                    hQ = hO.parseJson(hR.info["json"])
                                } else {
                                    hQ = hO.parseJson(hR.data["json"])
                                }
                                hP && hP(hQ)
                            } else {
                                hP && hP("default")
                            }
                        };
                        var T = "";
                        switch (this.environment) {
                            case "jsapi":
                                T = eS.apiHost + "/?qt=custom_map&v=3.0&style_id=" + i + "&type=publish&ak=" + ga;
                                T += "&callback=" + ex + "._cbk_si_phpui" + e;
                                break;
                            case "sharing":
                                T += "/apiconsole/custommap/getSharingJson";
                                T += "?styleid=" + i + "&type=edit";
                                T += "&ck=" + ex + "._cbk_si_api" + e;
                                break;
                            case "preview":
                                T += "/apiconsole/custommap/getJson";
                                T += "?styleid=" + i + "&type=edit";
                                T += "&ck=" + ex + "._cbk_si_api" + e;
                                break
                        }
                        hi.load(T)
                    } else {
                        hP && hP("default")
                    }
                }
            },
            parseJson: function (T) {
                if (T === null || T === "") {
                    return []
                }
                var i = {
                    t: "featureType",
                    e: "elementType",
                    v: "visibility",
                    c: "color",
                    l: "lightness",
                    s: "saturation",
                    w: "weight",
                    z: "level",
                    h: "hue",
                    f: "fontsize",
                    zri: "curZoomRegionId",
                    zr: "curZoomRegion"
                };
                var hO = {
                    all: "all",
                    g: "geometry",
                    "g.f": "geometry.fill",
                    "g.s": "geometry.stroke",
                    l: "labels",
                    "l.t.f": "labels.text.fill",
                    "l.t.s": "labels.text.stroke",
                    "l.t": "labels.text",
                    "l.i": "labels.icon",
                    "g.tf": "geometry.topfill",
                    "g.sf": "geometry.sidefill"
                };
                var hN = T.split(",");
                var e = hN.map(function (hS) {
                    var hR = hS.split("|").map(function (hY) {
                        var hW = i[hY.split(":")[0]];
                        var hV = (hO[hY.split(":")[1]] ? hO[hY.split(":")[1]] : hY.split(":")[1]);
                        switch (hV) {
                            case "poi":
                                hV = "poilabel";
                                break;
                            case "districtlabel":
                                hV = "districtlabel";
                                break
                        }
                        var hX = {};
                        hX[hW] = hV;
                        return hX
                    });
                    var hP = hR[0];
                    var hU = 1;
                    if (hR[1]["elementType"]) {
                        hU = 2;
                        C.extend(hP, hR[1])
                    }
                    var hT = {};
                    for (var hQ = hU; hQ < hR.length; hQ++) {
                        C.extend(hT, hR[hQ])
                    }
                    return C.extend(hP, {
                        stylers: hT
                    })
                });
                return e
            },
            getStyleUrl: function (T, hO, hN, e) {
                this.styleJson = T;
                var i = e0.apiHost + "/custom/v2/mapstyle?version=" + 4 + "&ak=" + hO + "&";
                i += "is_all=true&is_new=1&";
                i += "styles=" + encodeURIComponent(this.styleJson2styleStringV2(T, e));
                return i
            },
            styleJson2styleStringV2: function (e, hS) {
                var hT = {
                    featureType: "t",
                    elementType: "e",
                    visibility: "v",
                    color: "c",
                    lightness: "l",
                    saturation: "s",
                    weight: "w",
                    level: "z",
                    hue: "h",
                    fontsize: "f"
                };
                var hV = {
                    all: "all",
                    geometry: "g",
                    "geometry.fill": "g.f",
                    "geometry.stroke": "g.s",
                    labels: "l",
                    "labels.text.fill": "l.t.f",
                    "labels.text.stroke": "l.t.s",
                    "labels.text": "l.t",
                    "labels.icon": "l.i",
                    "geometry.topfill": "g.tf",
                    "geometry.sidefill": "g.sf"
                };
                var hW = [];
                for (var hN = this.map.getMinZoom(); hN <= this.map.getMaxZoom(); hN++) {
                    bl.customStyleInfo.zoomFrontStyle[hN] = {}
                }
                bl.customStyleInfo.zoomFrontStyle.main = {};
                var T = false;
                for (var hN = 0; !!e[hN]; hN++) {
                    var hU = e[hN];
                    if (this.isOnlyZoomStyler(hU)) {
                        continue
                    }
                    hS = this.getFrontZoom(hU, hS);
                    if ((hU.featureType === "land" || hU.featureType === "all" || hU.featureType === "background") && typeof hU.elementType === "string" && (hU.elementType === "geometry" || hU.elementType === "geometry.fill" || hU.elementType === "all") && hU.stylers && !T) {
                        if (hU.stylers["color"]) {
                            bl.customStyleInfo.bmapLandColor = hU.stylers["color"]
                        }
                        if (hU.stylers["visibility"] && hU.stylers["visibility"] === "off") {
                            bl.customStyleInfo.bmapLandColor = "#00000000"
                        }
                        if (hU.featureType === "land") {
                            T = true
                        }
                    }
                    if (hU.featureType === "building" && typeof hU.elementType === "string" && hU.elementType === "geometry.fill") {
                        bl.customStyleInfo.buildingFill = true
                    }
                    if (hU.featureType === "roadarrow" && hU.elementType === "labels.icon" && hU.stylers) {
                        bl.customStyleInfo.zoomFrontStyle[hS]["bmapRoadarrowVisibility"] = hU.stylers["visibility"]
                    }
                    var hO = {};
                    C.extend(hO, hU);
                    var hQ = hO.stylers;
                    delete hO.stylers;
                    C.extend(hO, hQ);
                    var hP = [];
                    for (var hR in hT) {
                        if (hO[hR]) {
                            if (this.isEditorZoomKeys(hR)) {
                                continue
                            }
                            if (hR === "elementType") {
                                hP.push(hT[hR] + ":" + hV[hO[hR]])
                            } else {
                                switch (hO[hR]) {
                                    case "poilabel":
                                        hO[hR] = "poi";
                                        break;
                                    case "districtlabel":
                                        hO[hR] = "label";
                                        break
                                }
                                hP.push(hT[hR] + ":" + hO[hR])
                            }
                        }
                    }
                    if (hP.length > 2) {
                        hW.push(hP.join("|"))
                    }
                }
                return hW.join(",")
            },
            getFrontZoom: function (i, e) {
                var T = i.stylers["level"];
                if (T === undefined) {
                    return "main"
                } else {
                    return parseInt(T, 10)
                }
            },
            isZoomConfig: function (e) {
                var i = e.stylers["level"];
                if (i === undefined) {
                    return false
                } else {
                    return true
                }
            },
            isOnlyZoomStyler: function (e) {
                var i = {};
                C.extend(i, e.stylers);
                delete i.curZoomRegionId;
                delete i.curZoomRegion;
                delete i.level;
                if (C.isEmptyObject(i)) {
                    return true
                } else {
                    return false
                }
            },
            isSelectZoom: function (i, e) {
                var T = i.stylers["level"];
                if (T === undefined) {
                    return true
                } else {
                    if (T === e + "") {
                        return true
                    } else {
                        return false
                    }
                }
            },
            isEditorZoomKeys: function (e) {
                var i = {
                    curZoomRegionId: true,
                    curZoomRegion: true
                };
                if (i[e]) {
                    return true
                } else {
                    return false
                }
            },
            getZoomRegion: function (e, i) {
                var hN = e.stylers["level"];
                var T = {};
                C.extend(T, i);
                if (hN === undefined) {
                    return T
                } else {
                    T[parseInt(hN, 10)] = true;
                    return T
                }
            },
            onStyleDataBack: function (hN, e, i, T, hP) {
                if (hN.status !== 0) {
                    return
                }
                if (hN.data.style.length === 3) {
                    if (!bl.customStyleInfo.baseFs) {
                        bl.customStyleInfo.baseFs = hN.data.style
                    }
                    bl.StyleBody = hN.data.style[2]
                } else {
                    bl.StyleBody = hN.data.style
                }
                var hO = bl.customStyleInfo.baseFs;
                bl["FeatureStyle" + i] = hO;
                this.updateFrontFeatureStyle()
            },
            updateFrontFeatureStyle: function () {
                if (bl.customStyleInfo.zoomFrontStyle.main["bmapRoadarrowVisibility"]) {
                    for (var e = this.map.getMinZoom(); e <= this.map.getMaxZoom(); e++) {
                        if (!bl.customStyleInfo.zoomFrontStyle[e]["bmapRoadarrowVisibility"]) {
                            bl.customStyleInfo.zoomFrontStyle[e]["bmapRoadarrowVisibility"] = bl.customStyleInfo.zoomFrontStyle.main["bmapRoadarrowVisibility"]
                        }
                    }
                }
            }
        };
        var bG = {
            map: null,
            labelCache: {},
            calcDrawMc: function (T, i, e) {
                var hN = [];
                switch (i) {
                    case "fill":
                        hN = this.calcFill(T, e);
                        break;
                    case "line":
                        break;
                    case "building3d":
                        hN = this.calcBuilding3d(T, e);
                        break
                }
                return hN
            },
            calcFill: function (hO, T) {
                var hP = [];
                for (var hN = 0; hN < hO.length; hN = hN + 5) {
                    var e = this.coordToMc({
                        x: hO[hN],
                        y: hO[hN + 1]
                    }, T.row, T.col, T.mercatorSize, T.baseTileSize);
                    hP.push(e[0], e[1])
                }
                return hP
            },
            calcLine: function (hO, T) {
                var hP = [];
                var hQ = new Int16Array(hO.buffer);
                for (var hN = 0; hN < hQ.length; hN = hN + 10) {
                    var e = this.coordToMc({
                        x: hQ[hN] / 10,
                        y: hQ[hN + 1] / 10
                    }, T.row, T.col, T.mercatorSize, T.baseTileSize);
                    hP.push(e[0], e[1])
                }
                return hP
            },
            calcBuilding3d: function (hP, T) {
                var hQ = [];
                var hN = {};
                for (var hO = 0; hO < hP.length / 2; hO = hO + 7) {
                    if (hP[hO] === hP[hO - 7] && hP[hO + 1] === hP[hO - 6]) {
                        continue
                    }
                    if (hN[hP[hO].toString() + hP[hO + 1].toString()]) {
                        continue
                    }
                    hN[hP[hO].toString() + hP[hO + 1].toString()] = true;
                    var e = this.coordToMc({
                        x: hP[hO],
                        y: hP[hO + 1]
                    }, T.row, T.col, T.mercatorSize, T.baseTileSize);
                    hQ.push(e[0], e[1])
                }
                return hQ
            },
            coordToMc: function (hO, hN, e, i, T) {
                return [hO.x * (i / T) + e * i, hO.y * (i / T) + hN * i]
            },
            addDrawIntoAreaSpots: function (e, hO) {
                if (f.environment !== "customEditor") {
                    return
                }
                if (!hO.styleIds) {
                    return
                }
                for (var T = 0; T < hO.styleIds.length; T++) {
                    var hR = 0;
                    if (T > 0) {
                        hR = hO.verticesLength[T - 1]
                    }
                    end = hO.verticesLength[T];
                    var hP = [];
                    var hN = "";
                    if (hO.vertex) {
                        hP = hO.vertex;
                        hN = "building3d"
                    } else {
                        if (hO.data[0]) {
                            hP = hO.data[0];
                            hN = hO.type
                        } else {
                            continue
                        }
                    }
                    var hQ = this.calcDrawMc(hP.slice(hR, end), hN, e);
                    this.map.addAreaSpot(hQ, {
                        userData: {
                            styleId: hO.styleIds[T],
                            type: "mapstyle"
                        }
                    })
                }
            },
            addLabelIntoAreaSpots: function (e) {
                if (f.environment !== "customEditor") {
                    return
                }
                for (var hO = 0; hO < e.length; hO++) {
                    var hP = e[hO];
                    for (var hN = 0; hN < hP.fixedLabel.length; hN++) {
                        var T = hP.fixedLabel[hN];
                        if (!T._mcBds) {
                            continue
                        }
                        var hQ = [T._mcBds[0].lng, T._mcBds[0].lat, T._mcBds[0].lng, T._mcBds[1].lat, T._mcBds[1].lng, T._mcBds[1].lat, T._mcBds[1].lng, T._mcBds[0].lat];
                        if (!this.labelCache[hQ.join()]) {
                            this.labelCache[hQ.join()] = true;
                            this.map.addAreaSpot(hQ, {
                                userData: {
                                    styleId: T.styleId,
                                    type: "mapstyle",
                                    name: T.name
                                }
                            })
                        }
                    }
                }
            }
        };

        function bO(i, e, hN, T) {
            this.cx = 3 * i;
            this.bx = 3 * (hN - i) - this.cx;
            this.ax = 1 - this.cx - this.bx;
            this.cy = 3 * e;
            this.by = 3 * (T - e) - this.cy;
            this.ay = 1 - this.cy - this.by;
            this.p1x = i;
            this.p1y = T;
            this.p2x = hN;
            this.p2y = T
        }
        bO.prototype.sampleCurveX = function (e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e
        };
        bO.prototype.sampleCurveY = function (e) {
            return ((this.ay * e + this.by) * e + this.cy) * e
        };
        bO.prototype.sampleCurveDerivativeX = function (e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx
        };
        bO.prototype.solveCurveX = function (e, hS) {
            if (typeof hS === "undefined") {
                hS = 0.000001
            }
            var hR;
            var hQ;
            var hO;
            var T;
            var hN;
            for (hO = e, hN = 0; hN < 8; hN++) {
                T = this.sampleCurveX(hO) - e;
                if (Math.abs(T) < hS) {
                    return hO
                }
                var hP = this.sampleCurveDerivativeX(hO);
                if (Math.abs(hP) < 0.000001) {
                    break
                }
                hO = hO - T / hP
            }
            hR = 0;
            hQ = 1;
            hO = e;
            if (hO < hR) {
                return hR
            }
            if (hO > hQ) {
                return hQ
            }
            while (hR < hQ) {
                T = this.sampleCurveX(hO);
                if (Math.abs(T - e) < hS) {
                    return hO
                }
                if (e > T) {
                    hR = hO
                } else {
                    hQ = hO
                }
                hO = (hQ - hR) * 0.5 + hR
            }
            return hO
        };
        bO.prototype.solve = function (e, i) {
            return this.sampleCurveY(this.solveCurveX(e, i))
        };
        var ck = {};

        function o(T) {
            var e = {
                duration: 1000,
                fps: 30,
                delay: 0,
                transition: ck.linear,
                dropLastAnimation: false
            };
            if (T) {
                for (var hN in T) {
                    e[hN] = T[hN]
                }
            }
            if (T.beginTime) {
                this._beginTime = T.beginTime
            }
            this._callbacks = [];
            this._options = e;
            if (e.delay) {
                var hO = this;
                setTimeout(function () {
                    hO._doStart()
                }, e.delay)
            } else {
                this._doStart()
            }
            this._pauseTime = 0
        }
        o.INFINITE = "INFINITE";
        o.prototype._doStart = function () {
            if (this._isPausing) {
                var e = performance.now() || new Date().getTime();
                this._pauseTime += e - this._isPausing;
                this._isPausing = undefined
            }
            if (window.requestAnimationFrame) {
                var i = this;
                i._timer = window.requestAnimationFrame(function (T) {
                    i._loop(T)
                })
            } else {
                this._beginTime = new Date().getTime();
                if (this._options.duration === o.INFINITE) {
                    this._endTime = null
                } else {
                    this._endTime = this._beginTime + this._options.duration
                }
                this._loop()
            }
        };
        o.prototype._loop = function (hN) {
            var hQ = this;
            hN = hN || new Date().getTime();
            hN = hN - this._pauseTime;
            if (!this._beginTime) {
                this._beginTime = hN
            }
            if (!this._endTime && typeof this._options.duration === "number") {
                this._endTime = this._beginTime + this._options.duration
            }
            if (hQ._endTime !== null && hN >= hQ._endTime) {
                if (hQ._options.dropLastAnimation === false) {
                    hQ._options.render(hQ._options.transition(1), 1, hN)
                }
                if (typeof hQ._options.finish === "function") {
                    hQ._options.finish(hN, this)
                }
                for (var hP = 0, e = hQ._callbacks.length; hP < e; hP++) {
                    hQ._callbacks[hP]()
                }
                return
            }
            var hO;
            if (typeof hQ._options.duration === "number") {
                hO = (hN - hQ._beginTime) / hQ._options.duration;
                hQ.schedule = hQ._options.transition(hO)
            } else {
                hO = hN - hQ._beginTime;
                hQ.schedule = 0
            }
            hQ._options.render(hQ.schedule, hO, hN);
            if (!hQ.terminative) {
                if (window.requestAnimationFrame) {
                    hQ._timer = requestAnimationFrame(function T(i) {
                        hQ._loop(i)
                    })
                } else {
                    hQ._timer = setTimeout(function () {
                        hQ._loop()
                    }, 1000 / hQ._options.fps)
                }
            }
        };
        o.prototype.stop = function (i, e) {
            this.terminative = true;
            if (this._timer) {
                if (window.cancelAnimationFrame) {
                    cancelAnimationFrame(this._timer)
                } else {
                    clearTimeout(this._timer)
                }
                this._timer = null;
                if (typeof this._options.onStop === "function") {
                    this._options.onStop(e)
                }
            }
            if (i) {
                this._endTime = this._beginTime;
                this._loop()
            }
        };
        o.prototype.pause = function () {
            if (!this._isPausing) {
                this.stop();
                this.terminative = undefined;
                this._isPausing = performance.now() || new Date().getTime()
            }
        };
        o.prototype.cancel = function () {
            this.stop()
        };
        o.prototype.append = function (e) {
            this._callbacks.push(e);
            return this
        };
        ck = {
            _p1: 1,
            _p2: 1 * 1.525,
            linear: function (e) {
                return e
            },
            reverse: function (e) {
                return 1 - e
            },
            easeInQuad: function (e) {
                return e * e
            },
            easeInCubic: function (e) {
                return Math.pow(e, 3)
            },
            easeInBiquad: function (e) {
                return Math.pow(e, 4)
            },
            easeInBack: function (e) {
                return e * e * ((ck._p1 + 1) * e - ck._p1)
            },
            easeOutQuad: function (e) {
                return -(e * (e - 2))
            },
            easeOutCubic: function (e) {
                return Math.pow((e - 1), 3) + 1
            },
            easeOutBiquad: function (e) {
                return 1 - Math.pow((e - 1), 4)
            },
            easeOutBack: function (e) {
                return ((e = e - 1) * e * ((ck._p1 + 1) * e + ck._p1) + 1)
            },
            easeInOutQuad: function (e) {
                if (e < 0.5) {
                    return e * e * 2
                } else {
                    return -2 * (e - 2) * e - 1
                }
            },
            easeInOutCubic: function (e) {
                if (e < 0.5) {
                    return Math.pow(e, 3) * 4
                } else {
                    return Math.pow(e - 1, 3) * 4 + 1
                }
            },
            easeInOutBiquad: function (e) {
                if (e < 0.5) {
                    return Math.pow(e, 4) * 8
                } else {
                    return 1 - (Math.pow(e - 1, 4) * 8)
                }
            },
            easeInOutSine: function (e) {
                return (1 - Math.cos(Math.PI * e)) / 2
            }
        };
        ck.ease = (function () {
            var e = new bO(0.4, 0, 0.6, 1);
            return function (i) {
                return e.solve(i)
            }
        })();
        ck["ease-in"] = ck.easeInQuad;
        ck["ease-out"] = ck.easeOutQuad;
        var fh = {
            start: function (hT) {
                var hN = hT.el;
                var e = hT.style;
                var i = hT.startValue;
                var hQ = hT.endValue;
                var hO = hT.duration || 1400;
                var hP = hT.transition || ck.linear;
                var hS = hT.callback;
                var hR = hQ - i;
                var T = hT.unit || "";
                return new o({
                    fps: 60,
                    duration: hO,
                    transition: hP,
                    render: function (hU) {
                        hN.style[e] = i + hR * hU + T
                    },
                    finish: function () {
                        hS && hS()
                    }
                })
            }
        };

        function cJ(hO, T) {
            ea.call(this);
            this.keyframes = hO;
            var e = {
                duration: 1000,
                delay: 0,
                transition: ck.linear,
                interation: 1
            };
            if (T) {
                for (var hN in T) {
                    e[hN] = T[hN]
                }
            }
            this._options = e
        }
        cJ.inherits(ea, "ViewAnimation");
        cJ.prototype._start = function (hP) {
            var T = this;
            T.map = hP;
            var hO = new a8("onanimationstart");
            T.dispatchEvent(hO);
            this._initStatus(T.map);
            var hN = this._options.duration;
            var i = this._options.interation;
            var hQ = this._options.transition;
            var hR = 0;
            T.poiStatus = T.map._displayOptions.poi;
            if (T.poiStatus) {
                T.map.setDisplayOptions({
                    poi: false
                })
            }
            T.map.viewAnimationTime = new Date().getTime();
            this.animation = new o({
                duration: hN,
                transition: hQ,
                start: function (e) { },
                render: function (hS, e) {
                    if (hS === 0) {
                        T._initStatus(T.map)
                    } else {
                        T._setViewByRate(hS)
                    }
                },
                finish: function (hT, hS) {
                    if (++hR < i || i === "INFINITE") {
                        var hU = new a8("onanimationiterations");
                        T.dispatchEvent(hU);
                        delete hS._beginTime;
                        delete hS._endTime;
                        hS._doStart()
                    } else {
                        var hU = new a8("onanimationend");
                        T.dispatchEvent(hU);
                        delete T.map.viewAnimationTime;
                        T.map.setDisplayOptions({
                            poi: T.poiStatus
                        })
                    }
                }
            })
        };
        cJ.prototype._getTotalDuration = function (e, i) {
            if (e === o.INFINITE) {
                return o.INFINITE
            } else {
                return e * i
            }
        };
        cJ.prototype._initStatus = function (e) {
            if (this.keyframes[0]) {
                e.setCenter(this.keyframes[0].center, {
                    noAnimation: true
                });
                e.setZoom(this.keyframes[0].zoom, {
                    noAnimation: true
                });
                e.setTilt(this.keyframes[0].tilt, {
                    noAnimation: true
                });
                e.setHeading(this.keyframes[0].heading, {
                    noAnimation: true
                })
            }
        };
        cJ.prototype._setViewByRate = function (hN) {
            for (var e = 0; e < this.keyframes.length - 1; e++) {
                var hO = this.keyframes[e];
                var T = this.keyframes[e + 1];
                if (hN >= hO.percentage && hN < T.percentage) {
                    this.map.setHeading(this._getHeadingDelta(hO, T, hN), {
                        noAnimation: true
                    });
                    this.map.setTilt(this._getTiltDelta(hO, T, hN), {
                        noAnimation: true
                    });
                    this.map.setCenter(this._getCenterDelta(hO, T, hN), {
                        noAnimation: true
                    });
                    this.map.setZoom(this._getZoomDelta(hO, T, hN), {
                        noAnimation: true
                    })
                }
            }
        };
        cJ.prototype._getHeadingDelta = function (T, i, e) {
            var hO = (e - T.percentage) / (i.percentage - T.percentage);
            var hN = T.heading + (i.heading - T.heading) * hO;
            return hN
        };
        cJ.prototype._getTiltDelta = function (T, i, e) {
            var hO = (e - T.percentage) / (i.percentage - T.percentage);
            var hN = T.tilt + (i.tilt - T.tilt) * hO;
            return hN
        };
        cJ.prototype._getCenterDelta = function (T, i, e) {
            var hO = (e - T.percentage) / (i.percentage - T.percentage);
            var hN = T.center.add(i.center.sub(T.center).mult(hO));
            return hN
        };
        cJ.prototype._getZoomDelta = function (hN, T, i) {
            var hO = (i - hN.percentage) / (T.percentage - hN.percentage);
            var e = hN.zoom + (T.zoom - hN.zoom) * hO;
            return e
        };
        cJ.prototype._pause = function (e) {
            this.animation.pause()
        };
        cJ.prototype._continue = function (e) {
            this.animation._doStart()
        };
        cJ.prototype._cancel = function (T) {
            T.setDisplayOptions({
                poi: this.poiStatus
            });
            this.animation.cancel();
            delete T.viewAnimationTime;
            var i = new a8("onanimationcancel");
            this.dispatchEvent(i)
        };
        var er = undefined;
        var cX = {
            is64Bit: function () {
                if (/Windows/.test(navigator.userAgent)) {
                    if (/Win64; x64/.test(navigator.userAgent)) {
                        return true
                    } else {
                        if (/WOW64/.test(navigator.userAgent)) {
                            return true
                        } else {
                            return false
                        }
                    }
                }
                return true
            },
            isIOS112: function cN(e) {
                return /11_2/.test(navigator.userAgent)
            },
            canUseWebAssembly: function (i) {
                if (er !== undefined) {
                    i && i(er);
                    return
                }
                if (window.WebAssembly && this.is64Bit()) {
                    if (window.disableWebAssembly === true) {
                        er = false;
                        i && i(er)
                    } else {
                        if (!bs()) {
                            er = true;
                            i && i(er)
                        } else {
                            if (this.isIOS112()) {
                                er = false;
                                i && i(er)
                            } else {
                                var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
                                WebAssembly.instantiate(e).then(function (T) {
                                    er = true;
                                    i && i(er)
                                }, function (T) {
                                    er = false;
                                    i && i(er)
                                })
                            }
                        }
                    }
                } else {
                    er = false;
                    i && i(er)
                }
            }
        };
        var dt = {};
        bl.Utils = dt;

        function da(e) {
            return e.style
        }

        function dj(i) {
            if (C.Browser.ie > 0) {
                i.unselectable = "on";
                i.selectstart = function () {
                    return false
                };
                i.onmousedown = function (T) {
                    T.preventDefault();
                    return false
                }
            } else {
                var e = da(i);
                e.MozUserSelect = "none";
                e.WebkitUserSelect = "none";
                i.addEventListener("mousedown", function (T) {
                    T.preventDefault()
                }, false)
            }
        }

        function g9(e) {
            return e && e.parentNode && e.parentNode.nodeType !== 11
        }

        function dF(i, e) {
            i.insertAdjacentHTML("beforeEnd", e);
            return i.lastChild
        }

        function hx(T, i) {
            var hN = document.createElement("div");
            hN.innerHTML = i;
            var e = hN.childNodes[0];
            return T.parentNode.insertBefore(e, T)
        }

        function h(i) {
            i = i || window.event;
            i.stopPropagation ? i.stopPropagation() : i.cancelBubble = true
        }

        function bR(i) {
            i = i || window.event;
            i.preventDefault ? i.preventDefault() : i.returnValue = false;
            return false
        }

        function c8(i) {
            h(i);
            return bR(i)
        }

        function fG() {
            var e = document.documentElement;
            var i = document.body;
            if (e && (e.scrollTop || e.scrollLeft)) {
                return [e.scrollTop, e.scrollLeft]
            } else {
                if (i) {
                    return [i.scrollTop, i.scrollLeft]
                } else {
                    return [0, 0]
                }
            }
        }

        function fn(hO) {
            if (!hO) {
                return
            }
            hO.onload = hO.onerror = null;
            var T = hO.attributes,
                hN, e, hP;
            if (T) {
                e = T.length;
                for (hN = 0; hN < e; hN += 1) {
                    hP = T[hN].name;
                    if (typeof hO[hP] === "function") {
                        hO[hP] = null
                    }
                }
            }
            T = hO.children;
            if (T) {
                e = T.length;
                for (hN = 0; hN < e; hN += 1) {
                    fn(hO.children[hN])
                }
            }
        }

        function bD(i, hQ, hP) {
            var hO = hQ.lng - hP.lng;
            var hN = hQ.lat - hP.lat;
            if (hO === 0) {
                return Math.abs(i.lng - hQ.lng)
            }
            if (hN === 0) {
                return Math.abs(i.lat - hQ.lat)
            }
            var T = hN / hO;
            var e = hQ.lat - T * hQ.lng;
            return Math.abs(T * i.lng - i.lat + e) / Math.sqrt(T * T + 1)
        }

        function gS(i, e) {
            if (!i || !e) {
                return
            }
            return Math.round(Math.sqrt(Math.pow(i.x - e.x, 2) + Math.pow(i.y - e.y, 2)))
        }

        function bM(i, e) {
            if (!i || !e) {
                return 0
            }
            return Math.round(Math.sqrt(Math.pow(i.lng - e.lng, 2) + Math.pow(i.lat - e.lat, 2)))
        }

        function cY(T, i) {
            var e = Math.round((T.x + i.x) / 2);
            var hN = Math.round((T.y + i.y) / 2);
            return new eg(e, hN)
        }

        function hf(e, T) {
            var i = [];
            T = T || function (hO) {
                return hO
            };
            for (var hN in e) {
                i.push(hN + "=" + T(e[hN]))
            }
            return i.join("&")
        }

        function S(T, i, hP) {
            var hQ = document.createElement(T);
            if (hP) {
                hQ = document.createElementNS(hP, T)
            }
            i = i || {};
            for (var hN in i) {
                var hO = {
                    "for": "htmlFor",
                    "class": "cssClass"
                }[hN] || hN;
                if (hN === "style") {
                    hQ.style.cssText = i[hN];
                    continue
                }
                if (hN === "class") {
                    C.ac(hQ, i[hN]);
                    continue
                }
                if (hQ.setAttribute) {
                    hQ.setAttribute(hO, i[hN])
                } else {
                    try {
                        hQ[hO] = i[hN]
                    } catch (hQ) { }
                }
            }
            return hQ
        }

        function fV(e) {
            if (e.currentStyle) {
                return e.currentStyle
            } else {
                if (e.ownerDocument && e.ownerDocument.defaultView) {
                    return e.ownerDocument.defaultView.getComputedStyle(e, null)
                }
            }
        }

        function bS(e) {
            return typeof e === "function"
        }
        var hk = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

        function gX(hO) {
            var T = "";
            var hV;
            var hT;
            var hR = "";
            var hU;
            var hS;
            var hQ;
            var hP = "";
            var hN = 0;
            var e = /[^A-Za-z0-9+/=]/g;
            if (!hO || e.exec(hO)) {
                return hO
            }
            hO = hO.replace(/[^A-Za-z0-9+/=]/g, "");
            do {
                hU = hk.indexOf(hO.charAt(hN++));
                hS = hk.indexOf(hO.charAt(hN++));
                hQ = hk.indexOf(hO.charAt(hN++));
                hP = hk.indexOf(hO.charAt(hN++));
                hV = (hU << 2) | (hS >> 4);
                hT = ((hS & 15) << 4) | (hQ >> 2);
                hR = ((hQ & 3) << 6) | hP;
                T = T + String.fromCharCode(hV);
                if (hQ !== 64) {
                    T = T + String.fromCharCode(hT)
                }
                if (hP !== 64) {
                    T = T + String.fromCharCode(hR)
                }
                hV = hT = hR = "";
                hU = hS = hQ = hP = ""
            } while (hN < hO.length);
            return T
        } (function (e) {
            if (!e.Utils) {
                e.Utils = {}
            }
            var i = e.Utils;
            i.format = (function () {
                function T(hQ, hP, hR) {
                    var hO = hR[+hP];
                    return typeof (hO) === "function" ? hO(hP) : hO
                }

                function hN(hQ, hP, hR) {
                    var hT = hP;
                    var hU = [];
                    var hO = hP.split(":");
                    if (hO.length === 2) {
                        hT = hO[0];
                        hU.push(hO[1])
                    }
                    var hS = typeof (hR[hT]);
                    if (hS === "function") {
                        return hR[hT].apply(undefined, hU)
                    } else {
                        if (hS === "undefined") {
                            return hQ
                        } else {
                            return String(hR[hT])
                        }
                    }
                }
                return function (hO, hP) {
                    var hR = hP.splice ? T : hN;
                    var hQ = hO.splice ? hO.join("") : hO;
                    return hQ.replace(/{([a-zA-Z0-9_$:.]+)}/g, function (hT, hS) {
                        return hR(hT, hS, hP)
                    })
                }
            })();
            i.ErrorMonitor = function (hN, T, hO) { };
            cX.canUseWebAssembly(function (T) {
                i.canUseWebAssembly = T
            })
        })(bl);

        function f1() {
            return (bs() || ey())
        }

        function bs() {
            var e = navigator.userAgent;
            if (e.indexOf("iPhone") > -1 || e.indexOf("iPad") > -1) {
                return true
            }
            return false
        }

        function ey() {
            var e = navigator.userAgent;
            if (e.indexOf("Android") > -1) {
                return true
            }
            return false
        }

        function dH(e) {
            return e * Math.PI / 180
        }

        function db(e) {
            return e / Math.PI * 180
        }

        function dL(e, hO) {
            var hN = Math.pow(10, hO);
            if (typeof e === "number") {
                return Math.round(e * hN) / hN
            }
            for (var T = 0; T < e.length; T++) {
                e[T] = dL(e[T], hO)
            }
            return e
        }

        function fC(T, i, e) {
            if (T < i) {
                T = i
            } else {
                if (T > e) {
                    T = e
                }
            }
            return T
        }

        function fW(e, i) {
            while (e < 0) {
                e += i
            }
            return e % i
        }

        function d5(i, e) {
            return (i >= 0 && e >= 0) || (i < 0 && e < 0)
        }

        function a2(i) {
            if (i._gl) {
                return i._gl
            }
            var e = {
                alpha: true,
                antialias: false,
                failIfMajorPerformanceCaveat: false,
                preserveDrawingBuffer: false,
                stencil: false
            };
            var T = i.getContext("webgl", e) || i.getContext("experimental-webgl", e);
            i._gl = T;
            return T
        }

        function eH(hN, T) {
            for (var e = 0; e < T.length; e++) {
                C.on(hN, T[e], h)
            }
        }

        function hM(i, T, e) {
            T[e] = i.getUniformLocation(T, e)
        }

        function eY(hO, hP, e, T, i) {
            var hN = "";
            switch (i) {
                case "mat4":
                    hO.uniformMatrix4fv(hP[e], false, T);
                    return;
                case "v3":
                    hN = "uniform3fv";
                    break;
                case "f":
                    hN = "uniform1f";
                    break;
                case "i":
                    hN = "uniform1i";
                    break
            }
            if (hN === "") {
                throw "error"
            }
            hO[hN](hP[e], T)
        }

        function K(hV, e) {
            while (hV < 0) {
                hV += 360
            }
            hV = hV % 360;
            var hN = e.width;
            var hU = e.height;
            var hQ = hN;
            var T = hU;
            if (hV < 90) {
                var i = Math.sin(dH(hV)) * hN;
                var hS = Math.sin(dH(hV)) * hU;
                var hT = Math.cos(dH(hV)) * hN;
                var hP = Math.cos(dH(hV)) * hU;
                var hQ = Math.ceil(hT + hS);
                var T = Math.ceil(i + hP)
            } else {
                if (hV < 180) {
                    var hV = hV - 90;
                    var i = Math.sin(dH(hV)) * hN;
                    var hS = Math.sin(dH(hV)) * hU;
                    var hT = Math.cos(dH(hV)) * hN;
                    var hP = Math.cos(dH(hV)) * hU;
                    var hQ = Math.ceil(i + hP);
                    var T = Math.ceil(hT + hS)
                } else {
                    if (hV < 270) {
                        var hV = hV - 180;
                        var i = Math.sin(dH(hV)) * hN;
                        var hS = Math.sin(dH(hV)) * hU;
                        var hT = Math.cos(dH(hV)) * hN;
                        var hP = Math.cos(dH(hV)) * hU;
                        var hQ = Math.ceil(hT + hS);
                        var T = Math.ceil(i + hP)
                    } else {
                        var hV = hV - 270;
                        var i = Math.sin(dH(hV)) * hN;
                        var hS = Math.sin(dH(hV)) * hU;
                        var hT = Math.cos(dH(hV)) * hN;
                        var hP = Math.cos(dH(hV)) * hU;
                        var hQ = Math.ceil(i + hP);
                        var T = Math.ceil(hT + hS)
                    }
                }
            }
            var hR = hQ - hN;
            var hO = T - hU;
            return [0 - hR / 2, 0 - hO / 2, hN + hR / 2, hU + hO / 2]
        }

        function gB(e) {
            if (e.toDataURL() === gB._blankData) {
                return true
            }
            return false
        }

        function gr(hO, hN, T) {
            var i = [T.lng - hO.lng, T.lat - hO.lat];
            var e = [hN.lng - hO.lng, hN.lat - hO.lat];
            return i[0] * e[1] - i[1] * e[0]
        }

        function ce(hP, hO, T) {
            var e;
            var hQ;
            var hN;
            var i;
            if (hP.lng < hO.lng) {
                e = hP.lng;
                hN = hO.lng
            } else {
                e = hO.lng;
                hN = hP.lng
            } if (hP.lat < hO.lat) {
                hQ = hP.lat;
                i = hO.lat
            } else {
                hQ = hO.lat;
                i = hP.lat
            } if (T.lng < e || T.lng > hN || T.lat < hQ || T.lat > i) {
                return false
            }
            return true
        }

        function gt(hR, hQ, hP, hN) {
            var hO = gr(hP, hN, hR);
            var T = gr(hP, hN, hQ);
            var i = gr(hR, hQ, hP);
            var e = gr(hR, hQ, hN);
            if (hO * T < 0 && i * e < 0) {
                return true
            } else {
                if (hO === 0 && ce(hP, hN, hR)) {
                    return true
                } else {
                    if (T === 0 && ce(hP, hN, hQ)) {
                        return true
                    } else {
                        if (i === 0 && ce(hR, hQ, hP)) {
                            return true
                        } else {
                            if (e === 0 && ce(hR, hQ, hN)) {
                                return true
                            } else {
                                return false
                            }
                        }
                    }
                }
            }
        }

        function hv(T, i) {
            var e = i.parentNode;
            if (e.lastChild === i) {
                e.appendChild(T)
            } else {
                e.insertBefore(T, i.nextSibling)
            }
        }

        function hB(hT, hU) {
            if (hU === 0) {
                return hT
            }
            var hS = 0;
            var hQ = 0;
            if (!hT) {
                throw "异常"
            }
            if (hT.length === 0) {
                return []
            }
            for (var hO = 1, T = hT.length - 1; hO < T; hO++) {
                var hR = bD(hT[hO], hT[0], hT[hT.length - 1]);
                if (hR > hS) {
                    hQ = hO;
                    hS = hR
                }
            }
            var e = [];
            if (hS >= hU) {
                var hW = hT.slice(0, hQ);
                var hV = hT.slice(hQ, hT.length);
                var hP = hB(hW, hU);
                var hN = hB(hV, hU);
                for (var hO = 0, T = hP.length; hO < T; hO++) {
                    e.push(hP[hO])
                }
                for (var hO = 0, T = hN.length; hO < T; hO++) {
                    e.push(hN[hO])
                }
            } else {
                e.push(hT[0]);
                e.push(hT[hT.length - 1])
            }
            return e
        }

        function ez(e) {
            if (Math.log2) {
                return Math.log2(e)
            }
            return Math.log(e) / Math.LN2
        }

        function bo(T, i, e) {
            return Math.min(e, Math.max(i, T))
        }

        function cG(e, i) {
            if (!i) {
                return e
            }
            var hP = i[0];
            var hO = i[1];
            var hN = i[2];
            var T = i[3];
            var hR = [];
            var hQ = [];
            hR[0] = T * e[0] + hN * e[2];
            hR[1] = e[1];
            hR[2] = -hN * e[0] + T * e[2];
            hQ[0] = hR[0];
            hQ[1] = hO * hR[1] - hP * hR[2];
            hQ[2] = hP * hR[1] + hO * hR[2];
            return hQ
        }
        var aN = Math.PI / 180;
        var E = 180 / Math.PI;

        function bw(T) {
            var i = (T - Date.UTC(2000, 0, 1, 12)) / 86400000 / 36525;
            var e = (d3.utcDay.floor(T) - T) / 86400000 * 360 - 180;
            return [e - U(i) * E, gy(i) * E]
        }

        function U(hN) {
            var hO = f3(hN);
            var i = dI(hN);
            var T = aj(hN);
            var hP = Math.tan(fZ(hN) / 2);
            hP *= hP;
            return hP * Math.sin(2 * T) - 2 * hO * Math.sin(i) + 4 * hO * hP * Math.sin(i) * Math.cos(2 * T) - 0.5 * hP * hP * Math.sin(4 * T) - 1.25 * hO * hO * Math.sin(2 * i)
        }

        function gy(e) {
            return Math.asin(Math.sin(fZ(e)) * Math.sin(gV(e)))
        }

        function gV(e) {
            return bd(e) - (0.00569 + 0.00478 * Math.sin((125.04 - 1934.136 * e) * aN)) * aN
        }

        function bd(e) {
            return aj(e) + dO(e)
        }

        function dI(e) {
            return (357.52911 + e * (35999.05029 - 0.0001537 * e)) * aN
        }

        function aj(i) {
            var e = (280.46646 + i * (36000.76983 + i * 0.0003032)) % 360;
            return (e < 0 ? e + 360 : e) / 180 * Math.PI
        }

        function dO(i) {
            var e = dI(i);
            return (Math.sin(e) * (1.914602 - i * (0.004817 + 0.000014 * i)) + Math.sin(e + e) * (0.019993 - 0.000101 * i) + Math.sin(e + e + e) * 0.000289) * aN
        }

        function fZ(e) {
            return e9(e) + 0.00256 * Math.cos((125.04 - 1934.136 * e) * aN) * aN
        }

        function e9(e) {
            return (23 + (26 + (21.448 - e * (46.815 + e * (0.00059 - e * 0.001813))) / 60) / 60) * aN
        }

        function f3(e) {
            return 0.016708634 - e * (0.000042037 + 1.267e-7 * e)
        }

        function a3() {
            return window.devicePixelRatio || 1
        }

        function aD(T) {
            var i;
            var e;
            var hN;
            if (T >= 0) {
                hN = Math.floor(T / 65536) * 65536;
                i = hN;
                e = T - hN
            } else {
                hN = Math.floor(-T / 65536) * 65536;
                i = -hN;
                e = T + hN
            }
            return [i, e]
        }

        function G(e) {
            if (e.lng >= 0 && e.lat >= 0) {
                return new ho(e.lng - 10000000, e.lat - 6000000)
            }
            if (e.lng >= 0 && e.lat < 0) {
                return new ho(e.lng - 10000000, e.lat + 6000000)
            }
            if (e.lng < 0 && e.lat >= 0) {
                return new ho(e.lng + 10000000, e.lat - 6000000)
            }
            if (e.lng < 0 && e.lat < 0) {
                return new ho(e.lng + 10000000, e.lat + 6000000)
            }
        }
        var fx = null;
        if (window.performance && window.performance.now) {
            fx = function () {
                return performance.now()
            }
        } else {
            if (Date.now) {
                fx = function () {
                    return Date.now()
                }
            } else {
                fx = function () {
                    return (new Date).getTime()
                }
            }
        }

        function bI(hN, e, i) {
            var T = "mouseWheel";
            if (C.Platform.macintosh) {
                if (!isNaN(hN) && (hN < 10 || hN !== 120) && (e % 1 === 0 && e < 5)) {
                    T = "padScroll"
                }
                if (C.Browser.firefox && (e % 1 === 0 && e < 5 && i === 0)) {
                    T = "padScroll"
                }
            }
            if (C.Browser.safari && hN === 12) {
                T = "mouseWheel"
            }
            return T
        }

        function dd(hW, hR) {
            var hV = hW[0];
            var hU = hW[1];
            var hN = false;
            for (var hQ = 0, hP = hR.length - 2; hQ < hR.length; hQ += 2) {
                var hT = hR[hQ];
                var hO = hR[hQ + 1];
                var hS = hR[hP];
                var T = hR[hP + 1];
                var e = ((hO > hU) !== (T > hU)) && (hV < (hS - hT) * (hU - hO) / (T - hO) + hT);
                if (e) {
                    hN = !hN
                }
                hP = hQ
            }
            return hN
        }

        function cB(T, e, i, hN) {
            hN = hN || 0.4;
            if (T > i) {
                T = Math.pow(T - i + 1, hN) + i - 1
            } else {
                if (T < e) {
                    T = e - Math.pow(e - T + 1, hN) + 1
                }
            }
            return T
        }

        function gh(hR) {
            var hP = "";
            for (var T = 0; T < hR.length; T++) {
                var hS = hR.charCodeAt(T) << 1;
                var e = hS.toString(2);
                var hO = e.length;
                var hV = e;
                if (hO < 8) {
                    hV = "00000000" + e;
                    hV = hV.substr(e.length, 8)
                }
                hP += hV
            }
            var hT = 5 - hP.length % 5;
            var hN = [];
            for (var T = 0; T < hT; T++) {
                hN[T] = "0"
            }
            hP = hN.join("") + hP;
            var hU = [];
            for (var T = 0; T < hP.length / 5; T++) {
                var hS = hP.substr(T * 5, 5);
                var hQ = parseInt(hS, 2) + 50;
                hU.push(String.fromCharCode(hQ))
            }
            return hU.join("") + hT.toString()
        }

        function aB(T, i) {
            var e = bl.TILE_VERSION || window.TILE_VERSION;
            if (!e || !e[T] || !e[T][i] || !e[T][i].version || !e[T][i].updateDate) {
                e = e0.tvc
            }
            return {
                ver: e[T][i].version,
                udt: e[T][i].updateDate
            }
        }

        function fw() {
            var e = bl.MSV || window.MSV;
            if (!e || !e.mapstyle || !e.mapstyle.updateDate || !e.mapstyle.version) {
                e = e0.msv
            }
            return {
                ver: e.mapstyle.version,
                udt: e.mapstyle.updateDate
            }
        }

        function eo(e, hO) {
            var hN = e.slice(0);
            for (var T = 0; T < hN.length; T++) {
                hN[T] += hO
            }
            return hN
        }
        var a1 = null;

        function bv(e) {
            if (a1) {
                return
            }
            e.fire(new a8("onloadtile"));
            a1 = setTimeout(function () {
                a1 = null
            }, 1000)
        }

        function eX() {
            if (co("//map.baidu.com") || co("//maps.baidu.com") || co("//ditu.baidu.com")) {
                return true
            }
            return false
        }
        dt.inMapHost = eX();
        if (typeof window._inMapHost === "boolean") {
            dt.inMapHost = window._inMapHost
        }

        function co(i) {
            var T = window.location;
            var e = document.createElement("a");
            e.href = i;
            return e.hostname === T.hostname && e.port === T.port && e.protocol === T.protocol
        }

        function d7() { }
        C.extend(d7, {
            Request: {
                INITIAL: -1,
                WAITING: 0,
                LOADED: 1,
                COMPLETED: 2
            },
            Dependency: {
                poly: ["marker"],
                hotspot: ["poly"],
                infowindow: ["marker", "hotspot"],
                simpleInfowindow: ["marker"],
                tools: ["marker", "poly"],
                mapgl: ["glcommon", "poly"],
                earth: ["glcommon"],
                control: ["scommon"],
                scommon: [],
                localSearch: ["scommon"],
                otherSearch: ["scommon"],
                route: ["scommon"],
                buslineSearch: ["route"],
                autocomplete: ["scommon"]
            },
            MD5Mapping: {
                control: "m2kmeu",
                marker: "n3gqvc",
                poly: "gnac1i",
                infowindow: "daijjm",
                simpleInfowindow: "t4or0p",
                hotspot: "aauoqd",
                menu: "q4hnb5",
                tools: "qpgsov",
                oppc: "wkakxc",
                oppcgl: "0iiiyf",
                mapgl: "u33h1a",
                markeranimation: "hdgo4a",
                earth: "o54zxr",
                glcommon: "0byyok",
                localSearch: "mbhk2k",
                scommon: "xr3lbo",
                otherSearch: "w4avtd",
                route: "t0fg22",
                buslineSearch: "o5bvfa",
                autocomplete: "akggpd"
            },
            Config: {
                baseUrl: e0.apiHost + "/getmodules?v=1.0&type=webgl",
                jsModPath: (dt.inMapHost ? "" : e0.mapHost) + "/res/newui/",
                timeout: 5000
            },
            delayFlag: false,
            Module: {
                modules: {},
                modulesNeedToLoad: []
            },
            _getMd5ModsStr: function (hP) {
                var hO = [];
                for (var hR = 0, T = hP.length; hR < T; hR++) {
                    var hQ = hP[hR];
                    var e = this.MD5Mapping[hQ];
                    var hN = "$" + hQ + "$";
                    if (e !== hN) {
                        hO.push(hQ + "_" + e)
                    }
                }
                return hO.join(",")
            },
            load: function (i, hP, hN) {
                var e = this.getModuleInfo(i);
                if (e.status === this.Request.COMPLETED) {
                    if (hN === true) {
                        hP()
                    }
                } else {
                    if (e.status === this.Request.INITIAL) {
                        this.combine(i);
                        this.addToLoadQueue(i);
                        var T = this;
                        if (T.delayFlag === false) {
                            T.delayFlag = true;
                            setTimeout(function () {
                                var hQ = T.Config.baseUrl + "&mod=" + T._getMd5ModsStr(T.Module.modulesNeedToLoad);
                                hi.load(hQ);
                                T.Module.modulesNeedToLoad.length = 0;
                                T.delayFlag = false
                            }, 1)
                        }
                        e.status = this.Request.WAITING;

                        function hO(hS) {
                            var hR = T.getModuleInfo(i);
                            if (hR.status !== T.Request.COMPLETED) {
                                if (window.map) {
                                    var hQ = new a8("onmod_timeout");
                                    hQ.timeout = hS / 1000;
                                    hQ.moduleName = i;
                                    window.map.fire(hQ)
                                }
                            }
                        }
                        setTimeout(hO, this.Config.timeout, this.Config.timeout);
                        setTimeout(hO, this.Config.timeout * 2, this.Config.timeout * 2)
                    }
                    if (hP) {
                        e.callbacks.push(hP)
                    }
                }
            },
            combine: function (e) {
                if (e && this.Dependency[e]) {
                    var hN = this.Dependency[e];
                    for (var T = 0; T < hN.length; T++) {
                        this.combine(hN[T]);
                        if (!this.Module.modules[hN[T]]) {
                            this.addToLoadQueue(hN[T])
                        }
                    }
                }
            },
            addToLoadQueue: function (e) {
                var i = this.getModuleInfo(e);
                if (i.status === this.Request.INITIAL) {
                    i.status = this.Request.WAITING;
                    this.Module.modulesNeedToLoad.push(e)
                }
            },
            run: function (T, hN) {
                var hR = this.getModuleInfo(T);
                var hU = this.Dependency[T];
                if (hU) {
                    for (var hP = 0; hP < hU.length; hP++) {
                        var hQ = this.getModuleInfo(hU[hP]);
                        if (hQ.status !== this.Request.COMPLETED) {
                            hQ.modsNeedToRun.push({
                                name: T,
                                code: hN
                            });
                            return
                        }
                    }
                }
                try {
                    eval(hN)
                } catch (hS) {
                    return
                }
                hR.status = this.Request.COMPLETED;
                for (var hP = 0, hO = hR.callbacks.length; hP < hO; hP++) {
                    hR.callbacks[hP]()
                }
                hR.callbacks.length = 0;
                for (hP = 0; hP < hR.modsNeedToRun.length; hP++) {
                    var hT = hR.modsNeedToRun[hP];
                    this.run(hT.name, hT.code)
                }
                hR.modsNeedToRun.length = 0
            },
            getModuleInfo: function (i) {
                var e;
                if (!this.Module.modules[i]) {
                    this.Module.modules[i] = {
                        status: this.Request.INITIAL,
                        callbacks: [],
                        modsNeedToRun: []
                    }
                }
                e = this.Module.modules[i];
                return e
            }
        });
        window._jsload = function (hO, hP) {
            var i = d7.getModuleInfo(hO);
            i.status = d7.Request.LOADED;
            if (hP !== "") {
                d7.run(hO, hP)
            } else {
                if (window.map) {
                    var e = new a8("ongetmodules_fail");
                    e.moduleName = hO;
                    window.map.fire(e)
                }
                var T = document.createElement("script");
                var hN = d7.MD5Mapping[hO];
                T.src = d7.Config.jsModPath + hO + "_" + hN + ".js";
                document.getElementsByTagName("head")[0].appendChild(T)
            }
        };

        function ac() {
            this._timeData = {}
        }
        var e6;
        if (typeof window !== "undefined") {
            e6 = window
        } else {
            e6 = self
        }
        ac.prototype.mark = function (e) {
            this._timeData[e] = this._getTime()
        };
        ac.prototype.getMark = function (e) {
            return this._timeData[e]
        };
        ac.prototype.getTime = function (i, e) {
            return parseFloat((this._timeData[e] - this._timeData[i]).toFixed(2))
        };
        ac.prototype.print = function () { };
        ac.prototype.clear = function () {
            this._timeData = {}
        };
        if (e6.performance && e6.performance.now) {
            ac.prototype._getTime = function () {
                return performance.now()
            }
        } else {
            ac.prototype._getTime = function () {
                return Date.now()
            }
        } ! function (i, T) {
            T(i.d3 = i.d3 || {})
        }(window, function (iu) {
            function iM(iS, iT, T, it) {
                function e(i) {
                    return iS(i = new Date(+i)), i
                }
                return e.floor = e, e.ceil = function (i) {
                    return iS(i = new Date(i - 1)), iT(i, 1), iS(i), i
                }, e.round = function (i) {
                    var iU = e(i),
                        iV = e.ceil(i);
                    return iV - i > i - iU ? iU : iV
                }, e.offset = function (i, iU) {
                    return iT(i = new Date(+i), null == iU ? 1 : Math.floor(iU)), i
                }, e.range = function (iV, i, iU) {
                    var iW = [];
                    if (iV = e.ceil(iV), iU = null == iU ? 1 : Math.floor(iU), !(i > iV && iU > 0)) {
                        return iW
                    }
                    do {
                        iW.push(new Date(+iV))
                    } while (iT(iV, iU), iS(iV), i > iV);
                    return iW
                }, e.filter = function (i) {
                    return iM(function (iU) {
                        for (; iS(iU), !i(iU);) {
                            iU.setTime(iU - 1)
                        }
                    }, function (iU, iV) {
                        for (; --iV >= 0;) {
                            for (; iT(iU, 1), !i(iU);) { }
                        }
                    })
                }, T && (e.count = function (i, iU) {
                    return iw.setTime(+i), iA.setTime(+iU), iS(iw), iS(iA), Math.floor(T(iw, iA))
                }, e.every = function (i) {
                    return i = Math.floor(i), isFinite(i) && i > 0 ? i > 1 ? e.filter(it ? function (iU) {
                        return it(iU) % i === 0
                    } : function (iU) {
                        return e.count(0, iU) % i === 0
                    }) : e : null
                }), e
            }

            function iB(e) {
                return iM(function (i) {
                    i.setDate(i.getDate() - (i.getDay() + 7 - e) % 7), i.setHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setDate(i.getDate() + 7 * T)
                }, function (i, T) {
                    return (T - i - (T.getTimezoneOffset() - i.getTimezoneOffset()) * iv) / iJ
                })
            }

            function ir(e) {
                return iM(function (i) {
                    i.setUTCDate(i.getUTCDate() - (i.getUTCDay() + 7 - e) % 7), i.setUTCHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setUTCDate(i.getUTCDate() + 7 * T)
                }, function (i, T) {
                    return (T - i) / iJ
                })
            }
            var iw = new Date,
                iA = new Date,
                iH = iM(function () { }, function (i, T) {
                    i.setTime(+i + T)
                }, function (i, T) {
                    return T - i
                });
            iH.every = function (e) {
                return e = Math.floor(e), isFinite(e) && e > 0 ? e > 1 ? iM(function (i) {
                    i.setTime(Math.floor(i / e) * e)
                }, function (i, T) {
                    i.setTime(+i + T * e)
                }, function (i, T) {
                    return (T - i) / e
                }) : iH : null
            };
            var iQ = iH.range,
                iO = 1000,
                iv = 60000,
                iL = 3600000,
                iD = 86400000,
                iJ = 604800000,
                hT = iM(function (e) {
                    e.setTime(Math.floor(e / iO) * iO)
                }, function (i, T) {
                    i.setTime(+i + T * iO)
                }, function (i, T) {
                    return (T - i) / iO
                }, function (e) {
                    return e.getUTCSeconds()
                }),
                iN = hT.range,
                iC = iM(function (e) {
                    e.setTime(Math.floor(e / iv) * iv)
                }, function (i, T) {
                    i.setTime(+i + T * iv)
                }, function (i, T) {
                    return (T - i) / iv
                }, function (e) {
                    return e.getMinutes()
                }),
                h1 = iC.range,
                im = iM(function (i) {
                    var T = i.getTimezoneOffset() * iv % iL;
                    0 > T && (T += iL), i.setTime(Math.floor((+i - T) / iL) * iL + T)
                }, function (i, T) {
                    i.setTime(+i + T * iL)
                }, function (i, T) {
                    return (T - i) / iL
                }, function (e) {
                    return e.getHours()
                }),
                iI = im.range,
                ib = iM(function (e) {
                    e.setHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setDate(i.getDate() + T)
                }, function (i, T) {
                    return (T - i - (T.getTimezoneOffset() - i.getTimezoneOffset()) * iv) / iD
                }, function (e) {
                    return e.getDate() - 1
                }),
                hS = ib.range,
                h8 = iB(0),
                ia = iB(1),
                hO = iB(2),
                h6 = iB(3),
                hV = iB(4),
                iq = iB(5),
                iz = iB(6),
                hQ = h8.range,
                ip = ia.range,
                hZ = hO.range,
                il = h6.range,
                iE = hV.range,
                io = iq.range,
                iP = iz.range,
                iG = iM(function (e) {
                    e.setDate(1), e.setHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setMonth(i.getMonth() + T)
                }, function (i, T) {
                    return T.getMonth() - i.getMonth() + 12 * (T.getFullYear() - i.getFullYear())
                }, function (e) {
                    return e.getMonth()
                }),
                iR = iG.range,
                h5 = iM(function (e) {
                    e.setMonth(0, 1), e.setHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setFullYear(i.getFullYear() + T)
                }, function (i, T) {
                    return T.getFullYear() - i.getFullYear()
                }, function (e) {
                    return e.getFullYear()
                });
            h5.every = function (e) {
                return isFinite(e = Math.floor(e)) && e > 0 ? iM(function (i) {
                    i.setFullYear(Math.floor(i.getFullYear() / e) * e), i.setMonth(0, 1), i.setHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setFullYear(i.getFullYear() + T * e)
                }) : null
            };
            var hY = h5.range,
                ix = iM(function (e) {
                    e.setUTCSeconds(0, 0)
                }, function (i, T) {
                    i.setTime(+i + T * iv)
                }, function (i, T) {
                    return (T - i) / iv
                }, function (e) {
                    return e.getUTCMinutes()
                }),
                id = ix.range,
                ic = iM(function (e) {
                    e.setUTCMinutes(0, 0, 0)
                }, function (i, T) {
                    i.setTime(+i + T * iL)
                }, function (i, T) {
                    return (T - i) / iL
                }, function (e) {
                    return e.getUTCHours()
                }),
                h9 = ic.range,
                h7 = iM(function (e) {
                    e.setUTCHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setUTCDate(i.getUTCDate() + T)
                }, function (i, T) {
                    return (T - i) / iD
                }, function (e) {
                    return e.getUTCDate() - 1
                }),
                h4 = h7.range,
                h3 = ir(0),
                h2 = ir(1),
                h0 = ir(2),
                hX = ir(3),
                hW = ir(4),
                hR = ir(5),
                hP = ir(6),
                hN = h3.range,
                ik = h2.range,
                iK = h0.range,
                iy = hX.range,
                iF = hW.range,
                ij = hR.range,
                ii = hP.range,
                ih = iM(function (e) {
                    e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setUTCMonth(i.getUTCMonth() + T)
                }, function (i, T) {
                    return T.getUTCMonth() - i.getUTCMonth() + 12 * (T.getUTCFullYear() - i.getUTCFullYear())
                }, function (e) {
                    return e.getUTCMonth()
                }),
                ig = ih.range,
                hU = iM(function (e) {
                    e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setUTCFullYear(i.getUTCFullYear() + T)
                }, function (i, T) {
                    return T.getUTCFullYear() - i.getUTCFullYear()
                }, function (e) {
                    return e.getUTCFullYear()
                });
            hU.every = function (e) {
                return isFinite(e = Math.floor(e)) && e > 0 ? iM(function (i) {
                    i.setUTCFullYear(Math.floor(i.getUTCFullYear() / e) * e), i.setUTCMonth(0, 1), i.setUTCHours(0, 0, 0, 0)
                }, function (i, T) {
                    i.setUTCFullYear(i.getUTCFullYear() + T * e)
                }) : null
            };
            var ie = hU.range;
            iu.timeInterval = iM, iu.timeMillisecond = iH, iu.timeMilliseconds = iQ, iu.utcMillisecond = iH, iu.utcMilliseconds = iQ, iu.timeSecond = hT, iu.timeSeconds = iN, iu.utcSecond = hT, iu.utcSeconds = iN, iu.timeMinute = iC, iu.timeMinutes = h1, iu.timeHour = im, iu.timeHours = iI, iu.timeDay = ib, iu.timeDays = hS, iu.timeWeek = h8, iu.timeWeeks = hQ, iu.timeSunday = h8, iu.timeSundays = hQ, iu.timeMonday = ia, iu.timeMondays = ip, iu.timeTuesday = hO, iu.timeTuesdays = hZ, iu.timeWednesday = h6, iu.timeWednesdays = il, iu.timeThursday = hV, iu.timeThursdays = iE, iu.timeFriday = iq, iu.timeFridays = io, iu.timeSaturday = iz, iu.timeSaturdays = iP, iu.timeMonth = iG, iu.timeMonths = iR, iu.timeYear = h5, iu.timeYears = hY, iu.utcMinute = ix, iu.utcMinutes = id, iu.utcHour = ic, iu.utcHours = h9, iu.utcDay = h7, iu.utcDays = h4, iu.utcWeek = h3, iu.utcWeeks = hN, iu.utcSunday = h3, iu.utcSundays = hN, iu.utcMonday = h2, iu.utcMondays = ik, iu.utcTuesday = h0, iu.utcTuesdays = iK, iu.utcWednesday = hX, iu.utcWednesdays = iy, iu.utcThursday = hW, iu.utcThursdays = iF, iu.utcFriday = hR, iu.utcFridays = ij, iu.utcSaturday = hP, iu.utcSaturdays = ii, iu.utcMonth = ih, iu.utcMonths = ig, iu.utcYear = hU, iu.utcYears = ie, Object.defineProperty(iu, "__esModule", {
                value: !0
            })
        });

        function gj(e) {
            this._elemType = e;
            this._objCollection = {}
        }
        gj.prototype.get = function () {
            var i = null;
            for (var e in this._objCollection) {
                if (this._objCollection[e] && this._objCollection[e]._free === true) {
                    this._objCollection[e]._free = false;
                    return this._objCollection[e]
                }
            }
            i = S(this._elemType);
            e = bl.getGUID("obj_pool_");
            this._objCollection[e] = i;
            return i
        };
        gj.prototype.free = function (e) {
            if (!e) {
                return
            }
            e._free = true;
            if (e.tagName.toLowerCase() === "img") {
                e.src = "";
                e.crossOrigin = null;
                e.onload = e.onerror = null
            }
        };
        gj.prototype.clear = function () {
            for (var e in this._objCollection) {
                if (this._objCollection[e] && this._objCollection[e].tagName.toLowerCase === "img") {
                    this._objCollection[e].onload = this._objCollection[e].onerror = null
                }
            }
            this._objCollection = {}
        };
        var gw = {
            get: function (i, hO, e, T) {
                var hN = new XMLHttpRequest();
                hN.open("GET", i, true);
                hN.timeout = 10000;
                hN.ontimeout = function () {
                    T && T()
                };
                hN.onreadystatechange = function (hP) {
                    if (this.readyState === 4) {
                        if (this.status === 200) {
                            hO && hO(hN.responseText)
                        } else {
                            e && e()
                        }
                    }
                };
                hN.send()
            },
            post: function (i, hP, hO, e, T) {
                var hN = new XMLHttpRequest();
                hN.open("POST", i, true);
                hN.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                hN.timeout = 10000;
                hN.ontimeout = function () {
                    T && T()
                };
                hN.onreadystatechange = function (hQ) {
                    if (this.readyState === 4) {
                        if (this.status === 200) {
                            hO && hO(hN.responseText, hP)
                        } else {
                            e && e()
                        }
                    }
                };
                hN.send(hP);
                return hN
            }
        };
        var hi = (function (e) {
            function i(hP, T, hO) {
                var hN = S("script", {
                    src: hP,
                    type: "text/javascript",
                    charset: "utf-8"
                });
                if (hN.addEventListener) {
                    hN.addEventListener("load", function (hR) {
                        var hQ = hR.target;
                        hQ.parentNode.removeChild(hQ);
                        T && T()
                    }, false);
                    hN.addEventListener("error", function (hQ) {
                        hO && hO(null)
                    }, false)
                } else {
                    if (hN.attachEvent) {
                        hN.attachEvent("onreadystatechange", function (hR) {
                            var hQ = window.event.srcElement;
                            if (hQ && (hQ.readyState === "loaded" || hQ.readyState === "complete")) {
                                hQ.parentNode.removeChild(hQ)
                            }
                            T && T()
                        })
                    }
                }
                e.getElementsByTagName("head")[0].appendChild(hN)
            }
            return {
                load: function (hQ, T, hN) {
                    if (typeof hQ === "string") {
                        i(hQ, T, hN)
                    } else {
                        if (hQ.length > 0) {
                            var hP = hQ.length;
                            for (var hO = 0; hO < hP; hO++) {
                                i(hQ[hO], function () {
                                    hP--;
                                    if (hP === 0 && T) {
                                        T()
                                    }
                                })
                            }
                        }
                    }
                }
            }
        })(window.document);

        function cI() { }
        cI.instances = {};
        cI.getInstance = function (i, T) {
            if (cI.instances[i]) {
                return cI.instances[i]
            }
            var e = new df(i, T);
            cI.instances[i] = e;
            return e
        };

        function df(e, i) {
            this._name = e;
            this._baseZoom = 18;
            this._opts = {
                tileSize: 256
            };
            C.extend(this._opts, i || {})
        }
        df.mapZoomBaseIndex = [8, 8, 8, 8, 7, 7, 6, 6, 5, 5, 4, 3, 3, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0];
        df.baseScaleZoom = [19, 17, 15, 12, 10, 9, 7, 5, 3];
        df.baseScaleZoomMercatorSize = [512, 2048, 4096, 32768, 65536, 262144, 1048576, 4194304, 8388608];
        df.mapZoomBaseZoomMapping = [3, 3, 3, 3, 5, 5, 7, 7, 9, 9, 10, 12, 12, 12, 15, 15, 17, 17, 19, 19, 19, 19, 19, 19, 19, 19];
        df.mapZoomStartZoomMapping = [3, 3, 3, 3, 4, 4, 6, 6, 8, 8, 10, 11, 11, 11, 14, 14, 16, 16, 18, 18, 18, 18, 18, 18, 18, 18];
        df.baseScaleTileSize = [1024, 1024, 512, 512, 256, 512, 512, 512, 256];
        df.mapZoomTileSize = [256, 256, 256, 256, 256, 512, 256, 512, 256, 512, 256, 256, 512, 1024, 256, 512, 512, 1024, 512, 1024, 2048, 4096, 4096 * 2, 4096 * 2 * 2, 4096 * 2 * 2 * 2, 4096 * 2 * 2 * 2 * 2];
        df.baseZoomInfo = {
            "3": [3],
            "5": [4, 5],
            "7": [6, 7],
            "9": [8, 9],
            "10": [10],
            "12": [11, 12, 13],
            "15": [14, 15],
            "17": [16, 17],
            "19": [18, 19, 20, 21, 22, 23, 24, 25]
        };
        df.prototype = {
            getName: function () {
                return this._name
            },
            getTileSize: function (e) {
                e = Math.floor(e);
                if (e < 3) {
                    e = 3
                }
                if (this._name === "na") {
                    return df.mapZoomTileSize[e]
                }
                return this._opts.tileSize
            },
            getBaseTileSize: function (i) {
                i = Math.floor(i);
                if (this._name === "na") {
                    var e = df.mapZoomBaseZoomMapping[i];
                    return df.mapZoomTileSize[e]
                }
                return this._opts.tileSize
            },
            getDataZoom: function (e) {
                e = Math.floor(e);
                if (this._name === "na") {
                    return df.mapZoomBaseZoomMapping[e]
                }
                return e
            },
            getZoomUnits: function (e) {
                return Math.pow(2, (this._baseZoom - e))
            },
            getMercatorSize: function (T, i) {
                if (this._name === "na") {
                    T = Math.floor(T);
                    var e = df.mapZoomBaseIndex[T];
                    return df.baseScaleZoomMercatorSize[e]
                }
                return this._opts.tileSize * this.getZoomUnits(i)
            },
            getBaseZoom: function () {
                return this._baseZoom
            },
            getParentTile: function (hN, hT, hS, T, i) {
                if (this._name === "na") {
                    var hO = df.baseZoomInfo[hS];
                    T--;
                    if (hO.indexOf(T) > -1) {
                        return {
                            col: hN,
                            row: hT,
                            zoom: hS,
                            useZoom: T
                        }
                    } else {
                        var hQ = df.mapZoomBaseIndex[hS];
                        var hP = df.baseScaleZoom[hQ + 1];
                        if (!hP) {
                            return null
                        }
                        var hR = this.getFactorByZooms(hP, hS);
                        var e = df.baseZoomInfo[hP];
                        return {
                            col: Math.floor(hN / hR),
                            row: Math.floor(hT / hR),
                            zoom: hP,
                            useZoom: e[e.length - 1]
                        }
                    }
                    return null
                }
                if (hS - 1 < i) {
                    return null
                }
                return {
                    col: Math.floor(hN / 2),
                    row: Math.floor(hT / 2),
                    zoom: hS - 1,
                    useZoom: hS - 1
                }
            },
            getChildTiles: function (hO, hQ, e, T, hX, h3) {
                if (this._name === "na") {
                    var hN = df.baseZoomInfo[e];
                    T += h3;
                    if (hN.indexOf(T) > -1) {
                        return [{
                            col: hO,
                            row: hQ,
                            zoom: e,
                            useZoom: T
                        }]
                    } else {
                        var h1 = 0;
                        var hY = e;
                        while (h1 < h3) {
                            var h2 = df.mapZoomBaseIndex[hY];
                            var hS = df.baseScaleZoom[h2 - 1];
                            if (!hS) {
                                return null
                            }
                            var hT = df.baseZoomInfo[hS];
                            if (hT[h3 - 1]) {
                                var hU = [];
                                var hW = this.getFactorByZooms(e, hS);
                                var i = hO * hW;
                                var hV = hQ * hW;
                                for (var h0 = 0; h0 < hW; h0++) {
                                    var hP = i + h0;
                                    for (var hZ = 0; hZ < hW; hZ++) {
                                        var hR = hV + hZ;
                                        hU.push({
                                            col: hP,
                                            row: hR,
                                            zoom: hS,
                                            useZoom: hT[h3 - 1]
                                        })
                                    }
                                }
                                return hU
                            }
                            h1 += hT.length;
                            if (h3 === hT.length) {
                                hY = hS
                            }
                        }
                    }
                    return null
                }
                var hU = [];
                if (e + h3 > hX) {
                    return null
                }
                var hW = Math.pow(2, h3);
                var i = hO * hW;
                var hV = hQ * hW;
                var hS = e + h3;
                var hU = [];
                for (var h0 = 0; h0 < 2; h0++) {
                    var hP = i + h0;
                    for (var hZ = 0; hZ < 2; hZ++) {
                        var hR = hV + hZ;
                        hU.push({
                            col: hP,
                            row: hR,
                            zoom: hS,
                            useZoom: hS
                        })
                    }
                }
                return hU
            },
            getFactorByZooms: function (i, hN) {
                var T = df.mapZoomBaseIndex[i];
                var hO = df.mapZoomBaseIndex[hN];
                var e = df.baseScaleZoomMercatorSize[T];
                var hP = df.baseScaleZoomMercatorSize[hO];
                return e / hP
            }
        };
        var a5 = {};
        var ag = ["swiftshader", "microsoft basic render driver"];
        var ci = ["intel", "nvidia", "amd", "apple", "geforce"];

        function ds(e) {
            e = e.toLowerCase();
            if (ag.indexOf(e) >= 0) {
                return true
            }
            if (e.indexOf("mobile") >= 0) {
                return true
            }
            return false
        }

        function fA(T) {
            T = T.toLowerCase();
            for (var e = 0; e < ci.length; e++) {
                if (T.indexOf(ci[e]) >= 0) {
                    return true
                }
            }
            return false
        }

        function dV(e) {
            if (!e) {
                return false
            }
            if (ds(e)) {
                return false
            }
            if (fA(e)) {
                return true
            }
            return false
        }
        a5.ifEnableEarth = function (i) {
            var e = a5.ifEnableEarth;
            if (!i && typeof e._enable === "boolean") {
                return e._enable
            }
            if (a5.ifSupportWebGL()) {
                e._enable = true;
                return true
            }
            e._enable = false;
            return false
        };
        a5.ifEnableWebGLMap = function (i) {
            var e = a5.ifEnableWebGLMap;
            if (!i && typeof e._enable === "boolean") {
                return e._enable
            }
            if (a5.ifSupportWebGL()) {
                if (dt.inMapHost) {
                    e._enable = true;
                    return true
                } else {
                    if (window.Blob || window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder) {
                        e._enable = true;
                        return true
                    } else {
                        e._enable = false;
                        return false
                    }
                }
            }
            e._enable = false;
            return false
        };
        a5.params = {};
        a5.ifSupportWebGL = function () {
            var i = a5.ifSupportWebGL;
            if (typeof i._supportWebGL === "boolean") {
                return i._supportWebGL
            }
            if (!window.WebGLRenderingContext) {
                i._supportWebGL = false;
                return false
            }
            var T = document.createElement("canvas");
            T.width = 300;
            T.height = 150;
            var hO = null;
            var hU = {
                alpha: true,
                antialias: false,
                failIfMajorPerformanceCaveat: true,
                preserveDrawingBuffer: false,
                stencil: false
            };
            try {
                hO = T.getContext("webgl", hU) || T.getContext("experimental-webgl", hU)
            } catch (hQ) {
                i._supportWebGL = false
            }
            if (hO === null) {
                i._supportWebGL = false
            } else {
                i._supportWebGL = true;
                var hS = hO.getExtension("WEBGL_debug_renderer_info");
                if (hS) {
                    var hR = hO.getParameter(hS.UNMASKED_RENDERER_WEBGL);
                    if (dV(hR) === true) {
                        i._supportWebGL = true
                    }
                    var hT = hO.getParameter(hS.UNMASKED_VENDOR_WEBGL);
                    i._renderer = hR;
                    i._vendor = hT
                }
                if (!hS && C.Browser.firefox) {
                    i._supportWebGL = true
                }
                if (!hS && C.Platform.macintosh) {
                    i._supportWebGL = true
                }
                if (hO.drawingBufferWidth !== T.width || hO.drawingBufferHeight !== T.height) {
                    i._supportWebGL = false
                }
                if (hO.getParameter(hO.MAX_VERTEX_TEXTURE_IMAGE_UNITS) < 4) {
                    i._supportWebGL = false
                }
                var hN = hO.getParameter(hO.MAX_TEXTURE_SIZE);
                a5.params.maxTextureSize = hN;
                if (hN < 4096) {
                    i._supportWebGL = false
                }
                var hP = hO.getParameter(hO.MAX_TEXTURE_IMAGE_UNITS);
                if (hP < 8) {
                    i._supportWebGL = false
                }
                if (!hO.getShaderPrecisionFormat || hO.getShaderPrecisionFormat(hO.FRAGMENT_SHADER, hO.HIGH_FLOAT).precision < 23) {
                    i._supportWebGL = false
                }
            }
            return i._supportWebGL
        };
        a5.ifSupportCanvas2d = function () {
            var hO = a5.ifSupportCanvas2d;
            if (typeof hO.supportCanvas2d === "boolean") {
                return hO.supportCanvas2d
            }
            var T = document.createElement("canvas");
            var i = null;
            try {
                i = T.getContext("2d")
            } catch (hN) {
                hO.supportCanvas2d = false
            }
            if (i === null) {
                hO.supportCanvas2d = false
            } else {
                hO.supportCanvas2d = true
            }
            return hO.supportCanvas2d
        };
        a5.ifEnableCanvas2dMap = function () {
            var i = navigator.userAgent;
            var e = 0;
            var hN = 0;
            var hO = 0;
            if (/macintosh/ig.test(i)) {
                var T = 0;
                if (/(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(i) && !/chrome/i.test(i)) {
                    T = parseInt((RegExp["$1"] || RegExp["$2"]), 10)
                }
                if (T > 0) {
                    return false
                }
                return true
            }
            if (/windows nt (\d+\.\d)/ig.test(i)) {
                hN = parseFloat(RegExp.$1);
                if (hN >= 6.1) {
                    if (/chrome\/(\d+\.\d)/i.test(i)) {
                        e = parseFloat(RegExp.$1);
                        if (e >= 31) {
                            return true
                        }
                    }
                    if (/MSIE (\d+(\.\d+)?)/.test(i)) {
                        hO = parseFloat(RegExp.$1);
                        if (hO >= 10) {
                            return true
                        }
                    }
                    if (/Firefox/.test(i)) {
                        return true
                    }
                    if (/rv:11.0/ig.test(i)) {
                        return true
                    }
                    if (/edge/ig.test(i)) {
                        return true
                    }
                }
            }
            return false
        };
        a5.ifSupportCSS3 = function (hR, i) {
            var hQ = document.createElement("div");
            var hP = "Webkit Moz O ms".split(" ");
            var e = hP.length;
            var T = "";
            var hN = hQ.style;
            if (hR in hN) {
                T = hR
            }
            hR = hR.replace(/^[a-z]/, function (hS) {
                return hS.toUpperCase()
            });
            while (e--) {
                var hO = hP[e] + hR;
                if (hO in hN) {
                    T = hO;
                    break
                }
            }
            if (i) {
                return T
            } else {
                return T.length > 0 ? true : false
            }
        };
        a5.isModernBrowser = a5.ifSupportCanvas2d() && a5.ifSupportCSS3("transform");

        function eW(i, e) {
            this._size = i;
            this._curSize = 0;
            this._cache = {};
            this._least = null;
            this._most = null;
            this._options = {
                clearCallback: null,
                removeOldCallback: null
            };
            e = e || {};
            for (var T in e) {
                this._options[T] = e[T]
            }
            this._getDataTimes = 0;
            this._hitTimes = 0
        }
        eW.prototype.setData = function (hN, hP) {
            var i = this._cache;
            var T = this._size;
            if (T === 0) {
                return
            }
            var e = this._curSize;
            if (e === T) {
                this._removeOld()
            }
            var hO;
            if (!i[hN]) {
                hO = {
                    key: hN,
                    data: hP,
                    older: null,
                    newwer: null
                };
                i[hN] = hO;
                if (this._least === null) {
                    this._least = hO
                }
                if (this._most === null) {
                    this._most = hO
                }
                this._curSize++
            } else {
                hO = i[hN];
                hO.data = hP;
                if (this._most === hO) {
                    return
                }
                hO.older && (hO.older.newer = hO.newer);
                hO.newer && (hO.newer.older = hO.older);
                if (this._least === hO) {
                    this._least = hO.newer
                }
            } if (this._most && this._most !== hO) {
                this._most.newer = hO;
                hO.older = this._most;
                this._most = hO;
                hO.newer = null
            }
        };
        eW.prototype.getData = function (e) {
            var i = this._cache[e];
            this._getDataTimes++;
            if (i) {
                this._hitTimes++;
                var T = i.data;
                if (this._most === i) {
                    return T
                }
                i.older && (i.older.newer = i.newer);
                i.newer && (i.newer.older = i.older);
                if (this._least === i) {
                    this._least = i.newer
                }
                this._most.newer = i;
                i.older = this._most;
                i.newer = null;
                this._most = i;
                return T
            }
            return null
        };
        eW.prototype.getAllData = function () {
            return this._cache
        };
        eW.prototype.getHitRate = function () {
            return this._hitTimes / this._getDataTimes
        };
        eW.prototype.removeData = function (i) {
            var e = this._cache;
            var T = e[i];
            if (!T) {
                return
            }
            if (this._options.clearCallback) {
                this._options.clearCallback(T.data, T.key)
            }
            T.older && (T.older.newer = T.newer);
            T.newer && (T.newer.older = T.older);
            if (this._least === T) {
                this._least = T.newer
            }
            if (this._most === T) {
                this._most = T.older
            }
            delete e[i];
            this._curSize--
        };
        eW.prototype._removeOld = function () {
            var e = this._cache;
            var hN = Math.round(this._size * 0.6);
            var T = 0;
            while (this._least && T < hN) {
                var i = this._least;
                this._least = i.newer;
                i.newer && (i.newer.older = null);
                if (this._options.clearCallback) {
                    this._options.clearCallback(i.data, i.key)
                }
                delete e[i.key];
                T++
            }
            this._curSize -= T;
            if (this._options.removeOldCallback) {
                this._options.removeOldCallback()
            }
        };
        eW.prototype.clear = function () {
            var e = this._cache;
            var i = this._least;
            if (this._options.clearCallback) {
                while (i) {
                    this._options.clearCallback(i.data, i.key);
                    i = i.newer
                }
            }
            this._least = this._most = null;
            this._cache = {};
            this._curSize = 0
        };
        eW.prototype.forEach = function (e) {
            var i = this._least;
            while (i) {
                e(i.data);
                i = i.newer
            }
        };
        eW.prototype.clearExcept = function (i) {
            var e = this._cache;
            var T = this._least;
            while (T) {
                if (!i[T.key]) {
                    if (this._options.clearCallback) {
                        this._options.clearCallback(T.data, T.key)
                    }
                    T.older && (T.older.newer = T.newer);
                    T.newer && (T.newer.older = T.older);
                    if (this._least === T) {
                        this._least = T.newer
                    }
                    if (this._most === T) {
                        this._most = T.older
                    }
                    delete e[T.key];
                    this._curSize--
                }
                T = T.newer
            }
        };
        var gW = {
            parseHexToRgbaArray: function (hP) {
                var hQ = hP.replace("#", "");
                if (hQ.length === 3) {
                    hQ += "f"
                } else {
                    if (hQ.length === 6) {
                        hQ += "ff"
                    }
                }
                var e = [];
                var hO = hQ.length;
                var hN = hO === 8 ? 2 : 1;
                for (var T = 0; T < hO; T = T + hN) {
                    if (hN === 2) {
                        e.push(parseInt(hQ.slice(T, T + 2), 16))
                    } else {
                        e.push(parseInt(hQ.slice(T, T + 1) + hQ.slice(T, T + 1), 16))
                    }
                }
                return e
            },
            parseRgbaStrToArray: function (i) {
                var e = [0, 0, 0, 255];
                if (i.indexOf("rgba(") === 0) {
                    var hN = i.replace("rgba(", "").replace(")", "");
                    var T = hN.split(",");
                    e[0] = parseInt(T[0], 10);
                    e[1] = parseInt(T[1], 10);
                    e[2] = parseInt(T[2], 10);
                    e[3] = Math.round(parseFloat(T[3]) * 255)
                } else {
                    if (i.indexOf("rgb(") === 0) {
                        var hN = i.replace("rgb(", "").replace(")", "");
                        var hO = hN.split(",");
                        e[0] = parseInt(hO[0], 10);
                        e[1] = parseInt(hO[1], 10);
                        e[2] = parseInt(hO[2], 10);
                        e[3] = 255
                    }
                }
                return e
            },
            parseHexAndOpacityToRgbaArray: function (hO, hP) {
                var T = [];
                var hS = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
                var hR = hO.toLowerCase();
                if (hS.test(hR)) {
                    if (hR.length === 4) {
                        var e = "#";
                        for (var hQ = 1; hQ < 4; hQ++) {
                            e += hR.slice(hQ, hQ + 1).concat(hR.slice(hQ, hQ + 1))
                        }
                        hR = e
                    }
                    for (var hN = 1; hN < 7; hN += 2) {
                        T.push(parseInt(hR.slice(hN, hN + 2), 16))
                    }
                    T.push(hP)
                }
                return T
            },
            parseCSSColor: function (e) {
                if (e.indexOf("#") === 0) {
                    return gW.parseHexToRgbaArray(e)
                }
                return gW.parseRgbaStrToArray(e)
            },
            rgbToHSV: function (hO) {
                var e = hO[0] / 255;
                var T = hO[1] / 255;
                var hP = hO[2] / 255;
                var hS = Math.max(e, T, hP);
                var hN = Math.min(e, T, hP);
                var hR = hS - hN;
                var i;
                if (hR === 0) {
                    i = 0
                } else {
                    if (hS === e) {
                        i = 60 * (((T - hP) / hR) % 6)
                    } else {
                        if (hS === T) {
                            i = 60 * ((hP - e) / hR + 2)
                        } else {
                            if (hS === hP) {
                                i = 60 * ((e - T) / hR + 4)
                            }
                        }
                    }
                }
                var hT = hS === 0 ? 0 : (hR / hS);
                var hQ = hS;
                while (i < 0) {
                    i += 360
                }
                return [i, hT, hQ]
            },
            hsvToRGB: function (hN) {
                var hR = hN[2] * hN[1];
                var T = hR * (1 - Math.abs((hN[0] / 60) % 2 - 1));
                var i = hN[2] - hR;
                var hO = hN[0];
                var hQ;
                var hP;
                var e;
                if (hO >= 0 && hO < 60) {
                    hQ = hR;
                    hP = T;
                    e = 0
                } else {
                    if (hO >= 60 && hO < 120) {
                        hQ = T;
                        hP = hR;
                        e = 0
                    } else {
                        if (hO >= 120 && hO < 180) {
                            hQ = 0;
                            hP = hR;
                            e = T
                        } else {
                            if (hO >= 180 && hO < 240) {
                                hQ = 0;
                                hP = T;
                                e = hR
                            } else {
                                if (hO >= 240 && hO < 300) {
                                    hQ = T;
                                    hP = 0;
                                    e = hR
                                } else {
                                    if (hO >= 300 && hO < 360) {
                                        hQ = hR;
                                        hP = 0;
                                        e = T
                                    }
                                }
                            }
                        }
                    }
                }
                hQ = (hQ + i) * 255 > 255 ? 255 : (hQ + i) * 255;
                hP = (hP + i) * 255 > 255 ? 255 : (hP + i) * 255;
                e = (e + i) * 255 > 255 ? 255 : (e + i) * 255;
                return [Math.round(hQ), Math.round(hP), Math.round(e)]
            }
        };
        var cy = {
            request: function (hQ, hN, i, hS, T) {
                var hO = (Math.random() * 100000).toFixed(0);
                bl._rd["_cbk" + hO] = function (hT) {
                    if (hT.result && hT.result["error"] && hT.result["error"] === 202) {
                        alert("该AK因为恶意行为已经被管理员封禁！");
                        return
                    }
                    i = i || {};
                    hQ && hQ(hT, i);
                    delete bl._rd["_cbk" + hO]
                };
                hS = hS || "";
                var hR;
                if (i && i.useEncodeURI) {
                    hR = hf(hN, encodeURI)
                } else {
                    hR = hf(hN, encodeURIComponent)
                }
                var hP = this;
                var e = e0.apiHost + "/" + hS + "?" + hR + "&ie=utf-8&oue=1&fromproduct=jsapi";
                if (!T) {
                    e += "&res=api"
                }
                e += "&callback=" + ex + "._rd._cbk" + hO;
                e += "&ak=" + ga;
                hi.load(e)
            }
        };
        bl._rd = {};
        var D = {
            request: function (hN, e) {
                if (e) {
                    var T = (Math.random() * 100000).toFixed(0);
                    BMapGL._rd["_cbk" + T] = function (hO) {
                        e && e(hO);
                        delete BMapGL._rd["_cbk" + T]
                    };
                    hN += "&callback=BMapGL._rd._cbk" + T
                }
                var i = S("script", {
                    src: hN,
                    type: "text/javascript",
                    charset: "utf-8"
                });
                if (i.addEventListener) {
                    i.addEventListener("load", function (hP) {
                        var hO = hP.target;
                        hO.parentNode.removeChild(hO)
                    }, false);
                    i.addEventListener("error", function (hO) {
                        e && e([, , , , ,])
                    }, false)
                } else {
                    if (i.attachEvent) {
                        i.attachEvent("onreadystatechange", function (hP) {
                            var hO = window.event.srcElement;
                            if (hO && (hO.readyState == "loaded" || hO.readyState == "complete")) {
                                hO.parentNode.removeChild(hO)
                            }
                        })
                    }
                }
                document.getElementsByTagName("head")[0].appendChild(i);
                i = null
            }
        };

        function a4() {
            this._map = null;
            this._container;
            this._type = "control";
            this.blockInfoWindow = true;
            this._visible = true
        }
        a4.inherits(ea, "Control");
        C.extend(a4.prototype, {
            initialize: function (e) {
                this._map = e;
                if (this._container) {
                    if (this._opts && this._opts.container) {
                        this._opts.container.appendChild(this._container)
                    } else {
                        e.container.appendChild(this._container)
                    }
                    return this._container
                }
                return
            },
            _i: function (e) {
                if (!this._container && this.initialize && bS(this.initialize)) {
                    this._container = this.initialize(e)
                }
                this._opts = this._opts || {
                    printable: false
                };
                this._setStyle();
                this._setPosition();
                if (this._container) {
                    this._container._jsobj = this
                }
            },
            _setStyle: function () {
                var i = this._container;
                if (i) {
                    var e = i.style;
                    e.position = "absolute";
                    e.zIndex = this._cZIndex || "10";
                    e.MozUserSelect = "none";
                    if (!this._opts.printable) {
                        C.ac(i, "BMap_noprint")
                    }
                    C.on(i, "contextmenu", c8)
                }
            },
            remove: function () {
                this._map = null;
                if (!this._container) {
                    return
                }
                this._container.parentNode && this._container.parentNode.removeChild(this._container);
                this._container._jsobj = null;
                this._container = null
            },
            _render: function (e) {
                if (this._opts && this._opts.container) {
                    this._container = dF(this._opts.container, '<div unselectable="on"></div>')
                } else {
                    var i = '<div unselectable="on"></div>';
                    if (e && e.config.autoSafeArea && bs()) {
                        this._safeAreaContainer = dF(this._map.container, i);
                        this._safeAreaContainer.style.position = "absolute";
                        this._safeAreaContainer.style.bottom = "env(safe-area-inset-bottom)";
                        this._container = dF(this._safeAreaContainer, i)
                    } else {
                        this._container = dF(this._map.container, i)
                    }
                } if (this._visible === false) {
                    this._container.style.display = "none"
                }
                return this._container
            },
            _setPosition: function () {
                this.setAnchor(this._opts.anchor)
            },
            setAnchor: function (hN) {
                if (this.anchorFixed || typeof hN !== "number" || isNaN(hN) || hN < BMAP_ANCHOR_TOP_LEFT || hN > BMAP_ANCHOR_BOTTOM_RIGHT) {
                    hN = this.defaultAnchor
                }
                this._opts.offset = this._opts.offset || this.defaultOffset;
                var T = this._opts.anchor;
                this._opts.anchor = hN;
                if (!this._container) {
                    return
                }
                var hP = this._container;
                var e = this._opts.offset.width;
                var hO = this._opts.offset.height;
                hP.style.left = hP.style.top = hP.style.right = hP.style.bottom = "auto";
                switch (hN) {
                    case BMAP_ANCHOR_TOP_LEFT:
                        hP.style.top = hO + "px";
                        hP.style.left = e + "px";
                        break;
                    case BMAP_ANCHOR_TOP_RIGHT:
                        hP.style.top = hO + "px";
                        hP.style.right = e + "px";
                        break;
                    case BMAP_ANCHOR_BOTTOM_LEFT:
                        hP.style.bottom = hO + "px";
                        hP.style.left = e + "px";
                        break;
                    case BMAP_ANCHOR_BOTTOM_RIGHT:
                        hP.style.bottom = hO + "px";
                        hP.style.right = e + "px";
                        break;
                    default:
                        break
                }
                var i = ["TL", "TR", "BL", "BR"];
                C.rc(this._container, "anchor" + i[T]);
                C.ac(this._container, "anchor" + i[hN])
            },
            getAnchor: function () {
                return this._opts.anchor
            },
            setOffset: function (e) {
                if (!e) {
                    return
                }
                this._opts = this._opts || {};
                this._opts.offset = new d6(e.width, e.height);
                if (!this._container) {
                    return
                }
                this.setAnchor(this._opts.anchor)
            },
            getOffset: function () {
                return this._opts.offset
            },
            getDom: function () {
                return this._container
            },
            show: function () {
                if (this._visible === true) {
                    return
                }
                this._visible = true;
                if (this._container) {
                    this._container.style.display = ""
                }
                this.dispatchEvent(new a8("onshow"))
            },
            hide: function () {
                if (this._visible === false) {
                    return
                }
                this._visible = false;
                if (this._container) {
                    this._container.style.display = "none"
                }
                this.dispatchEvent(new a8("onhide"))
            },
            isPrintable: function () {
                return !!this._opts.printable
            },
            isVisible: function () {
                if (!this._container && !this._map) {
                    return false
                }
                return !!this._visible
            },
            _asyncLoadCode: function () {
                var e = this;
                d7.load("control", function () {
                    if (e._asyncDraw) {
                        e._asyncDraw()
                    }
                })
            }
        });
        var hz = {
            TOP_LEFT: 0,
            TOP_RIGHT: 1,
            BOTTOM_LEFT: 2,
            BOTTOM_RIGHT: 3
        };
        bl.ControlAnchor = hz;
        window.BMAP_ANCHOR_TOP_LEFT = 0;
        window.BMAP_ANCHOR_TOP_RIGHT = 1;
        window.BMAP_ANCHOR_BOTTOM_LEFT = 2;
        window.BMAP_ANCHOR_BOTTOM_RIGHT = 3;

        function dE(e) {
            a4.call(this);
            e = e || {};
            this._opts = {
                printable: false
            };
            C.extend(this._opts, e);
            this._copyrightCollection = [];
            this.defaultAnchor = BMAP_ANCHOR_BOTTOM_LEFT;
            this.defaultOffset = new d6(5, 2);
            this.setAnchor(e.anchor);
            this._canShow = true;
            this.sateMapStyle = false;
            this.blockInfoWindow = false;
            this._asyncLoadCode()
        }
        dE.inherits(a4, "CopyrightControl");
        C.extend(dE.prototype, {
            initialize: function (e) {
                this._map = e;
                return this._container
            },
            addCopyright: function (hN) {
                var e = {
                    minZoom: 0,
                    bounds: null,
                    content: "",
                    mapType: ""
                };
                for (var T in hN) {
                    e[T] = hN[T]
                }
                if (this._map) {
                    var hQ = e.minZoom;
                    if (hQ === -1 || hQ < this._map.getMinZoom() || hQ > this._map.getMaxZoom()) {
                        e.minZoom = this._map.getMinZoom()
                    }
                    if (e.mapType !== "" && !b3[e.mapType]) {
                        e.mapType = BMAPGL_NORMAL_MAP
                    }
                }
                var hO = this.getCopyright(hN.id);
                if (hO) {
                    for (var hP in e) {
                        hO[hP] = e[hP]
                    }
                } else {
                    this._copyrightCollection.push(e)
                }
            },
            getCopyright: function (hN) {
                for (var T = 0, e = this._copyrightCollection.length; T < e; T++) {
                    if (this._copyrightCollection[T].id === hN) {
                        return this._copyrightCollection[T]
                    }
                }
            },
            addSateMapStyle: function () {
                this.sateMapStyle = true;
                if (this._container) {
                    C.ac(this._container, "BMap_cpyCtrl_w")
                }
            },
            removeSateMapStyle: function () {
                this.sateMapStyle = false;
                if (this._container) {
                    C.rc(this._container, "BMap_cpyCtrl_w")
                }
            }
        });

        function d8(e) {
            a4.call(this);
            e = e || {};
            this.canCheckSize = e.canCheckSize === false ? false : true;
            this.curCityName = "";
            this.curCityCode = "";
            this.defaultOffset = new d6(10, 10);
            this.defaultAnchor = hz.TOP_LEFT;
            this.onChangeBefore = [];
            this.onChangeAfter = [];
            this.onChangeSuccess = [];
            this._opts = {
                printable: false,
                offset: e.offset || this.defaultOffset,
                anchor: e.anchor || this.defaultAnchor,
                expand: !!(e.expand)
            };
            if (e.onChangeBefore && bS(e.onChangeBefore)) {
                this.onChangeBefore.push(e.onChangeBefore)
            }
            if (e.onChangeAfter && bS(e.onChangeAfter)) {
                this.onChangeAfter.push(e.onChangeAfter)
            }
            if (e.onChangeSuccess && bS(e.onChangeSuccess)) {
                this.onChangeSuccess.push(e.onChangeSuccess)
            }
            this.setAnchor(e.anchor);
            this._asyncLoadCode()
        }
        d8.inherits(a4, "CityListControl");
        C.extend(d8.prototype, {
            initialize: function (e) {
                this._map = e;
                return this._container
            }
        });

        function hd(e) {
            a4.call(this);
            e = e || {};
            this._opts = {
                printable: false
            };
            this._opts = C.extend(C.extend(this._opts, {
                unit: "metric"
            }), e);
            this.defaultAnchor = BMAP_ANCHOR_BOTTOM_LEFT;
            this.defaultOffset = new d6(81, 18);
            if (f1()) {
                this.defaultOffset = new d6(75, 10)
            }
            this.setAnchor(e.anchor);
            this._units = {
                metric: {
                    name: "metric",
                    conv: 1,
                    incon: 1000,
                    u1: "米",
                    u2: "公里"
                },
                us: {
                    name: "us",
                    conv: 3.2808,
                    incon: 5280,
                    u1: "英尺",
                    u2: "英里"
                }
            };
            this.sateMapStyle = false;
            if (!this._units[this._opts.unit]) {
                this._opts.unit = "metric"
            }
            this._scaleText = null;
            this._numberArray = {};
            this._asyncLoadCode()
        }
        window.BMAP_UNIT_METRIC = "metric";
        window.BMAP_UNIT_IMPERIAL = "us";
        hd.inherits(a4, "ScaleControl");
        C.extend(hd.prototype, {
            initialize: function (e) {
                this._map = e;
                return this._container
            },
            setUnit: function (e) {
                this._opts.unit = this._units[e] && this._units[e].name || this._opts.unit
            },
            getUnit: function () {
                return this._opts.unit
            },
            addSateMapStyle: function () {
                this.sateMapStyle = true;
                var e = this._container;
                if (e) {
                    C.ac(e.children[0], "dark")
                }
            },
            removeSateMapStyle: function () {
                this.sateMapStyle = false;
                var e = this._container;
                if (e) {
                    C.rc(e.children[0], "dark")
                }
            }
        });
        window.BMAP_NAVIGATION_CONTROL_LARGE = 0;
        window.BMAP_NAVIGATION_CONTROL_SMALL = 1;
        window.BMAP_NAVIGATION_CONTROL_PAN = 2;
        window.BMAP_NAVIGATION_CONTROL_ZOOM = 3;
        window.BMAP_NAVIGATION_CONTROL_ANIM = 4;

        function dq(e) {
            a4.call(this);
            e = e || {};
            this._opts = {
                printable: false
            };
            C.extend(this._opts, e);
            this.controlHeight = [{
                width: 65,
                height: 227,
                zoomHeight: 227,
                zoomWidth: 37,
                sliderHeight: 180
            }, {
                width: 65,
                height: 47,
                zoomHeight: (this._opts.forceNew === true) ? 56 : 47,
                zoomWidth: 37,
                sliderHeight: 0
            }, {
                width: 37,
                height: 57,
                zoomHeight: 0,
                zoomWidth: 0,
                sliderHeight: 0
            }, {
                width: 26,
                height: 56,
                zoomHeight: 56,
                zoomWidth: 6,
                sliderHeight: 0
            }, {
                width: 56,
                height: 47,
                zoomHeight: 47,
                zoomWidth: 37,
                sliderHeight: 180
            }];
            this.defaultAnchor = BMAP_ANCHOR_TOP_LEFT;
            this.defaultOffset = new d6(10, 10);
            this.setAnchor(e.anchor);
            this.setType(e.type);
            this._maxTotalZoomLv = 19;
            this._minZoomLevel = -1;
            this._maxZoomLevel = -1;
            this._totalZoomLv = -1;
            this._sliderInterval = 10;
            this._sliderHeight = 180;
            this._minBarY = 1;
            this._maxBarY = -1;
            this._curBarY = -1;
            this._zoomDom = null;
            this._zoomBtnDom = null;
            this._sliderDom = null;
            this._sliderBaseDom = null;
            this._cZIndex = "1100";
            this._asyncLoadCode()
        }
        dq.inherits(a4, "NavigationControl");
        C.extend(dq.prototype, {
            initialize: function (e) {
                this._map = e;
                return this._container
            },
            setType: function (e) {
                if (typeof e == "number" && e >= BMAP_NAVIGATION_CONTROL_LARGE && e <= BMAP_NAVIGATION_CONTROL_ANIM) {
                    this._opts.type = e
                } else {
                    this._opts.type = BMAP_NAVIGATION_CONTROL_LARGE
                }
            },
            getType: function () {
                return this._opts.type
            }
        });

        function bz(i) {
            a4.call(this);
            i = i || {};
            this._opts = {
                printable: false
            };
            this.defaultAnchor = BMAP_ANCHOR_TOP_RIGHT;
            this.defaultOffset = new d6(10, 10);
            this.setAnchor(i.anchor);
            this._opts = C.extend(C.extend(this._opts, {
                offset: this.defaultOffset,
                enableSwitch: true
            }), i);
            var e = this;
            d7.load("control", function () {
                e._asyncDraw()
            })
        }
        bz.inherits(a4, "MapTypeControl");
        C.extend(bz.prototype, {
            initialize: function (e) {
                this._map = e;
                return this._container
            },
            showStreetLayer: function (e) {
                this._map.showStreetLayer(e)
            }
        });

        function cv(e) {
            a4.call(this);
            e = e || {};
            this._opts = {};
            this._opts = C.extend(this._opts, e);
            this._zoomInDisabled = false;
            this._zoomOutDisabled = false;
            this._zoomInTapped = false;
            this._zoomOutTapped = false;
            this.defaultAnchor = hz.BOTTOM_RIGHT;
            this.defaultOffset = new d6(15, 20);
            this.setAnchor(e.anchor);
            this._asyncLoadCode()
        }
        cv.inherits(a4, "ZoomControl");
        C.extend(cv.prototype, {
            initialize: function (e) {
                this._map = e;
                return this._container
            }
        });

        function bx(e) {
            a4.call(this);
            e = e || {};
            this._opts = {
                autoZoom: true,
                autoViewport: true
            };
            this._opts = C.extend(this._opts, e);
            this.defaultAnchor = hz.BOTTOM_LEFT;
            this.defaultOffset = new d6(10, 50);
            this.watchPosition = this._opts.watchPosition || false;
            this.useCompass = this._opts.useCompass || false;
            this.locMarker = null;
            this.locLevel = 16;
            this.setAnchor(this._opts.anchor);
            this.onLocationStart = e.onLocationStart || null;
            this._asyncLoadCode()
        }
        bx.inherits(a4, "LocationControl");
        C.extend(bx.prototype, {
            initialize: function (e) {
                this._map = e;
                return this._container
            },
            startLocation: function () {
                this._startLocationCalled = true
            },
            stopLocationTrace: function () { },
            setOptions: function (e) {
                e = e || {};
                C.extend(this._opts, e)
            }
        });

        function af(e) {
            a4.call(this);
            e = e || {};
            this._opts = {};
            this._opts = C.extend(this._opts, e);
            this.defaultAnchor = hz.BOTTOM_LEFT;
            this.defaultOffset = new d6(5, 15);
            if (f1()) {
                this.defaultOffset = new d6(10, 10)
            }
            this.setAnchor(e.anchor)
        }
        af.inherits(a4, "LogoControl");
        C.extend(af.prototype, {
            initialize: function (i) {
                this._map = i;
                var e = this._container = document.createElement("div");
                e.innerHTML = '<img src="' + e0.apiHost + '/images/logo_hd.png"  style="height:21px;width:62px;"/>';
                i.getContainer().appendChild(e);
                return e
            }
        });

        function gx(e, i) {
            this._map = e;
            this._indoorInfo = i;
            this._visible = true;
            this._adjustVisible = true;
            this._isMobile = f1();
            this._sizeConfig = {
                FLOOR_BTN_HEIGHT: this._isMobile ? 35 : 26,
                SWITCH_ARROW_HEIGHT: this._isMobile ? 20 : 15
            };
            this._init()
        }
        gx.prototype._init = function () {
            this._render();
            this._bindDom();
            this._bind();
            this._adjustDisplayHeight();
            var e = new a8("onindoor_bar_show");
            e.uid = this._indoorInfo.uid;
            this._map.dispatchEvent(e)
        };
        gx.prototype._render = function () {
            if (!this._indoorInfo) {
                return
            }
            var hR = this._isMobile;
            var e = this._div = S("div");
            C.ac(e, "floor-select-container");
            hR && C.ac(e, "mobile");
            hR && C.ac(e, "all-border-radius");
            var i = this._btnTop = S("button");
            C.ac(i, "floor-switch-top");
            C.ac(i, "top-border-radius");
            var hP = S("div");
            C.ac(hP, "floor-switch-top-icon");
            i.appendChild(hP);
            var hO = this._btnBottom = S("button");
            var T = S("div");
            C.ac(T, "floor-switch-bottom-icon");
            hO.appendChild(T);
            C.ac(hO, "floor-switch-bottom");
            C.ac(hO, "bottom-border-radius");
            var hN = this._floorsContainer = S("div");
            C.ac(hN, "floors-container");
            hN.appendChild(this._createFloorsDom());
            this._div.appendChild(i);
            this._div.appendChild(hN);
            this._div.appendChild(hO);
            var hS = 0;
            if (this._btnTop.style.display === "") {
                hS = 2 * this._sizeConfig.SWITCH_ARROW_HEIGHT
            }
            this._div.style.height = parseInt(this._floorsContainer.style.height, 10) + hS + "px";
            this._map.getContainer().appendChild(this._div);
            if (!hR) {
                var hQ = this;
                setTimeout(function () {
                    hQ._div.style.right = "20px"
                }, 20)
            }
        };
        gx.prototype._createFloorsDom = function () {
            if (!this._indoorInfo) {
                return
            }
            var T = this._ol = S("ol");
            var hP = this._indoorInfo.currentFloor;
            for (var hO = this._indoorInfo.floors.length - 1; hO >= 0; hO--) {
                var hQ = this._indoorInfo.floors[hO].floorName;
                var e = S("li");
                var hN = S("button");
                C.ac(hN, "btn-select-floor");
                if (hO === hP) {
                    C.ac(hN, "selected")
                }
                hN.setAttribute("data-floor", hO);
                hN.innerHTML = hQ;
                e.appendChild(hN);
                T.appendChild(e)
            }
            return T
        };
        gx.prototype._updateUI = function () {
            if (!this._ol) {
                this._render();
                this._bind();
                this._adjustDisplayHeight();
                return
            }
            this._ol = null;
            this._ol = this._createFloorsDom();
            this._floorsContainer.innerHTML = "";
            this._floorsContainer.appendChild(this._ol);
            this._adjustDisplayHeight()
        };
        gx.prototype._bindDom = function () {
            var e = this;
            C.on(this._floorsContainer, "click", function (hN) {
                var T = hN.target || hN.srcElement;
                if (T.tagName.toLowerCase() === "button") {
                    e._map.showIndoor(e._indoorInfo.uid, parseInt(T.getAttribute("data-floor"), 10));
                    var i = new a8("onindoor_bar_click");
                    i.uid = e._indoorInfo.uid;
                    e._map.dispatchEvent(i)
                }
            });
            C.on(this._floorsContainer, "mouseover", function (T) {
                var i = T.target;
                if (i.tagName.toLowerCase() === "button") {
                    C.ac(i, "hover")
                }
            });
            C.on(this._floorsContainer, "mouseout", function (T) {
                var i = T.target;
                if (i.tagName.toLowerCase() === "button") {
                    C.rc(i, "hover")
                }
            });
            C.on(this._floorsContainer, "touchstart", function (T) {
                var i = T.target;
                if (i.tagName.toLowerCase() === "button") {
                    C.ac(i, "onmousedown")
                }
            });
            C.on(this._floorsContainer, "touchend", function (T) {
                var i = T.target;
                if (i.tagName.toLowerCase() === "button") {
                    C.rc(i, "onmousedown")
                }
            });
            C.on(this._btnTop, "mouseover", function (i) {
                if (this._disable) {
                    return
                }
                C.ac(this, "hover")
            });
            C.on(this._btnTop, "mouseout", function (i) {
                C.rc(this, "hover")
            });
            C.on(this._btnBottom, "mouseover", function (i) {
                if (this._disable) {
                    return
                }
                C.ac(this, "hover")
            });
            C.on(this._btnBottom, "mouseout", function (i) {
                C.rc(this, "hover")
            });
            C.on(this._btnTop, "touchstart", function (i) {
                if (this.className.indexOf("disable") > -1) {
                    return
                }
                C.ac(this, "onmousedown")
            });
            C.on(this._btnTop, "touchend", function (i) {
                C.rc(this, "onmousedown")
            });
            C.on(this._btnBottom, "touchstart", function (i) {
                if (this.className.indexOf("disable") > -1) {
                    return
                }
                C.ac(this, "onmousedown")
            });
            C.on(this._btnBottom, "touchend", function (i) {
                C.rc(this, "onmousedown")
            });
            C.on(this._btnTop, "click", function (i) {
                e._setBarSliderTop(parseInt(e._ol.style.top, 10) + 26)
            });
            C.on(this._btnBottom, "click", function (i) {
                e._setBarSliderTop(parseInt(e._ol.style.top, 10) - 26)
            });
            C.on(this._div, "mousemove", h);
            C.on(this._div, "wheel", c8);
            C.on(this._div, "mousewheel", c8);
            this._map.addEventListener("resize", function () {
                e._adjustDisplayHeight()
            })
        };
        gx.prototype._adjustDisplayHeight = function () {
            if (!this._indoorInfo) {
                return
            }
            var hP = this._map.getSize().height;
            var hQ = this._sizeConfig.FLOOR_BTN_HEIGHT;
            var hR = hP - 291 - 100;
            if (this._isMobile) {
                hR = hP - 12 - 108 - this._map.config.bottomOffset
            }
            var e = this._indoorInfo.floors.length;
            var T = e * hQ;
            var hN = e;
            var hT = 0;
            var hU = this._floorsContainer.children[0];
            if (T > hR) {
                this._showArrow = true;
                C.rc(hU.children[0].children[0], "top-border-radius");
                C.rc(hU.children[e - 1].children[0], "bottom-border-radius")
            } else {
                this._showArrow = false;
                C.ac(hU.children[0].children[0], "top-border-radius");
                C.ac(hU.children[e - 1].children[0], "bottom-border-radius")
            }
            while (T > hR) {
                if (hN === 0) {
                    break
                }
                hN--;
                hT = 2 * this._sizeConfig.SWITCH_ARROW_HEIGHT;
                T = hN * hQ + hT
            }
            this._currentDisplayHeight = T;
            if (hN < 3) {
                this._setAdjustVisbile(false)
            } else {
                this._setAdjustVisbile(true)
            }
            this._floorsContainer.style.height = hN * hQ + "px";
            var hO = this._indoorInfo.currentFloor;
            var i = e - hO;
            var hS = hO - 1;
            this._div.style.height = parseInt(this._floorsContainer.style.height, 10) + hT + "px";
            var hV = -(e - (hO + Math.round(hN / 2))) * hQ;
            this._setBarSliderTop(hV);
            if (hN < e) {
                C.show(this._btnTop);
                C.show(this._btnBottom)
            } else {
                C.hide(this._btnTop);
                C.hide(this._btnBottom);
                this._setBarSliderTop(0)
            } if (this._isMobile) {
                this._div.style.bottom = 108 + this._map.config.bottomOffset + "px"
            }
        };
        gx.prototype._setBarSliderTop = function (hN) {
            var T = 26;
            var i = this._indoorInfo.floors.length;
            var e = i * T;
            if (this._currentDisplayHeight) {
                if (this._showArrow) {
                    e = this._currentDisplayHeight - 30
                } else {
                    e = this._currentDisplayHeight
                }
            }
            if (e - hN >= i * T) {
                hN = e - i * T;
                C.ac(this._btnBottom, "disable");
                C.rc(this._btnBottom, "hover");
                this._btnBottom._disable = true
            } else {
                C.rc(this._btnBottom, "disable");
                this._btnBottom._disable = false
            } if (hN >= 0) {
                hN = 0;
                C.ac(this._btnTop, "disable");
                C.rc(this._btnTop, "hover");
                this._btnTop._disable = true
            } else {
                C.rc(this._btnTop, "disable");
                this._btnTop._disable = false
            }
            this._ol.style.top = hN + "px"
        };
        gx.prototype._setAdjustVisbile = function (e) {
            if (this._adjustVisible === e) {
                return
            }
            this._adjustVisible = e;
            if (e && this._visible) {
                this._div.style.right = "20px"
            } else {
                this._div.style.right = "-30px"
            }
        };
        gx.prototype._bind = function () {
            var i = this._map;
            var e = this;
            i.on("indoor_status_changed", function (hR) {
                if (e._visible === false) {
                    return
                }
                var T = e._ol;
                var hP = hR.uid;
                if (!hP) {
                    return
                }
                var hQ = hR.floor;
                for (var hO = 0; hO < T.children.length; hO++) {
                    var hN = T.children[hO].children[0];
                    if (parseInt(hN.getAttribute("data-floor"), 10) === hQ) {
                        C.ac(hN, "selected")
                    } else {
                        C.rc(hN, "selected")
                    }
                }
            });
            i.on("zoomend", function (T) {
                if (this.getZoom() < 17) {
                    e._setAdjustVisbile(false)
                } else {
                    e._setAdjustVisbile(true)
                }
            })
        };
        gx.prototype.setInfo = function (e) {
            if (this._indoorInfo && this._indoorInfo.uid === e.uid) {
                return
            }
            this._indoorInfo = e;
            this._updateUI()
        };
        gx.prototype.show = function () {
            if (this._visible === true) {
                return
            }
            this._visible = true;
            if (!this._isMobile) {
                this._div.style.right = "20px"
            } else {
                this._div.style.display = ""
            }
            var e = new a8("onindoor_bar_show");
            e.uid = this._indoorInfo.uid;
            this._map.dispatchEvent(e)
        };
        gx.prototype.hide = function () {
            if (this._visible === false) {
                return
            }
            this._visible = false;
            if (!this._isMobile) {
                this._div.style.right = "-30px"
            } else {
                this._div.style.display = "none"
            }
        };

        function eR() {
            this._opts = {};
            this.defaultOffset = new d6(2, 80);
            this.defaultAnchor = BMAP_ANCHOR_BOTTOM_RIGHT;
            this._firstAnimation = true
        }
        eR.inherits(a4, "NavigationControl3D");
        C.extend(eR.prototype, {
            initialize: function (T) {
                this._map = T;
                this._createDom();
                this._bindDom();
                this._bind();
                if (!f1()) {
                    this._headingControl = new hC(this._map, this._div)
                }
                this._tiltControl = new ep(this._map, this._div);
                this._render();
                var i = this._map.getMapType();
                var e = this;
                if (i === "B_EARTH_MAP" || this._map._renderType === "webgl") {
                    e._div.style.opacity = "1";
                    e._div.style.visibility = "visible"
                } else {
                    e._div.style.opacity = "0";
                    e._div.style.visibility = "hidden"
                }
                return this._container
            },
            _createDom: function () {
                var i = this._div = document.createElement("div");
                this._container = i;
                var e = i.style;
                e.position = "absolute";
                e.zIndex = 5;
                e.width = "52px";
                e.height = "82px";
                e.right = "-3px";
                e.bottom = "79px";
                e.opacity = "0";
                e.visibility = "hidden";
                e.WebkitTransition = e.transition = "opacity .3s ease-out,visibility .3s ease-out"
            },
            _render: function () {
                var e = document.getElementById("map-operate");
                if (e) {
                    e.appendChild(this._div)
                } else {
                    this._map.getContainer().appendChild(this._div)
                }
            },
            _bindDom: function () {
                this._div.addEventListener("mousemove", h)
            },
            _bind: function () {
                if (this._map._renderType === "webgl") {
                    return
                }
                var e = this;
                this._map.on("maptypechange", function () {
                    if (this.mapType === "B_EARTH_MAP") {
                        if (e._firstAnimation) {
                            e._firstAnimation = false;
                            setTimeout(function () {
                                e._div.style.opacity = "1";
                                e._div.style.visibility = "visible"
                            }, 300)
                        } else {
                            e._div.style.opacity = "1";
                            e._div.style.visibility = "visible"
                        }
                    } else {
                        e._div.style.opacity = "0";
                        e._div.style.visibility = "hidden"
                    }
                })
            }
        });

        function hC(T, i) {
            this._map = T;
            this._target = T;
            var hN = T.temp.originMapType || T.mapType;
            if (hN === "B_EARTH_MAP" && T._earth) {
                this._target = T._earth
            }
            this._outContainer = i || T.getContainer();
            this._imgRatio = a3() >= 1.5 ? 2 : 1;
            this._imgPath = e0.imgPath + "earth-navi-control-pc4" + (this._imgRatio === 2 ? "-2x.png" : ".png");
            this._enabled = true;
            var e = this;
            this._setHeadingOptions = {
                callback: function () {
                    e._target.setLock(false)
                }
            };
            this._init()
        }
        C.extend(hC.prototype, {
            _init: function () {
                this._createDom();
                this._render();
                this._bindDom();
                this._bind();
                this._updateUI();
                this._checkEnable()
            },
            _checkEnable: function () {
                if (this._target.getZoom() >= this._target._enableHeadingZoom) {
                    this.enable()
                } else {
                    this.disable()
                }
            },
            _createDom: function () {
                var i = this._div = S("div");
                var e = i.style;
                e.position = "absolute";
                e.zIndex = 5;
                e.top = "0";
                e.left = "0";
                e.width = "52px";
                e.height = "54px";
                e.background = "url(" + this._imgPath + ") no-repeat";
                e.backgroundSize = "266px auto";
                this._rotateCCW = this._createButton();
                this._rotateCCW.title = "逆时针转动";
                e = this._rotateCCW.style;
                e.left = "2px";
                e.top = "5px";
                e.zIndex = "1";
                e.width = "15px";
                e.height = "42px";
                e.backgroundPosition = "-75px -5px";
                this._rotateCW = this._createButton();
                this._rotateCW.title = "顺时针转动";
                e = this._rotateCW.style;
                e.right = "2px";
                e.top = "5px";
                e.zIndex = "1";
                e.width = "15px";
                e.height = "42px";
                e.backgroundPosition = "-75px -5px";
                e.WebkitTransform = e.transform = "scaleX(-1)";
                this._compass = this._createButton();
                this._compass.title = "恢复正北方向";
                e = this._compass.style;
                e.left = "19px";
                e.top = "4px";
                e.width = "14px";
                e.height = "44px";
                e.backgroundPosition = "-56px -4px";
                e.WebkitTransform = e.transform = "rotate(0deg)";
                this._div.appendChild(this._rotateCCW);
                this._div.appendChild(this._compass);
                this._div.appendChild(this._rotateCW);
                this._domRendered = true
            },
            _createButton: function () {
                var e = S("button");
                var i = e.style;
                i.position = "absolute";
                i.outline = "none";
                i.border = "none";
                i.background = "url(" + this._imgPath + ") no-repeat";
                i.backgroundSize = "266px auto";
                i.cursor = "pointer";
                return e
            },
            _render: function () {
                this._outContainer.appendChild(this._div)
            },
            enable: function () {
                this._enabled = true;
                if (this._domRendered) {
                    this._rotateCCW.style.cursor = "pointer";
                    this._rotateCCW.style.opacity = 1;
                    this._rotateCW.style.cursor = "pointer";
                    this._rotateCW.style.opacity = 1;
                    this._compass.style.cursor = "pointer";
                    this._compass.style.opacity = 1
                }
            },
            disable: function () {
                this._enabled = false;
                if (this._domRendered) {
                    this._rotateCCW.style.cursor = "";
                    this._rotateCCW.style.opacity = 0.4;
                    this._rotateCW.style.cursor = "";
                    this._rotateCW.style.opacity = 0.4;
                    this._compass.style.cursor = "";
                    this._compass.style.opacity = 0.4
                }
            },
            _bindDom: function () {
                eH(this._div, ["mousedown", "click", "dblclick"]);
                var i = this._map;
                var e = this;
                this._rotateCW.addEventListener("click", function () {
                    if (e._isOperating || e._enabled === false) {
                        return
                    }
                    if (e._target.getLock()) {
                        return
                    }
                    if (e._target.getHeading() === 360) {
                        e._target.setHeading(0)
                    }
                    e._target.setLock(true);
                    e._target.setHeading(e._target.getHeading() + 90, e._setHeadingOptions);
                    i.fire(new a8("onrotatecwclick"))
                }, false);
                this._rotateCCW.addEventListener("click", function () {
                    if (e._isOperating || e._enabled === false) {
                        return
                    }
                    if (e._target.getLock()) {
                        return
                    }
                    if (e._target.getHeading() === -360) {
                        e._target.setHeading(0)
                    }
                    e._target.setLock(true);
                    e._target.setHeading(e._target.getHeading() - 90, e._setHeadingOptions);
                    i.fire(new a8("onrotateccwclick"))
                }, false);
                this._rotateCW.addEventListener("mouseover", function () {
                    if (e._enabled === false) {
                        return
                    }
                    this.style.backgroundPosition = "-89px -5px"
                }, false);
                this._rotateCW.addEventListener("mouseout", function () {
                    if (e._enabled === false) {
                        return
                    }
                    this.style.backgroundPosition = "-75px -5px"
                }, false);
                this._rotateCCW.addEventListener("mouseover", function () {
                    if (e._enabled === false) {
                        return
                    }
                    this.style.backgroundPosition = "-89px -5px"
                }, false);
                this._rotateCCW.addEventListener("mouseout", function () {
                    if (e._enabled === false) {
                        return
                    }
                    this.style.backgroundPosition = "-75px -5px"
                }, false);
                this._compass.addEventListener("click", function () {
                    if (e._isOperating || e._enabled === false) {
                        return
                    }
                    if (e._target.getLock()) {
                        return
                    }
                    e._target.setLock(true);
                    var T = false;
                    if (e._target.getTilt() !== 0) {
                        T = true;
                        e._target.setTilt(0, e._setHeadingOptions)
                    }
                    if (e._target.getHeading() % 360 !== 0) {
                        T = true;
                        e._target.resetHeading(e._setHeadingOptions)
                    }
                    if (!T) {
                        e._target.setLock(false)
                    }
                    i.fire(new a8("oncompassclick"))
                }, false)
            },
            _bind: function () {
                var e = this;
                this._bindTarget(this._target);
                if (this._map._renderType === "webgl") {
                    this._map.addEventListener("maptypechange", function (i) {
                        if (this.mapType === "B_EARTH_MAP") {
                            e._target = e._map._earth
                        } else {
                            e._target = e._map
                        }
                        e._bindTarget(e._target);
                        e._checkEnable()
                    })
                }
            },
            _bindTarget: function (i) {
                if (i === this._map && this._mapBinded) {
                    return
                }
                if (i === this._map._earth && this._earthBinded) {
                    return
                }
                var e = this;
                i.addEventListener("heading_changed", function (T) {
                    e._updateUI()
                });
                i.addEventListener("animation_start", function (T) {
                    e._isOperating = true
                });
                i.addEventListener("animation_end", function (T) {
                    e._isOperating = false
                });
                i.on("load", function () {
                    e._checkEnable()
                });
                i.on("zoom_changed", function () {
                    e._checkEnable()
                });
                if (i === this._map) {
                    this._mapBinded = true
                } else {
                    this._earthBinded = true
                }
            },
            _updateUI: function () {
                var e = this._target.getHeading();
                var i = this._compass.style;
                i.WebkitTransform = i.transform = "rotate(" + e + "deg)"
            },
            hide: function () {
                this._div.style.display = "none"
            },
            show: function () {
                this._div.style.display = "block"
            }
        });

        function ep(T, i) {
            this._map = T;
            this._target = T;
            var hN = T.temp.originMapType || T.mapType;
            if (hN === "B_EARTH_MAP" && T._earth) {
                this._target = T._earth
            }
            this._outContainer = i || T.getContainer();
            this._imgRatio = a3() >= 1.5 ? 2 : 1;
            this._imgPath = e0.imgPath + "gl-navi-control-pc4" + (this._imgRatio === 2 ? "-2x.png" : ".png");
            this._enabled = true;
            var e = this;
            this._setTiltOptions = {
                callback: function () {
                    e._target.setLock(false)
                }
            };
            this._init()
        }
        C.extend(ep.prototype, {
            _init: function () {
                this._createDom();
                this._render();
                this._bindDom();
                this._bind();
                this._checkEnable()
            },
            _checkEnable: function () {
                if (this._target.getZoom() >= this._target._enableTiltZoom) {
                    this.enable()
                } else {
                    this.disable()
                }
            },
            _createDom: function () {
                var e = this._div = S("button");
                e.title = "倾斜";
                var i = e.style;
                i.position = "absolute";
                i.zIndex = 5;
                i.outline = "none";
                i.border = "none";
                i.cursor = "pointer";
                i.width = "26px";
                i.height = "26px";
                i.top = "56px";
                i.right = "13px";
                i.background = "url(" + this._imgPath + ") no-repeat #fff";
                i.backgroundSize = "266px auto";
                i.backgroundPosition = "-110px 1px";
                i.boxShadow = "1px 2px 1px rgba(0, 0, 0, 0.15)"
            },
            enable: function () {
                this._enabled = true;
                if (this._div) {
                    this._div.style.cursor = "pointer"
                }
                this._updateUI()
            },
            disable: function () {
                this._enabled = false;
                if (this._div) {
                    this._div.style.cursor = ""
                }
                this._updateUI()
            },
            _render: function () {
                this._outContainer.appendChild(this._div)
            },
            _bindDom: function () {
                var e = this;
                this._div.addEventListener("mousedown", function (hN) {
                    if (!e._enabled) {
                        return
                    }
                    if (e._target.getLock()) {
                        return
                    }
                    var i = e._target.getTilt();
                    var T;
                    if (i === e._map.getCurrentMaxTilt()) {
                        T = "out"
                    } else {
                        if (i === 0) {
                            T = "in"
                        } else {
                            T = e._preTrend ? e._preTrend : "in"
                        }
                    }
                    e._curTrend = T;
                    e._clickTimer = setTimeout(function () {
                        e._map.fire(new a8("ontiltmsdown"));
                        e._tiltAni = new o({
                            duration: 9999999,
                            render: function (hO) {
                                i = e._target.getTilt();
                                if (T === "in" && i < e._map.getCurrentMaxTilt()) {
                                    e._target.setTilt(i + 1, {
                                        noAnimation: true
                                    })
                                } else {
                                    if (T === "out" && i > 0) {
                                        e._target.setTilt(i - 1, {
                                            noAnimation: true
                                        })
                                    }
                                }
                            },
                            finish: function () {
                                e._tiltAni = null
                            }
                        });
                        e._clickTimer = null
                    }, 200);
                    hN.stopPropagation()
                }, false);
                this._div.addEventListener("mouseup", function (i) {
                    if (!e._enabled) {
                        return
                    }
                    if (e._tiltAni) {
                        e._tiltAni.stop()
                    }
                    e._preTrend = e._curTrend
                }, false);
                this._div.addEventListener("click", function (hN) {
                    if (!e._enabled) {
                        return
                    }
                    if (!e._clickTimer) {
                        return
                    }
                    if (e._target.getLock()) {
                        return
                    }
                    clearTimeout(e._clickTimer);
                    e._map.fire(new a8("ontiltclick"));
                    var i = e._target.getTilt();
                    e._target.setLock(true);
                    hN.stopPropagation();
                    var T = e._map.getCurrentMaxTilt();
                    if (e._curTrend === "in") {
                        e._target.setTilt(T, e._setTiltOptions)
                    } else {
                        if (e._curTrend === "out") {
                            e._target.setTilt(0, e._setTiltOptions)
                        } else {
                            if (i < T) {
                                e._target.setTilt(T, e._setTiltOptions)
                            } else {
                                e._target.setTilt(0, e._setTiltOptions)
                            }
                        }
                    }
                }, false);
                this._div.addEventListener("mouseover", function (i) {
                    if (!e._enabled) {
                        return
                    }
                    e._mouseOver = true;
                    e._updateUI()
                }, false);
                this._div.addEventListener("mouseout", function (i) {
                    if (!e._enabled) {
                        return
                    }
                    e._mouseOver = false;
                    e._updateUI()
                }, false);
                eH(this._div, ["mousedown", "click", "dblclick"])
            },
            _bind: function () {
                var e = this;
                var i = this._map;
                this._bindTarget(this._target);
                if (this._map._renderType === "webgl") {
                    this._map.addEventListener("maptypechange", function (T) {
                        if (this.mapType === "B_EARTH_MAP") {
                            e._target = e._map._earth
                        } else {
                            e._target = e._map
                        }
                        e._bindTarget(e._target);
                        e._checkEnable()
                    })
                }
            },
            _bindTarget: function (i) {
                if (i === this._map && this._mapBinded) {
                    return
                }
                if (i === this._map._earth && this._earthBinded) {
                    return
                }
                var e = this;
                i.on("load", function () {
                    e._checkEnable()
                });
                i.on("zoom_changed", function () {
                    e._checkEnable()
                });
                i.on("tilt_changed", function () {
                    e._updateUI()
                });
                if (i === this._map) {
                    this._mapBinded = true
                } else {
                    this._earthBinded = true
                }
            },
            _updateUI: function () {
                var T = this._target.getTilt();
                var i = 0;
                var hN = 0;
                var e = 0;
                if (T > 0) {
                    i = 78
                }
                if (this._mouseOver) {
                    e = 52
                }
                if (this._enabled === false) {
                    hN = 26;
                    e = 0;
                    i = 0
                }
                var hO = "-" + (110 + i + hN + e) + "px 1px";
                this._div && (this._div.style.backgroundPosition = hO);
                if (this._enabled) {
                    if (T > 0) {
                        this._div && (this._div.title = "恢复")
                    } else {
                        this._div && (this._div.title = "倾斜")
                    }
                } else {
                    this._div && (this._div.title = "请放大地图后操作")
                }
            },
            hide: function () {
                this._div.style.display = "none"
            },
            show: function () {
                this._div.style.display = "block"
            }
        });

        function cc(i) {
            ea.call(this);
            this._opts = {
                container: null,
                cursor: "default"
            };
            this._opts = C.extend(this._opts, i);
            this._type = "contextmenu";
            this._map = null;
            this._container;
            this._left = 0;
            this._top = 0;
            this._items = [];
            this._rItems = [];
            this._dividers = [];
            this._enable = true;
            this.curPixel = null;
            this.curPoint = null;
            this._isOpen = false;
            var e = this;
            d7.load("menu", function () {
                e._draw()
            })
        }
        cc.inherits(ea, "ContextMenu");
        C.extend(cc.prototype, {
            initialize: function (e) {
                this._map = e
            },
            remove: function () {
                this._map = null
            },
            addItem: function (hO, e) {
                if (!hO || hO._type != "menuitem" || hO._text == "" || hO._width <= 0) {
                    return
                }
                for (var hN = 0, T = this._items.length; hN < T; hN++) {
                    if (this._items[hN] === hO) {
                        return
                    }
                }
                if (e === undefined || e > this._items.length - 1) {
                    e = -1
                }
                hO._insertIndex = e;
                if (e === -1) {
                    this._items.push(hO);
                    this._rItems.push(hO)
                } else {
                    this._items.splice(e, 0, hO);
                    this._rItems.splice(e, 0, hO)
                }
            },
            removeItem: function (hN) {
                if (!hN || hN._type != "menuitem") {
                    return
                }
                for (var T = 0, e = this._items.length; T < e; T++) {
                    if (this._items[T] === hN) {
                        this._items[T].remove();
                        this._items.splice(T, 1);
                        delete hN._insertIndex;
                        e--
                    }
                }
                for (var T = 0, e = this._rItems.length; T < e; T++) {
                    if (this._rItems[T] === hN) {
                        this._rItems[T].remove();
                        this._rItems.splice(T, 1);
                        delete hN._insertIndex;
                        e--
                    }
                }
            },
            addSeparator: function (e) {
                if (e === undefined || e > this._items.length - 1) {
                    e = -1
                }
                var i = {
                    _type: "divider",
                    _dIndex: this._dividers.length,
                    _insertIndex: e
                };
                this._dividers.push({
                    dom: null
                });
                if (e === -1) {
                    this._items.push(i)
                } else {
                    this._items.splice(e, 0, i)
                }
            },
            removeSeparator: function (T) {
                if (!this._dividers[T]) {
                    return
                }
                for (var hN = 0, e = this._items.length; hN < e; hN++) {
                    if (this._items[hN] && this._items[hN]._type == "divider" && this._items[hN]._dIndex == T) {
                        this._items.splice(hN, 1);
                        e--
                    }
                    if (this._items[hN] && this._items[hN]._type == "divider" && this._items[hN]._dIndex > T) {
                        this._items[hN]._dIndex--
                    }
                }
                this._dividers.splice(T, 1)
            },
            getDom: function () {
                return this._container
            },
            show: function () {
                if (this._isOpen == true) {
                    return
                }
                this._isOpen = true
            },
            hide: function () {
                if (this._isOpen == false) {
                    return
                }
                this._isOpen = false
            },
            setCursor: function (e) {
                if (!e) {
                    return
                }
                this._opts.cursor = e
            },
            getItem: function (e) {
                return this._rItems[e]
            },
            enable: function () {
                this._enable = true
            },
            disable: function () {
                this._enable = false
            }
        });

        function fv(T, hN, i) {
            if (!T || !hN || typeof hN != "function") {
                return
            }
            ea.call(this);
            this._opts = {
                width: 100,
                id: ""
            };
            i = i || {};
            this._opts.width = (i.width * 1) ? i.width : 100;
            this._opts.id = i.id ? i.id : "";
            this._text = T + "";
            this._callback = hN;
            this._map = null;
            this._type = "menuitem";
            this._contextmenu = null;
            this._container = null;
            this._enabled = true;
            var e = this;
            d7.load("menu", function () {
                e._draw()
            })
        }
        fv.inherits(ea, "MenuItem");
        C.extend(fv.prototype, {
            initialize: function (e, i) {
                this._map = e;
                this._contextmenu = i
            },
            remove: function () {
                this._contextmenu = null;
                this._map = null
            },
            setText: function (e) {
                if (!e) {
                    return
                }
                this._text = e + ""
            },
            getDom: function () {
                return this._container
            },
            enable: function () {
                this._enabled = true
            },
            disable: function () {
                this._enabled = false
            }
        });

        function dP(e, i) {
            this.setSouthWest(e);
            this.setNorthEast(i)
        }
        C.extend(dP.prototype, {
            isEmpty: function () {
                return this.sw === null && this.ne === null
            },
            equals: function (e) {
                if (!e || e.isEmpty() || this.isEmpty()) {
                    return false
                }
                return this.sw.equals(e.sw) && this.ne.equals(e.ne)
            },
            containsBounds: function (e) {
                if (!e || e.isEmpty() || this.isEmpty()) {
                    return false
                }
                return (e.sw.lng > this.sw.lng && e.ne.lng < this.ne.lng && e.sw.lat > this.sw.lat && e.ne.lat < this.ne.lat)
            },
            getCenter: function () {
                if (this.isEmpty()) {
                    return null
                }
                return new ho((this.sw.lng + this.ne.lng) / 2, (this.sw.lat + this.ne.lat) / 2)
            },
            intersects: function (T) {
                if (!T || T.isEmpty() || this.isEmpty()) {
                    return null
                }
                if (Math.max(T.sw.lng, T.ne.lng) < Math.min(this.sw.lng, this.ne.lng) || Math.min(T.sw.lng, T.ne.lng) > Math.max(this.sw.lng, this.ne.lng) || Math.max(T.sw.lat, T.ne.lat) < Math.min(this.sw.lat, this.ne.lat) || Math.min(T.sw.lat, T.ne.lat) > Math.max(this.sw.lat, this.ne.lat)) {
                    return null
                }
                var hO = Math.max(this.sw.lng, T.sw.lng);
                var i = Math.min(this.ne.lng, T.ne.lng);
                var hN = Math.max(this.sw.lat, T.sw.lat);
                var e = Math.min(this.ne.lat, T.ne.lat);
                return new dP(new ho(hO, hN), new ho(i, e))
            },
            setMinMax: function () {
                this.minX = this.sw ? this.sw.lng : null;
                this.minY = this.sw ? this.sw.lat : null;
                this.maxX = this.ne ? this.ne.lng : null;
                this.maxY = this.ne ? this.ne.lat : null
            },
            containsPoint: function (e) {
                if (!e) {
                    return
                }
                return (e.lng >= this.sw.lng && e.lng <= this.ne.lng && e.lat >= this.sw.lat && e.lat <= this.ne.lat)
            },
            extend: function (e) {
                if (!e) {
                    return
                }
                var i = e.lng;
                var T = e.lat;
                if (!this.sw) {
                    this.sw = e.clone()
                }
                if (!this.ne) {
                    this.ne = e.clone()
                }
                if (this.sw.lng > i) {
                    this.sw.lng = i
                }
                if (this.ne.lng < i) {
                    this.ne.lng = i
                }
                if (this.sw.lat > T) {
                    this.sw.lat = T
                }
                if (this.ne.lat < T) {
                    this.ne.lat = T
                }
            },
            getMin: function () {
                return this.sw
            },
            getMax: function () {
                return this.ne
            },
            getSouthWest: function () {
                return this.sw
            },
            getNorthEast: function () {
                return this.ne
            },
            setSouthWest: function (e) {
                this.sw = e ? e.clone() : null
            },
            setNorthEast: function (e) {
                this.ne = e ? e.clone() : null
            },
            clone: function () {
                return new dP(this.sw, this.ne)
            },
            toSpan: function () {
                if (this.isEmpty()) {
                    return new d6(0, 0)
                }
                return new d6(Math.abs(this.ne.lng - this.sw.lng), Math.abs(this.ne.lat - this.sw.lat))
            },
            div: function (e) {
                if (!e || e.isEmpty() || this.isEmpty()) {
                    return 0
                }
                return ((this.ne.lng - this.sw.lng) * (this.ne.lat - this.sw.lat)) / ((e.ne.lng - e.sw.lng) * (e.ne.lat - e.sw.lat))
            },
            makeNormalizedPoint: function (e) {
                this.normalizedTopLeft = this.pointTopLeft.clone();
                this.normalizedTopRight = this.pointTopRight.clone();
                this.normalizedBottomRight = this.pointBottomRight.clone();
                this.normalizedBottomLeft = this.pointBottomLeft.clone();
                while (e < 0) {
                    e += 360
                }
                e = e % 360;
                if (e >= 0 && e < 90 || e >= 270 && e < 360) {
                    if (this.normalizedTopRight.lng < this.normalizedTopLeft.lng) {
                        this.normalizedTopRight.lng += c5.WORLD_SIZE_MC
                    }
                    if (this.normalizedBottomRight.lng < this.normalizedBottomLeft.lng) {
                        this.normalizedBottomRight.lng += c5.WORLD_SIZE_MC
                    }
                } else {
                    if (this.normalizedTopLeft.lng < this.normalizedTopRight.lng) {
                        this.normalizedTopLeft.lng += c5.WORLD_SIZE_MC
                    }
                    if (this.normalizedBottomLeft.lng < this.normalizedBottomRight.lng) {
                        this.normalizedBottomLeft.lng += c5.WORLD_SIZE_MC
                    }
                }
            },
            toString: function () {
                return "Bounds"
            }
        });

        function ho(e, i) {
            if (isNaN(e)) {
                e = gX(e);
                e = isNaN(e) ? 0 : e
            }
            if (typeof e === "string") {
                e = parseFloat(e)
            }
            if (isNaN(i)) {
                i = gX(i);
                i = isNaN(i) ? 0 : i
            }
            if (typeof i === "string") {
                i = parseFloat(i)
            }
            this.lng = e;
            this.lat = i
        }
        ho.prototype.equals = function (i) {
            if (!i) {
                return false
            }
            var hN = Math.abs(this.lat - i.lat);
            var T = Math.abs(this.lng - i.lng);
            var e = 1e-8;
            if (hN < e && T < e) {
                return true
            }
            return false
        };
        ho.prototype.clone = function () {
            return new ho(this.lng, this.lat)
        };
        ho.prototype.add = function (e) {
            return new ho(this.lng + e.lng, this.lat + e.lat)
        };
        ho.prototype.sub = function (e) {
            return new ho(this.lng - e.lng, this.lat - e.lat)
        };
        ho.prototype.mult = function (e) {
            return new ho(this.lng * e, this.lat * e)
        };
        ho.prototype.div = function (e) {
            return new ho(this.lng / e, this.lat / e)
        };
        ho.prototype.mag = function () {
            return Math.sqrt(this.lng * this.lng + this.lat * this.lat)
        };
        ho.prototype.toString = function () {
            return "Point"
        };

        function ek() { }
        C.extend(ek, {
            EARTHRADIUS: 6370996.81,
            MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
            LLBAND: [86, 60, 45, 30, 15, 0],
            MC2LL: [
                [1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2],
                [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86],
                [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37],
                [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06],
                [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4],
                [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]
            ],
            LL2MC: [
                [-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5],
                [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5],
                [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5],
                [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5],
                [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5],
                [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]
            ],
            getDistanceByMC: function (hP, hN) {
                if (!hP || !hN) {
                    return 0
                }
                var i;
                var hO;
                var e;
                var T;
                hP = this.convertMC2LL(hP);
                if (!hP) {
                    return 0
                }
                i = dH(hP.lng);
                hO = dH(hP.lat);
                hN = this.convertMC2LL(hN);
                if (!hN) {
                    return 0
                }
                e = dH(hN.lng);
                T = dH(hN.lat);
                return this.getDistance(i, e, hO, T)
            },
            getDistanceByLL: function (hP, hN) {
                if (!hP || !hN) {
                    return 0
                }
                hP.lng = this.getLoop(hP.lng, -180, 180);
                hP.lat = this.getRange(hP.lat, -80, 84);
                hN.lng = this.getLoop(hN.lng, -180, 180);
                hN.lat = this.getRange(hN.lat, -80, 84);
                var i;
                var e;
                var hO;
                var T;
                i = dH(hP.lng);
                hO = dH(hP.lat);
                e = dH(hN.lng);
                T = dH(hN.lat);
                return this.getDistance(i, e, hO, T)
            },
            proximityCovertMC2LL: function (e) {
                if (e === null) {
                    return e
                }
                if (e.lng < 180 && e.lng > -180 && e.lat < 90 && e.lat > -90) {
                    return e
                }
                return this.convertMC2LL(e)
            },
            convertMC2LL: function (e) {
                if (e === null) {
                    return e
                }
                if (!e) {
                    return new ho(0, 0)
                }
                var T;
                var hO;
                T = new ho(Math.abs(e.lng), Math.abs(e.lat));
                for (var hN = 0; hN < this.MCBAND.length; hN++) {
                    if (T.lat >= this.MCBAND[hN]) {
                        hO = this.MC2LL[hN];
                        break
                    }
                }
                var hP = this.convertor(e, hO);
                return new c0(hP.lat, hP.lng)
            },
            convertLL2MC: function (hQ) {
                if (!hQ) {
                    return new ho(0, 0)
                }
                var hS = hQ.lat;
                var hN = hQ.lng;
                hN = this.getLoop(hQ.lng, -180, 180);
                hS = fC(hS, -85, 85);
                var hP;
                for (var hO = 0; hO < this.LLBAND.length; hO++) {
                    if (hS >= this.LLBAND[hO]) {
                        hP = this.LL2MC[hO];
                        break
                    }
                }
                if (!hP) {
                    for (hO = 0; hO < this.LLBAND.length; hO++) {
                        if (hS <= -this.LLBAND[hO]) {
                            hP = this.LL2MC[hO];
                            break
                        }
                    }
                }
                var T = new ho(hN, hS);
                var hR = this.convertor(T, hP);
                var e = new ho(hR.lng, hR.lat);
                e.latLng = new c0(hQ.lat, hQ.lng);
                return e
            },
            convertor: function (T, hN) {
                if (!T || !hN) {
                    return
                }
                var e = hN[0] + hN[1] * Math.abs(T.lng);
                var i = Math.abs(T.lat) / hN[9];
                var hO = hN[2] + hN[3] * i + hN[4] * i * i + hN[5] * i * i * i + hN[6] * i * i * i * i + hN[7] * i * i * i * i * i + hN[8] * i * i * i * i * i * i;
                e *= (T.lng < 0 ? -1 : 1);
                hO *= (T.lat < 0 ? -1 : 1);
                return new ho(e, hO)
            },
            getDistance: function (i, e, hN, T) {
                return this.EARTHRADIUS * Math.acos((Math.sin(hN) * Math.sin(T) + Math.cos(hN) * Math.cos(T) * Math.cos(e - i)))
            },
            getRange: function (T, i, e) {
                if (i != null) {
                    T = Math.max(T, i)
                }
                if (e != null) {
                    T = Math.min(T, e)
                }
                return T
            },
            getLoop: function (T, i, e) {
                while (T > e) {
                    T -= e - i
                }
                while (T < i) {
                    T += e - i
                }
                return T
            }
        });
        C.extend(ek.prototype, {
            lnglatToMercator: function (e) {
                return ek.convertLL2MC(e)
            },
            lngLatToPoint: function (e) {
                var i = ek.convertLL2MC(e);
                return new eg(i.lng, i.lat)
            },
            mercatorToLnglat: function (e) {
                return ek.convertMC2LL(e)
            },
            pointToLngLat: function (i) {
                var e = new ho(i.x, i.y);
                var T = ek.convertMC2LL(e);
                return new c0(T.lat, T.lng)
            },
            pointToPixel: function (i, hP, hO, hN) {
                if (!i) {
                    return
                }
                i = this.lnglatToMercator(i);
                var T = this.getZoomUnits(hP);
                var e = Math.round((i.lng - hO.lng) / T + hN.width / 2);
                var hQ = Math.round((hO.lat - i.lat) / T + hN.height / 2);
                return new eg(e, hQ)
            },
            mercatorToPixel: function (hP, hO, hN, T) {
                if (!hP) {
                    return
                }
                var i = this.getZoomUnits(hO);
                var e = Math.round((hP.lng - hN.lng) / i + T.width / 2);
                var hQ = Math.round((hN.lat - hP.lat) / i + T.height / 2);
                return new eg(e, hQ)
            },
            pixelToPoint: function (hN, hQ, hP, hO) {
                if (!hN) {
                    return
                }
                var i = this.getZoomUnits(hQ);
                var T = hP.lng + i * (hN.x - hO.width / 2);
                var hR = hP.lat - i * (hN.y - hO.height / 2);
                var e = new ho(T, hR);
                return this.mercatorToLnglat(e)
            },
            getZoomUnits: function (e) {
                return Math.pow(2, (18 - e))
            },
            setCoordType: function (e) {
                this.coordsType = e
            }
        });

        function c0(i, e) {
            if (i < -90) {
                i = -90
            } else {
                if (i > 90) {
                    i = 90
                }
            }
            while (e < -180) {
                e += 360
            }
            while (e > 180) {
                e -= 360
            }
            e = e || 0;
            i = i || 0;
            ho.call(this, e, i)
        }
        c0.inherits(ho, "LatLng");
        C.extend(c0.prototype, {
            equals: function (e) {
                return (this.lat === e.lat && this.lng === e.lng)
            },
            clone: function () {
                return new c0(this.lat, this.lng)
            },
            add: function (e) {
                return new c0(this.lng + e.lng, this.lat + e.lat)
            },
            sub: function (e) {
                return new c0(this.lat - e.lat, this.lng - e.lng)
            },
            mult: function (e) {
                return new c0(this.lng * e, this.lat * e)
            },
            div: function (e) {
                return new c0(this.lng / e, this.lat / e)
            },
            mag: function () {
                return Math.sqrt(this.lng * this.lng + this.lat * this.lat)
            },
            getLngSpan: function (e) {
                var i = this.lng;
                var T = Math.abs(e - i);
                if (T > 180) {
                    T = 360 - T
                }
                return T
            },
            toString: function () {
                return "LatLng"
            }
        });

        function eD(e, i) {
            if (e && !i) {
                i = e
            }
            this._sw = this._ne = null;
            this._swLng = this._swLat = null;
            this._neLng = this._neLat = null;
            if (e) {
                this._sw = new c0(e.lat, e.lng);
                this._ne = new c0(i.lat, i.lng);
                this._swLng = e.lng;
                this._swLat = e.lat;
                this._neLng = i.lng;
                this._neLat = i.lat
            }
        }
        C.extend(eD.prototype, {
            isEmpty: function () {
                return !this._sw || !this._ne
            },
            equals: function (e) {
                if (this.isEmpty()) {
                    return false
                }
                return this.getSouthWest().equals(e.getSouthWest()) && this.getNorthEast().equals(e.getNorthEast())
            },
            getSouthWest: function () {
                return this._sw
            },
            getNorthEast: function () {
                return this._ne
            },
            containsBounds: function (e) {
                if (this.isEmpty() || e.isEmpty()) {
                    return false
                }
                return (e._swLng > this._swLng && e._neLng < this._neLng && e._swLat > this._swLat && e._neLat < this._neLat)
            },
            getCenter: function () {
                if (this.isEmpty()) {
                    return null
                }
                return new c0((this._swLat + this._neLat) / 2, (this._swLng + this._neLng) / 2)
            },
            intersects: function (T) {
                if (Math.max(T._swLng, T._neLng) < Math.min(this._swLng, this._neLng) || Math.min(T._swLng, T._neLng) > Math.max(this._swLng, this._neLng) || Math.max(T._swLat, T._neLat) < Math.min(this._swLat, this._neLat) || Math.min(T._swLat, T._neLat) > Math.max(this._swLat, this._neLat)) {
                    return false
                }
                var hO = Math.max(this._swLng, T._swLng);
                var i = Math.min(this._neLng, T._neLng);
                var hN = Math.max(this._swLat, T._swLat);
                var e = Math.min(this._neLat, T._neLat);
                this._sw = new c0(hN, hO);
                this._ne = new c0(e, i);
                this._swLng = hO;
                this._swLat = hN;
                this._neLng = i;
                this._neLat = e;
                return true
            },
            containsPoint: function (e) {
                if (this.isEmpty()) {
                    return false
                }
                return (e.lng >= this._swLng && e.lng <= this._neLng && e.lat >= this._swLat && e.lat <= this._neLat)
            },
            extend: function (e) {
                var i = e.lng;
                var T = e.lat;
                if (!this._sw) {
                    this._sw = new c0(0, 0)
                }
                if (!this._ne) {
                    this._ne = new c0(0, 0)
                }
                if (!this._swLng || this._swLng > i) {
                    this._sw.lng = this._swLng = i
                }
                if (!this._neLng || this._neLng < i) {
                    this._ne.lng = this._neLng = i
                }
                if (!this._swLat || this._swLat > T) {
                    this._sw.lat = this._swLat = T
                }
                if (!this._neLat || this._neLat < T) {
                    this._ne.lat = this._neLat = T
                }
            },
            toSpan: function () {
                if (this.isEmpty()) {
                    return new c0(0, 0)
                }
                return new c0(Math.abs(this._neLat - this._swLat), Math.abs(this._neLng - this._swLng))
            },
            union: function (i) {
                if (i.isEmpty()) {
                    return false
                }
                var e = i.getSouthWest();
                var T = i.getNorthEast();
                if (this._swLat > e.lat) {
                    this._swLat = e.lat
                }
                if (this._swLng > e.lng) {
                    this._swLng = e.lng
                }
                if (this._neLat < T.lat) {
                    this._neLat = T.lat
                }
                if (this._neLng < T.lng) {
                    this._neLng = T.lng
                }
                this._sw = new c0(this._swLat, this._swLng);
                this._ne = new c0(this._neLat, this._neLng);
                return true
            },
            toString: function () {
                return this._swLat + ", " + this._swLng + ", " + this._neLat + ", " + this._neLng
            }
        });
        window.COORDINATES_WGS84 = 1;
        window.COORDINATES_WGS84_MC = 2;
        window.COORDINATES_GCJ02 = 3;
        window.COORDINATES_GCJ02_MC = 4;
        window.COORDINATES_BD09 = 5;
        window.COORDINATES_BD09_MC = 6;
        window.COORDINATES_MAPBAR = 7;
        window.COORDINATES_51 = 8;

        function ax() { }
        ax.inherits(ea, "Convertor");
        C.extend(ax.prototype, {
            translate: function (i, hO, hN, T) {
                hO = hO || 1;
                hN = hN || 5;
                if (i.length > 10) {
                    T && T({
                        status: 25
                    });
                    return
                }
                var e = e0.apiHost + "/geoconv/v1/?coords=";
                C.each(i, function (hP) {
                    e += hP.lng + "," + hP.lat + ";"
                });
                e = e.replace(/;$/gi, "");
                e = e + "&from=" + hO + "&to=" + hN + "&ak=" + ga;
                D.request(e, function (hQ) {
                    if (hQ.status === 0) {
                        var hP = [];
                        C.each(hQ.result, function (hR) {
                            hP.push(new ho(hR.x, hR.y))
                        });
                        delete hQ.result;
                        hQ.points = hP
                    }
                    T && T(hQ)
                })
            }
        });
        var dR = {
            idle: 0,
            freeze: 1,
            zooming: 2,
            dragging: 3,
            moving: 4,
            readyToDrag: 5,
            readyToPinch: 6,
            pinching: 7,
            stdMapCtrlDrag: 8,
            KEY_LEFT: 37,
            KEY_UP: 38,
            KEY_RIGHT: 39,
            KEY_DOWN: 40,
            arrowOpCodes: {
                37: 1,
                38: 2,
                39: 4,
                40: 8
            }
        };
        var ee = {
            _map: null,
            _html: "<div class='BMap_opMask' unselectable='on'></div>",
            _maskElement: null,
            _cursor: "default",
            inUse: false,
            show: function (e) {
                if (!this._map) {
                    this._map = e
                }
                this.inUse = true;
                if (!this._maskElement) {
                    this._createMask(e)
                }
                this._maskElement.style.display = "block"
            },
            _createMask: function (i) {
                if (!this._map) {
                    this._map = i
                }
                if (!this._map) {
                    return
                }
                var e = this._maskElement = dF(this._map.container, this._html);
                C.on(e, "mouseup", function (T) {
                    if (T.button == 2) {
                        c8(T)
                    }
                });
                C.on(e, "contextmenu", c8);
                e.style.display = "none"
            },
            getDrawPoint: function (hN, hQ, hO) {
                hN = window.event || hN;
                var i = hN.offsetX || hN.layerX || 0;
                var hP = parseInt(hN.offsetY) || parseInt(hN.layerY) || 0;
                var T = hN.target || hN.srcElement;
                if (T != ee.getDom(this._map) && hQ == true) {
                    while (T && T != this._map.container) {
                        if (!(T.clientWidth == 0 && T.clientHeight == 0 && T.offsetParent && T.offsetParent.nodeName.toLowerCase() == "td")) {
                            i += T.offsetLeft;
                            hP += T.offsetTop
                        }
                        T = T.offsetParent
                    }
                }
                if (T != ee.getDom(this._map) && T != this._map.container) {
                    return
                }
                if (typeof i === "undefined" || typeof hP === "undefined") {
                    return
                }
                if (isNaN(i) || isNaN(hP)) {
                    return
                }
                if (hO) {
                    i = i + hO.x;
                    hP = hP + hO.y
                }
                return this._map.pixelToPointIn(new eg(i, hP))
            },
            hide: function () {
                if (!this._map) {
                    return
                }
                this.inUse = false;
                if (this._maskElement) {
                    this._maskElement.style.display = "none"
                }
            },
            getDom: function (e) {
                if (!this._maskElement) {
                    this._createMask(e)
                }
                return this._maskElement
            },
            setCursor: function (e) {
                this._cursor = e || "default";
                if (this._maskElement) {
                    this._maskElement.style.cursor = this._cursor
                }
            }
        };

        function bi() {
            this._type = "overlay"
        }
        bi.inherits(C.BaseClass, "Overlay");
        bi.getZIndex = function (i, e) {
            i = i * 1;
            if (!i) {
                return 0
            }
            if (e) {
                i = ek.convertMC2LL(new ho(0, i)).lat
            }
            return (i * -100000) << 1
        };
        C.extend(bi.prototype, {
            _i: function (e) {
                this._map = e;
                if (!this.domElement && bS(this.initialize)) {
                    this.domElement = this.initialize(e);
                    if (this.domElement) {
                        this.domElement.style.WebkitUserSelect = "none"
                    }
                }
                this.draw()
            },
            initialize: function (e) {
                throw "initialize方法未实现"
            },
            draw: function () {
                throw "draw方法未实现"
            },
            remove: function () {
                if (this.domElement && this.domElement.parentNode) {
                    this.domElement.parentNode.removeChild(this.domElement)
                }
                this.domElement = null;
                this.dispatchEvent(new a8("onremove"))
            },
            hide: function () {
                this._visible = false;
                C.hide(this.domElement)
            },
            show: function () {
                this._visible = true;
                C.show(this.domElement)
            },
            getMap: function () {
                return this._map
            },
            dispose: function () {
                C.BaseClass.prototype.decontrol.call(this)
            }
        });

        function cS() {
            C.BaseClass.call(this);
            bi.call(this);
            this._visible = true;
            this._visibleInternal = true;
            this.infoWindow = null;
            this._dblclickTime = 0
        }
        cS.inherits(bi, "OverlayInternal");
        C.extend(cS.prototype, {
            initialize: function (e) {
                this.map = e;
                C.BaseClass.call(this, this.hashCode);
                return null
            },
            draw: function () { },
            remove: function () {
                this.decontrol();
                bi.prototype.remove.call(this)
            },
            hide: function () {
                this._visible = false
            },
            show: function () {
                this._visible = true
            },
            getDom: function () {
                return this.domElement
            },
            getContainer: function () {
                return this.domElement
            },
            setClassName: function () { },
            setConfig: function (i) {
                if (!i) {
                    return
                }
                for (var e in i) {
                    if (i.hasOwnProperty(e)) {
                        this._config[e] = i[e]
                    }
                }
            },
            getPoint: function (T, hN) {
                if (!T) {
                    return this.point
                } else {
                    var e = hN ? hN.width : 0;
                    var hO = hN ? hN.height : 0;
                    if (this.map) {
                        var i = this.map.pointToPixelIn(this.point);
                        if (this._config && this._config.offset) {
                            i.x = i.x + this._config.offset.width + e;
                            i.y = i.y + this._config.offset.height + hO
                        } else {
                            i.x = i.x + e;
                            i.y = i.y + hO
                        }
                        return this.map.pixelToPointIn(i)
                    }
                }
            },
            setZIndex: function (e) {
                this.zIndex = e
            },
            isVisible: function () {
                if (!this.domElement) {
                    return false
                }
                return !!this._visible
            },
            enableMassClear: function () {
                this._config.enableMassClear = true
            },
            disableMassClear: function () {
                this._config.enableMassClear = false
            },
            showInternal: function () {
                this._visibleInternal = true
            },
            hideInternal: function (e) {
                this._visibleInternal = false;
                this._hideInternalReason = e
            }
        });

        function eU(e) {
            this.map = e;
            this._overlays = {};
            this._overlayArray = [];
            this._customOverlays = [];
            e._overlays = this._overlays;
            e._overlayArray = this._overlayArray;
            e._customOverlays = this._customOverlays;
            this._zoomingOrMoving = false;
            this._init()
        }
        eU.prototype._init = function () {
            if (this.map._renderType !== "webgl") {
                this._createOverlayContainers()
            } else {
                this._createWebGLOverlayContainers()
            }
            this._bind()
        };
        eU.prototype._createOverlayContainers = function () {
            var e = this.map;
            e.temp.overlayDiv = e.overlayDiv = this._createOverlayDiv(e.platform, 200);
            e.temp.overlayDivEx = e.overlayDivEx = this._createOverlayDiv(e.platform, 50);
            e._panes.floatPane = this._createOverlayDiv(e.temp.overlayDiv, 800);
            e._panes.markerMouseTarget = this._createOverlayDiv(e.temp.overlayDiv, 700);
            e._panes.floatShadow = this._createOverlayDiv(e.temp.overlayDiv, 600);
            e._panes.labelPane = this._createOverlayDiv(e.temp.overlayDiv, 500);
            e._panes.markerPane = this._createOverlayDiv(e.temp.overlayDiv, 400);
            if (e.isCanvasMap()) {
                e._panes.mapPane = this._createOverlayDiv(e.temp.overlayDivEx, 50)
            } else {
                e._panes.mapPane = this._createOverlayDiv(e.temp.overlayDiv, 200)
            }
        };
        eU.prototype._createWebGLOverlayContainers = function () {
            var e = this.map;
            e.temp.overlayDiv = e.overlayDiv = this._createOverlayDiv(e.platform, 200);
            e._panes.floatPane = this._createOverlayDiv(e.temp.overlayDiv, 800);
            e._panes.markerMouseTarget = this._createOverlayDiv(e.temp.overlayDiv, 700);
            e._panes.floatShadow = this._createOverlayDiv(e.temp.overlayDiv, 600);
            e._panes.labelPane = this._createOverlayDiv(e.temp.overlayDiv, 500);
            e._panes.markerPane = this._createOverlayDiv(e.temp.overlayDiv, 400)
        };
        eU.prototype._createOverlayDiv = function (e, hN) {
            var T = S("div");
            var i = T.style;
            i.position = "absolute";
            i.top = i.left = i.width = i.height = "0";
            i.zIndex = hN;
            e.appendChild(T);
            return T
        };
        eU.prototype._bind = function () {
            var hO = this.map;
            var hN = this;

            function i(hQ) {
                hN.draw(hQ)
            }
            if (hO._renderType !== "webgl") {
                hO.addEventListener("load", i);
                hO.addEventListener("moveend", i);
                hO.addEventListener("resize", i);
                hO.addEventListener("zoomend", i);
                hO.addEventListener("zooming_inner", i)
            } else {
                hO.on("update", i)
            }
            hO.addEventListener("zoomend", function (hQ) {
                if (this.mapType === "B_EARTH_MAP") {
                    if (this._earth.getZoom() < this._earth.zoomForNight + 1) {
                        this.temp.overlayDiv.style.display = "none";
                        if (this.temp.overlayDivEx) {
                            this.temp.overlayDivEx.style.display = "none"
                        }
                    } else {
                        if (this.temp.overlayDiv.style.display === "none") {
                            this.temp.overlayDiv.style.display = "";
                            if (this.temp.overlayDivEx) {
                                this.temp.overlayDivEx.style.display = ""
                            }
                            if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
                                this.temp.infoWin.redraw()
                            }
                        }
                    }
                }
            });
            hO.addEventListener("oncenterandzoom", function (hQ) {
                hN.draw(hQ);
                if (this.mapType === "B_EARTH_MAP") {
                    if (this._earth.getZoom() < this._earth.zoomForNight + 1) {
                        this.temp.overlayDiv.style.display = "none";
                        if (this.temp.overlayDivEx) {
                            this.temp.overlayDivEx.style.display = "none"
                        }
                    } else {
                        if (this.temp.overlayDiv.style.display === "none") {
                            this.temp.overlayDiv.style.display = "";
                            if (this.temp.overlayDivEx) {
                                this.temp.overlayDivEx.style.display = ""
                            }
                            if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
                                this.temp.infoWin.redraw()
                            }
                        }
                    }
                }
            });
            hO.addEventListener("maptypechange", function (hQ) {
                if (this.mapType === "B_EARTH_MAP") {
                    if (this._panes.mapPane) {
                        this._panes.mapPane.style.display = "none"
                    }
                    if (this._earth.getZoom() < this._earth.zoomForNight + 1) {
                        this.temp.overlayDiv.style.display = "none";
                        if (this.temp.overlayDivEx) {
                            this.temp.overlayDivEx.style.display = "none"
                        }
                    } else {
                        if (this.temp.overlayDiv.style.display === "none") {
                            this.temp.overlayDiv.style.display = "";
                            if (this.temp.overlayDivEx) {
                                this.temp.overlayDivEx.style.display = ""
                            }
                            if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
                                this.temp.infoWin.redraw()
                            }
                        }
                    } if (this._panes.markerPane) {
                        this._panes.markerPane.style.display = "none"
                    }
                } else {
                    if (this._panes.mapPane) {
                        this._panes.mapPane.style.display = ""
                    }
                    if (this._panes.markerPane) {
                        this._panes.markerPane.style.display = ""
                    }
                    if (this.temp.overlayDiv.style.display === "none") {
                        this.temp.overlayDiv.style.display = "";
                        if (this.temp.overlayDivEx) {
                            this.temp.overlayDivEx.style.display = ""
                        }
                        if (this.temp.infoWin && this.temp.infoWin.isOpen()) {
                            this.temp.infoWin.redraw()
                        }
                    }
                }
                hN.draw(hQ)
            });
            hO.on("earthstatuschange", function hP(hQ) {
                hN.draw(hQ)
            });
            hO.addEventListener("addoverlay", function (hU) {
                var hR = hU.target;
                if (hR instanceof cS) {
                    if (!hN._overlays[hR.hashCode]) {
                        hN._overlays[hR.hashCode] = hR;
                        hN._overlayArray.push(hR)
                    }
                } else {
                    var hT = false;
                    for (var hS = 0, hQ = hN._customOverlays.length; hS < hQ; hS++) {
                        if (hN._customOverlays[hS] === hR) {
                            hT = true;
                            break
                        }
                    }
                    if (!hT) {
                        hN._customOverlays.push(hR)
                    }
                }
            });
            hO.addEventListener("removeoverlay", function (hT) {
                var hR = hT.target;
                if (hR instanceof cS) {
                    delete hN._overlays[hR.hashCode];
                    for (var hS = 0; hS < hN._overlayArray.length; hS++) {
                        if (hN._overlayArray[hS] === hR) {
                            hN._overlayArray.splice(hS, 1);
                            break
                        }
                    }
                } else {
                    for (var hS = 0, hQ = hN._customOverlays.length; hS < hQ; hS++) {
                        if (hN._customOverlays[hS] === hR) {
                            hN._customOverlays.splice(hS, 1);
                            break
                        }
                    }
                }
            });
            hO.addEventListener("clearoverlays", function (hS) {
                this.closeInfoWindow();
                this.closeSimpleInfoWindow();
                for (var hR in hN._overlays) {
                    if (hN._overlays[hR]._config.enableMassClear) {
                        this.removeOverlay(hN._overlays[hR])
                    }
                }
                for (var hQ = hN._customOverlays.length - 1; hQ > 0; hQ--) {
                    if (hN._customOverlays[hQ].enableMassClear !== false) {
                        this.removeOverlay(hN._customOverlays[hQ]);
                        hN._customOverlays.splice(hQ, 1)
                    }
                }
            });
            hO.addEventListener("infowindowopen", function (hR) {
                var hQ = this.infoWindow;
                if (hQ) {
                    C.hide(hQ.popDom);
                    C.hide(hQ.shadowDom)
                }
            });

            function T() {
                if (this.getMapType() === "B_EARTH_MAP" || this._renderType === "webgl") {
                    if (hN._zoomingOrMoving === false) {
                        this._panes.markerMouseTarget.style.display = "none";
                        hN._zoomingOrMoving = true
                    }
                }
            }

            function e(hS) {
                if (this.getMapType() === "B_EARTH_MAP" || this._renderType === "webgl") {
                    if (hN._zoomingOrMoving === true) {
                        this._panes.markerMouseTarget.style.display = "";
                        hN._zoomingOrMoving = false;
                        for (var hR = 0; hR < hN._overlayArray.length; hR++) {
                            var hQ = hN._overlayArray[hR];
                            if (hQ instanceof dn === true) {
                                hQ.draw(hS)
                            }
                        }
                    }
                }
            }
            hO.addEventListener("movestart", T);
            hO.addEventListener("moveend", e);
            hO.addEventListener("zoomstart", T);
            hO.addEventListener("zoomend", e);
            hO.addEventListener("animation_start", T);
            hO.addEventListener("animation_end", e);
            hO.addEventListener("displayoptions_changed", function (hQ) {
                if (this._displayOptions.overlay === false) {
                    this.temp.overlayDiv.style.display = "none"
                } else {
                    this.temp.overlayDiv.style.display = ""
                }
            })
        };
        eU.prototype.draw = function (hQ) {
            hQ = hQ || {};
            if (this.map.getMapType() === "B_EARTH_MAP") {
                for (var hO = 0; hO < this._overlayArray.length; hO++) {
                    var T = this._overlayArray[hO];
                    if (T instanceof w === true) {
                        continue
                    }
                    if (this._zoomingOrMoving) {
                        if (T instanceof dn === true) {
                            continue
                        }
                    }
                    T.draw(hQ)
                }
            } else {
                for (var hO = 0, hN = this._overlayArray.length; hO < hN; hO++) {
                    var T = this._overlayArray[hO];
                    if (this._zoomingOrMoving && T instanceof dn === true) {
                        continue
                    }
                    T.draw(hQ)
                }
            }
            C.each(this._customOverlays, function (e) {
                e.draw(hQ)
            });
            if (this.map.temp.infoWin) {
                this.map.temp.infoWin.setPosition(hQ.center, hQ.zoom)
            }
            if (this.map.getMapType() !== "B_EARTH_MAP" && this.map._renderType !== "webgl") {
                if (bl.DrawerSelector) {
                    var hP = bl.DrawerSelector.getDrawer(this.map);
                    hP.setPalette()
                }
            }
        };
        bl.register(function (e) {
            e._overlayMgr = new eU(e)
        });

        function w(e) {
            cS.call(this);
            this._config = {
                strokeColor: "#000",
                strokeWeight: 2,
                strokeOpacity: 1,
                strokeStyle: "solid",
                dashArray: null,
                strokeLineCap: "round",
                strokeLineJoin: "round",
                enableMassClear: true,
                getParseTolerance: null,
                getParseCacheIndex: null,
                enableParse: true,
                enableEditing: false,
                mouseOverTolerance: 5,
                geodesic: false,
                clip: true,
                texture: null,
                textureSize: null,
                textureZoomWithMap: false,
                textureRepeat: true
            };
            this.setConfig(e);
            if (this._config.strokeOpacity < 0 || this._config.strokeOpacity > 1) {
                this._config.strokeOpacity = 1
            }
            if (this._config.fillOpacity < 0 || this._config.fillOpacity > 1) {
                this._config.fillOpacity = 1
            }
            if (this._config.strokeStyle !== "solid" && this._config.strokeStyle !== "dashed" && this._config.strokeStyle !== "dotted") {
                this._config.strokeStyle = "solid"
            }
            this.domElement = null;
            this._bounds = new dP();
            this.points = [];
            this.greatCirclePoints = [];
            this._parseCache = [];
            this._holesCache = [];
            this._parseCacheGL = [];
            this._parseCacheGLRaw = [];
            this._areaCacheGL = [];
            this._strokeStyleInfoForGL = [
                []
            ];
            this._fillStyleInfoForGL = "";
            this.vertexMarkers = [];
            this._temp = {}
        }
        w.JOININDEX = {
            miter: 0,
            round: 1,
            bevel: 2
        };
        w.CAPINDEX = {
            round: 0,
            butt: 1,
            square: 2
        };
        w.inherits(cS, "Graph");
        w.getGraphPoints = function (i) {
            var e = [];
            if (!i || i.length === 0) {
                return e
            }
            if (typeof i === "string") {
                var T = i.split(";");
                C.each(T, function (hO) {
                    var hN = hO.split(",");
                    e.push(new ho(hN[0], hN[1]))
                })
            }
            if (i.constructor === Array && i.length > 0) {
                e = i
            }
            return e
        };
        w.parseTolerance = {
            0: [0.09, 0.005, 0.0001, 0.00001],
            1: [9000, 500, 20, 1]
        };
        C.extend(w.prototype, {
            initialize: function (e) {
                this.map = e;
                return null
            },
            draw: function () { },
            setPoints: function (e) {
                this._clearCache();
                this.points = w.getGraphPoints(e).slice(0);
                this._calcBounds()
            },
            setPathIn: function (e) {
                this.setPoints(e)
            },
            _calcBounds: function () {
                if (!this.points) {
                    return
                }
                var e = this;
                e._bounds = new dP();
                if (!this.hasMultipleParts) {
                    C.each(this.points, function (i) {
                        e._bounds.extend(i)
                    })
                } else {
                    C.each(this.points, function (i) {
                        C.each(i, function (T) {
                            e._bounds.extend(T)
                        })
                    })
                }
            },
            getPoints: function () {
                return this.points
            },
            getPathIn: function () {
                return this.points
            },
            setPointAt: function (i, e) {
                if (!e || !this.points[i]) {
                    return
                }
                this._clearCache();
                this.points[i] = new ho(e.lng, e.lat);
                this._calcBounds()
            },
            setPositionAt: function (i, e) {
                if (!e || !this.points[i]) {
                    return
                }
                var T = ek.convertLL2MC(e);
                this.setPointAt(i, T)
            },
            setOptions: function (i) {
                i = i || {};
                for (var e in i) {
                    if (i.hasOwnProperty(e)) {
                        this._config[e] = i[e]
                    }
                }
            },
            setStrokeColor: function (e) {
                this._config.strokeColor = e
            },
            getStrokeColor: function () {
                return this._config.strokeColor
            },
            setStrokeLineCap: function (e) {
                this._config.strokeLineCap = e
            },
            getStrokeLineCap: function () {
                return this._config.strokeLineCap
            },
            setStrokeLineJoin: function (e) {
                this._config.strokeLineJoin = e
            },
            getStrokeLineJoin: function () {
                return this._config.strokeLineJoin
            },
            setStrokeWeight: function (e) {
                if (e > 0) {
                    this._config.strokeWeight = e
                }
            },
            getStrokeWeight: function () {
                return this._config.strokeWeight
            },
            setStrokeOpacity: function (e) {
                if (!e || e > 1 || e < 0) {
                    return
                }
                this._config.strokeOpacity = e
            },
            getStrokeOpacity: function () {
                return this._config.strokeOpacity
            },
            setFillOpacity: function (e) {
                if (e > 1 || e < 0) {
                    return
                }
                this._config.fillOpacity = e
            },
            getFillOpacity: function () {
                return this._config.fillOpacity
            },
            setStrokeStyle: function (e) {
                if (e !== "solid" && e !== "dashed" && e !== "dotted") {
                    return
                }
                this._config.strokeStyle = e
            },
            getStrokeStyle: function () {
                return this._config.strokeStyle
            },
            setFillColor: function (e) {
                this._config.fillColor = e || ""
            },
            getFillColor: function () {
                return this._config.fillColor
            },
            getBoundsIn: function () {
                this._bounds.setMinMax();
                return this._bounds
            },
            getBounds: function () {
                var e = this.getBoundsIn();
                var i = new dP(ek.convertMC2LL(e.getSouthWest()), ek.convertMC2LL(e.getNorthEast()));
                i.setMinMax();
                return i
            },
            remove: function () {
                if (this.map) {
                    this.map.removeEventListener("onmousemove", this._graphMouseEvent);
                    this.map.removeEventListener("onclick", this._graphClickEvent)
                }
                cS.prototype.remove.call(this);
                this._clearCache();
                var e = new a8("onlineupdate");
                e.action = "remove";
                e.overlay = this;
                this.fire(e)
            },
            enableEditing: function () {
                if (this.points.length < 2) {
                    return
                }
                this._config.enableEditing = true;
                var e = this;
                d7.load("poly", function () {
                    e.addVertexs()
                }, true)
            },
            disableEditing: function () {
                this._config.enableEditing = false;
                var e = this;
                d7.load("poly", function () {
                    e.clearVertexs()
                }, true)
            },
            getLength: function () {
                if (typeof this._length === "number") {
                    return this._length
                }
                if (typeof this._config.totalLength === "number") {
                    this._length = this._config.totalLength;
                    return this._length
                }
                var T = 0;
                if (this.points.length <= 1) {
                    this._length = 0;
                    return T
                }
                for (var e = 0; e < this.points.length - 1; e++) {
                    T += bM(this.points[e], this.points[e + 1])
                }
                this._length = T;
                return T
            },
            getParsedPoints: function () {
                var e = this._simplification(this.points);
                if (this.hasMultipleParts) {
                    return e
                }
                return [e]
            },
            _simplification: function (hR) {
                var e = this.map;
                var hQ = this.getParseCacheIndex(e.getZoom());
                var hT;
                if (this._parseCache[hQ]) {
                    hT = this._parseCache[hQ]
                } else {
                    var hO = hR;
                    if (this.greatCirclePoints.length > 0) {
                        hO = this.greatCirclePoints
                    }
                    var hP = this.getParseTolerance(e.getZoom(), e.config.coordType);
                    if (!this.hasMultipleParts) {
                        var hS = hB(hO, hP)
                    } else {
                        var hS = [];
                        for (var T = 0; T < hO.length; T++) {
                            var hN = hB(hO[T], hP);
                            hS.push(hN)
                        }
                    }
                    hT = this._parseCache[hQ] = hS
                }
                return hT
            },
            _clearCache: function () {
                this._length = null;
                this._parseCache.length = 0;
                this._parseCacheGL.length = 0;
                this._parseCacheGLRaw.length = 0;
                this._areaCacheGL.length = 0
            },
            canRenderDataBeMerged: function () {
                var e = this._config;
                if (e.texture) {
                    return false
                }
                return true
            }
        });
        if (C.Browser.ie && document.namespaces && !document.namespaces.olv) {
            document.namespaces.add("olv", "urn:schemas-microsoft-com:vml")
        }

        function g7(hP, hN, T) {
            if (!hP || !hN) {
                return
            }
            this.imageUrl = null;
            this.imageDom = null;
            if (typeof hP === "string") {
                this.imageUrl = hP
            } else {
                this.imageDom = hP;
                if (!this.imageDom.id) {
                    this.imageDom.id = bl.getGUID("icon_dom_")
                }
            }
            this.size = hN;
            var hO = new d6(Math.floor(hN.width / 2), Math.floor(hN.height / 2));
            var i = {
                offset: hO,
                imageOffset: new d6(0, 0)
            };
            T = T || {};
            for (var e in T) {
                i[e] = T[e]
            }
            if (T.anchor) {
                i.offset = T.anchor
            }
            this.anchor = this.offset = i.offset;
            this.imageOffset = i.imageOffset;
            this.infoWindowOffset = T.infoWindowOffset || this.offset;
            this.printImageUrl = T.printImageUrl || "";
            this.imageSize = T.imageSize || this.size;
            this.srcSetObject = {};
            this.setImageSrcset(T.srcset || T.srcSet)
        }
        g7.prototype.setImageUrl = function (e) {
            if (!e) {
                return
            }
            this.imageUrl = e;
            this._renderData = null
        };
        g7.prototype.getCurrentImageUrl = function () {
            if (window.devicePixelRatio > 1 && this.srcSetObject["2x"]) {
                return this.srcSetObject["2x"]
            }
            return this.imageUrl
        };
        g7.prototype.setPrintImageUrl = function (e) {
            if (!e) {
                return
            }
            this.printImageUrl = e
        };
        g7.prototype.setSize = function (e) {
            if (!e) {
                return
            }
            this.size = new d6(e.width, e.height);
            this._renderData = null
        };
        g7.prototype.setOffset = function (e) {
            if (!e) {
                return
            }
            this.anchor = this.offset = new d6(e.width, e.height);
            this._renderData = null
        };
        g7.prototype.setAnchor = function (e) {
            this.setOffset(e)
        };
        g7.prototype.setImageOffset = function (e) {
            if (!e) {
                return
            }
            this.imageOffset = new d6(e.width, e.height);
            this._renderData = null
        };
        g7.prototype.setInfoWindowOffset = function (e) {
            if (!e) {
                return
            }
            this.infoWindowOffset = new d6(e.width, e.height)
        };
        g7.prototype.setImageSize = function (e) {
            if (!e) {
                return
            }
            this.imageSize = new d6(e.width, e.height)
        };
        g7.prototype.setImageSrcset = function (T) {
            var e = "";
            if (!T) {
                return
            }
            for (var i in T) {
                if (T.hasOwnProperty(i)) {
                    this.srcSetObject[i] = T[i];
                    e = T[i] + " " + i + ","
                }
            }
            this.srcSet = e
        };
        g7.prototype.toString = function () {
            return "Icon"
        };
        g7.prototype.generateRenderData = function (hP) {
            var T = this.offset;
            var e = this.size;
            var hR = this.imageOffset;
            var hQ = [];
            hQ.push(-T.width, T.height - e.height, 0);
            hQ.push(e.width - T.width, T.height - e.height, 0);
            hQ.push(e.width - T.width, T.height, 0);
            hQ.push(-T.width, T.height - e.height, 0);
            hQ.push(e.width - T.width, T.height, 0);
            hQ.push(-T.width, T.height, 0);
            if (hP !== 0) {
                for (var hO = 0; hO < hQ.length; hO += 3) {
                    var hN = vec2.fromValues(hQ[hO], hQ[hO + 1]);
                    vec2.rotate(hN, hN, [0, 0], dH(-hP));
                    hQ[hO] = hN[0];
                    hQ[hO + 1] = hN[1]
                }
            }
            return {
                vertex: hQ
            }
        };
        g7.prototype.getRenderData = function (e) {
            this._renderData = this.generateRenderData(e);
            return this._renderData
        };

        function an(T, i) {
            C.BaseClass.call(this);
            this.content = T;
            this.map = null;
            this._config = {
                width: 0,
                height: 0,
                maxWidth: 600,
                offset: new d6(0, 0),
                title: "",
                maxContent: "",
                enableMaximize: false,
                enableAutoPan: true,
                enableCloseOnClick: true,
                margin: [10, 10, 40, 10],
                collisions: [
                    [10, 10],
                    [10, 10],
                    [10, 10],
                    [10, 10]
                ],
                ifMaxScene: false,
                onClosing: function () {
                    return true
                }
            };
            this.setConfig(i);
            if (this._config.width !== 0) {
                if (this._config.width < 220) {
                    this._config.width = 220
                }
                if (this._config.width > 730) {
                    this._config.width = 730
                }
            }
            if (this._config.height !== 0) {
                if (this._config.height < 60) {
                    this._config.height = 60
                }
                if (this._config.height > 650) {
                    this._config.height = 650
                }
            }
            if (this._config.maxWidth !== 0) {
                if (this._config.maxWidth < 220) {
                    this._config.maxWidth = 220
                }
                if (this._config.maxWidth > 730) {
                    this._config.maxWidth = 730
                }
            }
            this.isWinMax = false;
            this.IMG_PATH = e0.imgPath;
            this.overlay = null;
            var e = this;
            d7.load("infowindow", function () {
                e._draw()
            })
        }
        an.inherits(C.BaseClass, "InfoWindow");
        C.extend(an.prototype, {
            setWidth: function (e) {
                e = e * 1;
                if (!e && e !== 0 || isNaN(e) || e < 0) {
                    return
                }
                if (e !== 0) {
                    if (e < 220) {
                        e = 220
                    }
                    if (e > 730) {
                        e = 730
                    }
                }
                this._config.width = e
            },
            setHeight: function (e) {
                e = e * 1;
                if (!e && e !== 0 || isNaN(e) || e < 0) {
                    return
                }
                if (e !== 0) {
                    if (e < 60) {
                        e = 60
                    }
                    if (e > 650) {
                        e = 650
                    }
                }
                this._config.height = e
            },
            setMaxWidth: function (e) {
                e = e * 1;
                if (!e && e !== 0 || isNaN(e) || e < 0) {
                    return
                }
                if (e !== 0) {
                    if (e < 220) {
                        e = 220
                    }
                    if (e > 730) {
                        e = 730
                    }
                }
                this._config.maxWidth = e
            },
            setTitle: function (e) {
                this._config.title = e || ""
            },
            setContent: function (e) {
                this.content = e || ""
            },
            getContent: function () {
                return this.content
            },
            setMaxContent: function (e) {
                this._config.maxContent = e || ""
            },
            redraw: function () { },
            enableAutoPan: function () {
                this._config.enableAutoPan = true
            },
            disableAutoPan: function () {
                this._config.enableAutoPan = false
            },
            enableCloseOnClick: function () {
                this._config.enableCloseOnClick = true
            },
            disableCloseOnClick: function () {
                this._config.enableCloseOnClick = false
            },
            enableMaximize: function () {
                this._config.enableMaximize = true
            },
            disableMaximize: function () {
                this._config.enableMaximize = false
            },
            show: function () {
                this._visible = true
            },
            hide: function () {
                this._visible = false
            },
            close: function () {
                this.hide()
            },
            dispose: function () {
                C.BaseClass.prototype.decontrol.call(this)
            },
            maximize: function () {
                this.isWinMax = true
            },
            restore: function () {
                this.isWinMax = false
            },
            setConfig: function (i) {
                if (!i) {
                    return
                }
                for (var e in i) {
                    if (typeof (this._config[e]) === typeof (i[e])) {
                        this._config[e] = i[e]
                    }
                }
            },
            isVisible: function () {
                return this.isOpen()
            },
            isOpen: function () {
                return false
            },
            getPointIn: function () {
                if (this.overlay && this.overlay.getPoint) {
                    return this.overlay.getPoint()
                }
            },
            getTitle: function () {
                return this._config.title || ""
            },
            getPosition: function () {
                return this.latLng;
                var e = this.getPointIn();
                return ek.convertMC2LL(e)
            },
            getPoint: function () {
                var e = this.getPointIn();
                return ek.convertMC2LL(e)
            },
            getOffset: function () {
                return this._config.offset
            },
            dispose: function () {
                C.BaseClass.prototype.decontrol.call(this)
            },
            toString: function () {
                return "InfoWindow"
            }
        });
        c5.prototype.openInfoWindow = function (T, e) {
            T.latLng = new c0(e.lat, e.lng);
            var i = ek.convertLL2MC(e);
            this.openInfoWindowIn(T, i)
        };
        c5.prototype.closeInfoWindow = function () {
            var e = this.temp.infoWin || this.temp._infoWin;
            if (e && e.overlay) {
                e.overlay.closeInfoWindow()
            }
        };
        c5.prototype.openInfoWindowIn = function (hN, e) {
            if (!hN || hN.toString() !== "InfoWindow" || !e || e.toString() !== "Point") {
                return
            }
            var i = this.temp;
            if (!i.marker) {
                var T = new g7(e0.imgPath + "blank.gif", {
                    width: 1,
                    height: 1
                });
                i.marker = new dn(e, {
                    icon: T,
                    width: 1,
                    height: 1,
                    offset: new d6(0, 0),
                    infoWindowOffset: new d6(0, 0),
                    clickable: false
                });
                i.marker._fromMap = 1
            } else {
                i.marker.setPoint(e)
            }
            this.addOverlay(i.marker);
            i.marker.show();
            i.marker.openInfoWindow(hN)
        };
        cS.prototype.openInfoWindow = function (e) {
            if (this.map) {
                this.map.closeInfoWindow();
                e._visible = true;
                this.map.temp._infoWin = e;
                e.overlay = this;
                C.BaseClass.call(e, e.hashCode)
            }
        };
        cS.prototype.closeInfoWindow = function () {
            if (this.map && this.map.temp._infoWin) {
                this.map.temp._infoWin._visible = false;
                this.map.temp._infoWin.decontrol();
                this.map.temp._infoWin = null
            }
        };

        function aK(T, i) {
            cS.call(this);
            this.content = T;
            this.map = null;
            this.domElement = null;
            this._config = {
                width: 0,
                offset: new d6(0, 0),
                styles: {
                    backgroundColor: "#fff",
                    border: "1px solid #f00",
                    padding: "1px",
                    whiteSpace: "nowrap",
                    fontSize: "12px",
                    zIndex: "80",
                    MozUserSelect: "none"
                },
                point: null,
                enableMassClear: true
            };
            i = i || {};
            this.setConfig(i);
            if (this._config.width < 0) {
                this._config.width = 0
            }
            this.point = this._config.point;
            var e = this;
            d7.load("marker", function () {
                e._draw()
            })
        }
        aK.inherits(cS, "Label");
        C.extend(aK.prototype, {
            setPoint: function (e) {
                if (e && e.toString() === "Point" && !this.getMarker()) {
                    this.point = this._config.point = new ho(e.lng, e.lat)
                }
            },
            setContent: function (e) {
                this.content = e
            },
            getContent: function (e) {
                return this.content
            },
            setOpacity: function (e) {
                if (e >= 0 && e <= 1) {
                    this._config.opacity = e
                }
            },
            setOffset: function (e) {
                if (!e || e.toString() !== "Size") {
                    return
                }
                this._config.offset = new d6(e.width, e.height)
            },
            getOffset: function () {
                return this._config.offset
            },
            setStyle: function (e) {
                e = e || {};
                this._config.styles = C.extend(this._config.styles, e)
            },
            setStyles: function (e) {
                this.setStyle(e)
            },
            setTitle: function (e) {
                this._config.title = e || ""
            },
            getTitle: function () {
                return this._config.title
            },
            setMarker: function (e) {
                if (this._marker && this._marker !== e) {
                    this._marker._config.label = null
                }
                this._marker = e;
                if (e) {
                    this.point = this._config.point = e.getPoint()
                } else {
                    this.point = this._config.point = null
                }
            },
            getMarker: function () {
                return this._marker || null
            },
            getPositionIn: function () {
                return this.getPoint()
            },
        });

        function fM(T, i) {
            var hN = {};
            for (var e in i) {
                if (i.hasOwnProperty(e)) {
                    if (e === "position") {
                        hN.point = ek.convertLL2MC(i[e]);
                        this.latLng = new c0(i[e]["lat"], i[e]["lng"])
                    } else {
                        hN[e] = i[e]
                    }
                }
            }
            aK.call(this, T, hN)
        }
        fM.inherits(aK, "LabelOut");
        C.extend(fM.prototype, {
            toString: function () {
                return "Label"
            },
            setPosition: function (e) {
                this.latLng = new c0(e.lat, e.lng);
                var i = ek.convertLL2MC(e);
                this.setPoint(i)
            },
            getPosition: function () {
                return this.latLng;
                var e = this.getPositionIn();
                return ek.convertMC2LL(e)
            }
        });
        window.BMAP_ANIMATION_DROP = 1;
        window.BMAP_ANIMATION_BOUNCE = 2;

        function dn(e, i) {
            cS.call(this);
            i = i || {};
            this.point = e;
            this._rotation = 0;
            this.map = null;
            this._animation = null;
            this.domElement = null;
            this.iconDom = null;
            this.infoWindowDom = null;
            this.siblingElement = null;
            this.textureCoord = null;
            this.textureCoordGLMap = null;
            this.collisionDetectionFailed = false;
            this._config = {
                offset: new d6(0, 0),
                opacity: 1,
                icon: null,
                title: "",
                infoWindow: null,
                label: null,
                baseZIndex: 0,
                clickable: true,
                zIndexFixed: false,
                isTop: false,
                enableMassClear: true,
                enableDragging: false,
                raiseOnDrag: false,
                restrictDraggingArea: false,
                startAnimation: "",
                enableCollisionDetection: false,
                rank: 0,
                enableDraggingMap: false
            };
            this.setConfig(i);
            if (!i.icon) {
                this._config.icon = new g7(e0.imgPath + "marker_red.png", new d6(23, 25), {
                    offset: new d6(10, 25),
                    infoWindowOffset: new d6(10, 0)
                })
            }
            this._isDragging = false;
            var T = this;
            d7.load("marker", function () {
                T._draw()
            })
        }
        dn.TOP_ZINDEX = bi.getZIndex(-90) + 1000000;
        dn.DRAG_ZINDEX = dn.TOP_ZINDEX + 1000000;
        dn._injectMethond = function (e) {
            C.extend(dn.prototype, e)
        };
        dn.inherits(cS, "Marker");
        C.extend(dn.prototype, {
            toString: function () {
                return "Marker"
            },
            setIcon: function (e) {
                if (e) {
                    this._config.icon = e;
                    this.textureCoord = this.textureCoordGLMap = null
                }
            },
            getIcon: function () {
                return this._config.icon
            },
            setLabel: function (e) {
                if (!(e instanceof aK)) {
                    return
                }
                this._config.label = e;
                e._config.enableMassClear = this._config.enableMassClear;
                e.setPoint(this.point)
            },
            getLabel: function () {
                return this._config.label
            },
            enableDragging: function () {
                this._config.enableDragging = true
            },
            disableDragging: function () {
                this._config.enableDragging = false
            },
            setPoint: function (e) {
                if (e) {
                    this.point = this._config.point = new ho(e.lng, e.lat);
                    this.latLng = ek.convertMC2LL(e)
                }
            },
            setPositionIn: function (e) {
                this.setPoint(e)
            },
            getPositionIn: function () {
                return this.getPoint()
            },
            setTop: function (i, e) {
                this._config.isTop = !!i;
                if (i) {
                    this._addi = e || 0
                }
            },
            setTitle: function (e) {
                this._config.title = e || ""
            },
            getTitle: function () {
                return this._config.title
            },
            setOffset: function (e) {
                if (e) {
                    this._config.offset = e
                }
            },
            getOffset: function () {
                return this._config.offset
            },
            setAnimation: function (e) {
                this._animation = e
            },
            setRank: function (e) {
                this._config.rank = e
            },
            getRank: function () {
                return this._config.rank
            },
            setRotation: function (e) {
                while (e < 0) {
                    e += 360
                }
                this._rotation = e % 360
            },
            getRotation: function () {
                return this._rotation
            }
        });

        function aA(e, T) {
            this.latLng = new c0(e.lat, e.lng);
            var i = ek.convertLL2MC(e);
            dn.call(this, i, T)
        }
        aA.inherits(dn, "MarkerOut");
        C.extend(aA.prototype, {
            toString: function () {
                return "Marker"
            },
            setPosition: function (e) {
                this.latLng = new c0(e.lat, e.lng);
                var i = ek.convertLL2MC(e);
                this.setPositionIn(i)
            },
            getPosition: function () {
                return this.latLng;
                var e = this.getPositionIn();
                return ek.convertMC2LL(e)
            }
        });
        window.BMAP_SHAPE_CIRCLE = 1;
        window.BMAP_SHAPE_RECT = 2;

        function ba(i, e, T) {
            cS.call(this, e, T);
            this.domElement = null;
            this.point = i;
            T = T || {};
            this._config = {};
            this._config.height = e || 0;
            this._config.size = typeof T.size === "number" ? T.size : 50;
            this._config.fillOpacity = typeof T.fillOpacity === "number" ? T.fillOpacity : 0.8;
            this._config.shape = typeof T.shape === "number" ? T.shape : 1;
            fC(this._config.fillOpacity, 0, 1);
            if (T.fillColor === "") {
                this._config.fillColor = ""
            } else {
                this._config.fillColor = T.fillColor ? T.fillColor : "#f00"
            }
            this._config.icon = T.icon instanceof g7 ? T.icon : "";
            var hN = this;
            d7.load("marker", function () {
                hN._draw()
            })
        }
        ba.inherits(cS, "Marker3D");
        C.extend(ba.prototype, {
            setPoint: function (e) {
                this.point = this._config.point = new ho(e.lng, e.lat);
                this.latLng = ek.convertMC2LL(e);
                var i = new a8("onstatus_change");
                i.overlay = this;
                i.action = "setPoint";
                this.fire(i)
            },
            setPositionIn: function (e) {
                this.setPoint(e)
            },
            getPositionIn: function () {
                return this.getPoint()
            },
            setDomAttribute: function (i, T) {
                var e = new a8("onlineupdate");
                e.overlay = this;
                this.dispatchEvent(e)
            }
        });

        function cs(i, e, hN) {
            this.latLng = new c0(i.lat, i.lng);
            var T = ek.convertLL2MC(i);
            ba.call(this, T, e, hN)
        }
        cs.inherits(ba, "Marker3d");
        C.extend(cs.prototype, {
            toString: function () {
                return "Marker3D"
            },
            setHeight: function (e) {
                this._config.height = Number(e);
                this.draw();
                var i = new a8("onlineupdate");
                i.overlay = this;
                this.dispatchEvent(i)
            },
            getHeight: function () {
                return this._config.height
            },
            setFillOpacity: function (e) {
                if (e > 1 || e < 0) {
                    return
                }
                this._config.fillOpacity = e;
                this.setDomAttribute("fillopacity", e)
            },
            getFillOpacity: function () {
                return this._config.fillOpacity
            },
            setFillColor: function (e) {
                this._config.fillColor = e || "";
                this.setDomAttribute("fillcolor", e)
            },
            getFillColor: function () {
                return this._config.fillColor
            },
            setIcon: function (i) {
                if (!i || !this.map) {
                    return
                }
                this._config.icon = i;
                if (this._config.icon) {
                    var e = this._config.icon.getCurrentImageUrl();
                    var hN = i.getCurrentImageUrl() !== e;
                    this._config.icon = i;
                    this.textureCoord = this.textureCoordGLMap = null;
                    this.draw();
                    var T = new a8("onstatus_change");
                    T.overlay = this;
                    T.action = "setIcon";
                    T.imageUrlChanged = hN;
                    this.fire(T)
                }
            },
            getIcon: function () {
                return this._config.icon
            },
            setPosition: function (e) {
                this.latLng = new c0(e.lat, e.lng);
                var i = ek.convertLL2MC(e);
                this.setPositionIn(i)
            },
            getPosition: function () {
                var e = this.getPositionIn();
                return ek.convertMC2LL(e)
            }
        });

        function a(T, e) {
            w.call(this, e);
            this._normalizedBounds = new dP();
            this.setPoints(T);
            var i = this;
            d7.load("poly", function () {
                i._draw()
            })
        }
        a.inherits(w, "Polyline");
        C.extend(a.prototype, {
            getBoundsIn: function (e) {
                if (!e) {
                    this._bounds.setMinMax();
                    return this._bounds
                }
                this._normalizedBounds.setMinMax();
                return this._normalizedBounds
            },
            setPoints: function (T) {
                this._clearCache();
                this.points = w.getGraphPoints(T).slice(0);
                if (this._config.geodesic === true) {
                    this.greatCirclePoints.length = 0;
                    for (var e = 0; e < this.points.length - 1; e++) {
                        this.calcGreatCirclePoints(this.points[e], this.points[e + 1])
                    }
                }
                this._calcBounds()
            },
            _calcBounds: function () {
                if (!this.points) {
                    return
                }
                var e = this;
                e._bounds.setNorthEast(null);
                e._bounds.setSouthWest(null);
                if (e.greatCirclePoints && e.greatCirclePoints.length > 0) {
                    C.each(e.greatCirclePoints, function (i) {
                        e._bounds.extend(i)
                    })
                } else {
                    C.each(e.points, function (i) {
                        e._bounds.extend(i)
                    })
                }
                e._normalizedBounds.setSouthWest(e._bounds.getSouthWest());
                e._normalizedBounds.setNorthEast(e._bounds.getNorthEast());
                if (e._normalizedBounds.sw.lng < -c5.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > c5.WORLD_SIZE_MC_HALF) {
                    e._normalizedBounds.sw.lng = -c5.WORLD_SIZE_MC_HALF;
                    e._normalizedBounds.ne.lng = c5.WORLD_SIZE_MC_HALF
                }
            },
            calcGreatCirclePoints: function (hN, T) {
                var hP = hN.latLng;
                var hO = T.latLng;
                if (hP.equals(hO)) {
                    return
                }
                var e = ek.getDistance(dH(hP.lng), dH(hP.lat), dH(hO.lng), dH(hO.lat));
                if (e < 250000) {
                    return
                }
                var hT = Math.round(e / 150000);
                var hX = this.calcAngularDistance(hP, hO);
                this.greatCirclePoints.push(hN);
                var hW = hP.lng;
                var hV = hN;
                for (var hQ = 0; hQ < hT; hQ++) {
                    var hS = this.calcMiddlePoint(hP, hO, hQ / hT, hX);
                    var hU = ek.convertLL2MC(hS);
                    var hR = hU.lng;
                    var hY = bM(hU, hV);
                    if (hY > 30037726) {
                        if (hU.lng < hV.lng) {
                            hU.lng += c5.WORLD_SIZE_MC
                        } else {
                            hU.lng -= c5.WORLD_SIZE_MC
                        }
                    }
                    this.greatCirclePoints.push(hU);
                    hV = hU
                }
                var hY = bM(T, hV);
                if (hY > 30037726) {
                    if (T.lng < hV.lng) {
                        T.lng += c5.WORLD_SIZE_MC
                    } else {
                        T.lng -= c5.WORLD_SIZE_MC
                    }
                }
                this.greatCirclePoints.push(T)
            },
            calcMiddlePoint: function (hU, hT, hV, hZ) {
                var hO = hU.lat;
                var hN = hT.lat;
                var hY = hU.lng;
                var hW = hT.lng;
                var h0 = dH(hO);
                var hX = dH(hN);
                var i = dH(hY);
                var e = dH(hW);
                var h2 = Math.sin((1 - hV) * hZ) / Math.sin(hZ);
                var h1 = Math.sin(hV * hZ) / Math.sin(hZ);
                var hR = h2 * Math.cos(h0) * Math.cos(i) + h1 * Math.cos(hX) * Math.cos(e);
                var hQ = h2 * Math.cos(h0) * Math.sin(i) + h1 * Math.cos(hX) * Math.sin(e);
                var hP = h2 * Math.sin(h0) + h1 * Math.sin(hX);
                var T = Math.atan2(hP, Math.sqrt(Math.pow(hR, 2) + Math.pow(hQ, 2)));
                var hS = Math.atan2(hQ, hR);
                return new ho(db(hS), db(T))
            },
            calcAngularDistance: function (hO, i) {
                var hP = dH(hO.lat);
                var hN = dH(i.lat);
                var T = dH(hO.lng);
                var e = dH(i.lng);
                return Math.acos(Math.sin(hP) * Math.sin(hN) + Math.cos(hP) * Math.cos(hN) * Math.cos(Math.abs(e - T)))
            }
        });

        function ak(hO, e) {
            if (!hO || hO.length === 0) {
                return
            }
            var hN = [];
            for (var T = 0; T < hO.length; T++) {
                hN[T] = ek.convertLL2MC(hO[T])
            }
            a.call(this, hN, e)
        }
        ak.inherits(a, "PolylineOut");
        C.extend(ak.prototype, {
            toString: function () {
                return "Polyline"
            },
            setPath: function (hN) {
                if (!hN || hN.length === 0) {
                    return
                }
                var T = [];
                for (var e = 0; e < hN.length; e++) {
                    T[e] = ek.convertLL2MC(hN[e])
                }
                this.setPathIn(T)
            },
            getPath: function () {
                var e = this.getPathIn();
                if (!e || e.length === 0) {
                    return []
                }
                var hN = [];
                for (var T = 0; T < e.length; T++) {
                    hN[T] = ek.convertMC2LL(e[T])
                }
                return hN
            },
            getBounds: function (i) {
                var e = this.getBoundsIn(i);
                var T = new dP(ek.convertMC2LL(e.getSouthWest()), ek.convertMC2LL(e.getNorthEast()));
                return T
            }
        });

        function em(T, hN, e) {
            w.call(this, e);
            this._normalizedBounds = new dP();
            this._cps = hN;
            this._path = T;
            this.setPoints(T);
            var i = this;
            d7.load("poly", function () {
                i._draw()
            })
        }
        em.inherits(a, "BezierCurve");
        C.extend(em.prototype, {
            getBoundsIn: function (e) {
                if (!e) {
                    this._bounds.setMinMax();
                    return this._bounds
                }
                this._normalizedBounds.setMinMax();
                return this._normalizedBounds
            },
            setPoints: function (e) {
                this._clearCache();
                this.points = w.getGraphPoints(e).slice(0);
                this.points = this.calcBezierPoints(this.points, this._cps);
                this._calcBounds()
            },
            _calcBounds: function () {
                if (!this.points) {
                    return
                }
                var e = this;
                e._bounds.setNorthEast(null);
                e._bounds.setSouthWest(null);
                if (e.greatCirclePoints && e.greatCirclePoints.length > 0) {
                    C.each(e.greatCirclePoints, function (i) {
                        e._bounds.extend(i)
                    })
                } else {
                    C.each(e.points, function (i) {
                        e._bounds.extend(i)
                    })
                }
                e._normalizedBounds.setSouthWest(e._bounds.getSouthWest());
                e._normalizedBounds.setNorthEast(e._bounds.getNorthEast());
                if (e._normalizedBounds.sw.lng < -c5.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > c5.WORLD_SIZE_MC_HALF) {
                    e._normalizedBounds.sw.lng = -c5.WORLD_SIZE_MC_HALF;
                    e._normalizedBounds.ne.lng = c5.WORLD_SIZE_MC_HALF
                }
            },
            getPathIn: function () {
                return this._path
            },
            setPathIn: function (e) {
                this._path = e;
                this.setPoints(e)
            },
            getCpsIn: function () {
                return this._cps
            },
            setCpsIn: function (e) {
                this._cps = e;
                this.setPoints(this._path)
            },
            calcBezierPoints: function (hN, hP) {
                var T = [];
                for (var e = 0; e < hN.length - 1; e++) {
                    var hO = [hN[e], hP[e][0], hP[e][1], hN[e + 1]];
                    T = T.concat((this.bezierbetweenTwoP(hO)))
                }
                return T
            },
            bezierbetweenTwoP: function (hP) {
                var T = 100;
                var hO = 1 / T;
                var e = [];
                for (var hN = 0; hN < T; hN++) {
                    e.push(this.getPointOnCubicBezier(hP, hN * hO))
                }
                return e
            },
            getPointOnCubicBezier: function (hQ, hU) {
                var i;
                var hP;
                var hN;
                var hV;
                var hO;
                var T;
                var hT;
                var e;
                var hS;
                var hR;
                hN = 3 * (hQ[1].lng - hQ[0].lng);
                hP = 3 * (hQ[2].lng - hQ[1].lng) - hN;
                i = hQ[3].lng - hQ[0].lng - hN - hP;
                T = 3 * (hQ[1].lat - hQ[0].lat);
                hO = 3 * (hQ[2].lat - hQ[1].lat) - T;
                hV = hQ[3].lat - hQ[0].lat - T - hO;
                hT = hU * hU;
                e = hT * hU;
                hS = (i * e) + (hP * hT) + (hN * hU) + hQ[0].lng;
                hR = (hV * e) + (hO * hT) + (T * hU) + hQ[0].lat;
                return new ho(hS, hR)
            }
        });

        function fk(hO, hQ, e) {
            if (!hO || hO.length === 0) {
                return
            }
            this.userPath = hO;
            this.userCps = hQ;
            var hN = [];
            for (var T = 0; T < hO.length; T++) {
                hN[T] = ek.convertLL2MC(hO[T])
            }
            if (!hQ || hQ.length === 0) {
                return
            }
            var hP = [];
            for (var T = 0; T < hQ.length; T++) {
                hP[T] = [];
                hP[T][0] = ek.convertLL2MC(hQ[T][0]);
                if (hQ[T][1]) {
                    hP[T][1] = ek.convertLL2MC(hQ[T][1])
                } else {
                    hP[T][1] = ek.convertLL2MC(hQ[T][0])
                }
            }
            em.call(this, hN, hP, e)
        }
        fk.inherits(em, "BezierCurveOut");
        C.extend(fk.prototype, {
            toString: function () {
                return "BezierCurve"
            },
            setPath: function (hN) {
                if (!hN || hN.length === 0) {
                    return
                }
                this.userPath = hN;
                var T = [];
                for (var e = 0; e < hN.length; e++) {
                    T[e] = ek.convertLL2MC(hN[e])
                }
                this.setPathIn(T)
            },
            getPath: function () {
                return this.userPath;
                var e = this.getPathIn();
                if (!e || e.length === 0) {
                    return []
                }
                var hN = [];
                for (var T = 0; T < e.length; T++) {
                    hN[T] = ek.convertMC2LL(e[T])
                }
                return hN
            },
            getControlPoints: function () {
                return this.userCps;
                var e = this.getCpsIn();
                if (!e || e.length === 0) {
                    return []
                }
                var hN = [];
                for (var T = 0; T < e.length; T++) {
                    hN[T] = [];
                    hN[T][0] = ek.convertMC2LL(e[T][0]);
                    hN[T][1] = ek.convertMC2LL(e[T][1])
                }
                return hN
            },
            setControlPoints: function (hN) {
                if (!hN || hN.length === 0) {
                    return
                }
                this.userCps = hN;
                var T = [];
                for (var e = 0; e < hN.length; e++) {
                    T[e] = [];
                    T[e][0] = ek.convertLL2MC(hN[e][0]);
                    if (hN[e][1]) {
                        T[e][1] = ek.convertLL2MC(hN[e][1])
                    } else {
                        T[e][1] = ek.convertLL2MC(hN[e][0])
                    }
                }
                this.setCpsIn(T)
            },
            getBounds: function (i) {
                var e = this.getBoundsIn(i);
                var T = new dP(ek.convertMC2LL(e.getSouthWest()), ek.convertMC2LL(e.getNorthEast()));
                return T
            }
        });

        function fi(e, T) {
            w.call(this, T);
            this._normalizedBounds = new dP();
            this.setPoints(e);
            var i = this;
            d7.load("poly", function () {
                i._draw()
            })
        }
        fi.inherits(a, "PolylineMultipart");
        C.extend(fi.prototype, {
            setPoints: function (e) {
                if (!e) {
                    return
                }
                this._clearCache();
                this.points = this._unifyArgs(e);
                this._calcBounds()
            },
            _unifyArgs: function (T) {
                var e = [];
                var i = [];
                if (T.constructor === Array) {
                    if (T[0].constructor === ho) {
                        i.push(T)
                    } else {
                        i = T
                    }
                } else {
                    if (typeof T === "string") {
                        i.push(T)
                    }
                }
                C.each(i, function (hN) {
                    e.push(w.getGraphPoints(hN))
                });
                return e
            },
            setPointAt: function (i, e, T) {
                T = T || 0;
                if (!e || !this.points[T] || !this.points[T][i]) {
                    return
                }
                this._clearCache();
                this.points[T][i] = new ho(e.lng, e.lat);
                this._calcBounds()
            },
            getBoundsIn: function (e) {
                if (!e) {
                    this._bounds.setMinMax();
                    return this._bounds
                }
                this._normalizedBounds.setMinMax();
                return this._normalizedBounds
            },
            _calcBounds: function () {
                if (!this.points) {
                    return
                }
                var e = this;
                e._bounds.setNorthEast(null);
                e._bounds.setSouthWest(null);
                if (e.greatCirclePoints && e.greatCirclePoints.length > 0) {
                    C.each(e.greatCirclePoints, function (i) {
                        e._bounds.extend(i)
                    })
                } else {
                    C.each(e.points, function (i) {
                        C.each(i, function (T) {
                            e._bounds.extend(T)
                        })
                    })
                }
                e._normalizedBounds.setSouthWest(e._bounds.getSouthWest());
                e._normalizedBounds.setNorthEast(e._bounds.getNorthEast());
                if (e._normalizedBounds.sw.lng < -c5.WORLD_SIZE_MC_HALF || e._normalizedBounds.ne.lng > c5.WORLD_SIZE_MC_HALF) {
                    e._normalizedBounds.sw.lng = -c5.WORLD_SIZE_MC_HALF;
                    e._normalizedBounds.ne.lng = c5.WORLD_SIZE_MC_HALF
                }
            }
        });

        function aO(T, e) {
            w.call(this, e);
            e = e || {};
            if (typeof e.fillOpacity === "number") {
                this._config.fillOpacity = e.fillOpacity
            } else {
                this._config.fillOpacity = 0.6
            }
            fC(this._config.fillOpacity, 0, 1);
            if (e.fillColor === "") {
                this._config.fillColor = ""
            } else {
                this._config.fillColor = e.fillColor ? e.fillColor : "#fff"
            }
            this._parseFillCacheWebGL = [];
            this.setPoints(T, e);
            var i = this;
            d7.load("poly", function () {
                i._draw()
            })
        }
        aO.inherits(w, "Polygon");
        C.extend(aO.prototype, {
            setPoints: function (hP) {
                var hN = [];
                if (typeof hP === "string" || hP[0] instanceof ho || hP[0] instanceof c0 || this instanceof f4 || hP.length === 0) {
                    var e = this._processSinglePointArray(hP);
                    this._userPoints = e.userPoints;
                    hN = e.innerPoints;
                    this.hasMultipleParts = false
                } else {
                    this._userPoints = [];
                    for (var hO = 0; hO < hP.length; hO++) {
                        var T = this._processSinglePointArray(hP[hO]);
                        this._userPoints.push(T.userPoints);
                        hN.push(T.innerPoints)
                    }
                    this.hasMultipleParts = true
                }
                w.prototype.setPoints.call(this, hN)
            },
            setPathIn: function (e) {
                this.setPoints(e)
            },
            _processSinglePointArray: function (e) {
                var i = w.getGraphPoints(e).slice(0);
                innerPoints = i.slice(0);
                if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) {
                    innerPoints.push(new ho(innerPoints[0].lng, innerPoints[0].lat))
                }
                return {
                    userPoints: i,
                    innerPoints: innerPoints
                }
            },
            setPointAt: function (i, e) {
                if (!this._userPoints[i]) {
                    return
                }
                this._clearCache();
                this._userPoints[i] = new ho(e.lng, e.lat);
                this.points[i] = new ho(e.lng, e.lat);
                if (i === 0 && !this.points[0].equals(this.points[this.points.length - 1])) {
                    this.points[this.points.length - 1] = new ho(e.lng, e.lat)
                }
                this._calcBounds()
            },
            setPositionAt: function (i, e) {
                if (!this._userPoints[i]) {
                    return
                }
                var T = ek.convertLL2MC(e);
                this.setPointAt(i, T)
            },
            getPoints: function () {
                var e = this._userPoints;
                if (e.length === 0) {
                    e = this.points
                }
                return e
            },
            getPathIn: function () {
                return this.getPoints()
            }
        });

        function g0(hS, hP) {
            if (!hS || hS.length === 0) {
                return
            }
            var hR = [];
            if (typeof hS === "string" || hS[0] instanceof ho || hS[0] instanceof c0) {
                var e = this._processSinglePointArray(hS);
                for (var hQ = 0; hQ < e.innerPoints.length; hQ++) {
                    hR[hQ] = ek.convertLL2MC(e.innerPoints[hQ])
                }
            } else {
                for (var hQ = 0; hQ < hS.length; hQ++) {
                    var T = this._processSinglePointArray(hS[hQ]);
                    var hO = [];
                    for (var hN = 0; hN < T.innerPoints.length; hN++) {
                        hO[hN] = ek.convertLL2MC(T.innerPoints[hN])
                    }
                    hR.push(hO)
                }
            }
            aO.call(this, hR, hP)
        }
        g0.inherits(aO, "PolygonOut");
        C.extend(g0.prototype, {
            toString: function () {
                return "Polygon"
            },
            setPath: function (hN) {
                if (!hN || hN.length === 0) {
                    return
                }
                hN = w.getGraphPoints(hN);
                var T = [];
                for (var e = 0; e < hN.length; e++) {
                    T[e] = ek.convertLL2MC(hN[e])
                }
                this.setPathIn(T)
            },
            getPath: function () {
                var e = this.getPathIn();
                if (!e || e.length === 0) {
                    return []
                }
                var hN = [];
                for (var T = 0; T < e.length; T++) {
                    hN[T] = ek.convertMC2LL(e[T])
                }
                return hN
            }
        });

        function f4(i, e, T) {
            this.point = i;
            this.radius = Math.abs(e);
            aO.call(this, [], T)
        }
        f4.parseTolerance = {
            0: [0.01, 0.0001, 0.00001, 0.000004],
            1: [1000, 10, 1, 0.4]
        };
        f4.inherits(aO, "Circle");
        C.extend(f4.prototype, {
            initialize: function (e) {
                this.map = e;
                this.points = this._getPerimeterPoints(this.point, this.radius);
                this._calcBounds();
                return null
            },
            getPoint: function () {
                return this.point
            },
            setPoint: function (e) {
                if (!e) {
                    return
                }
                this.point = e;
                this.latLng = ek.convertMC2LL(e)
            },
            setCenterIn: function (e) {
                var i = arguments[1];
                this.setPoint(e, i)
            },
            setRadius: function (e) {
                this.radius = Math.abs(e)
            },
            getCenterIn: function () {
                return this.point
            },
            getRadius: function () {
                return this.radius
            },
            _getPerimeterPoints: function (e, hU) {
                if (!e || !hU || !this.map) {
                    return []
                }
                var T = this.map;
                var hR = e.lng;
                var hP = e.lat;
                var h0 = ek.convertMC2LL(e);
                hR = h0.lng;
                hP = h0.lat;
                var h1 = [];
                var hW = hU / ek.EARTHRADIUS;
                var hT = (Math.PI / 180) * hP;
                var hZ = (Math.PI / 180) * hR;
                for (var hS = 0; hS < 360; hS += 9) {
                    var hQ = (Math.PI / 180) * hS;
                    var hX = Math.asin(Math.sin(hT) * Math.cos(hW) + Math.cos(hT) * Math.sin(hW) * Math.cos(hQ));
                    var hV = Math.atan2(Math.sin(hQ) * Math.sin(hW) * Math.cos(hT), Math.cos(hW) - Math.sin(hT) * Math.sin(hX));
                    var hY = ((hZ - hV + Math.PI) % (2 * Math.PI)) - Math.PI;
                    var hO = new c0(hX * (180 / Math.PI), hY * (180 / Math.PI));
                    h1.push(ek.convertLL2MC(hO))
                }
                var hN = h1[0];
                h1.push(new ho(hN.lng, hN.lat));
                if (hN) {
                    this._radiusMercator = Math.sqrt(Math.pow(hN.lng - this.point.lng, 2) + Math.pow(hN.lat - this.point.lat, 2))
                } else {
                    this._radiusMercator = this.radius
                }
                return h1
            }
        });

        function dC(i, e, hN) {
            this.latLng = new c0(i.lat, i.lng);
            var T = ek.convertLL2MC(i);
            f4.call(this, T, e, hN)
        }
        dC.inherits(f4, "CircleOut");
        C.extend(dC.prototype, {
            toString: function () {
                return "Circle"
            },
            setCenter: function (e) {
                this.latLng = new c0(e.lat, e.lng);
                var i = ek.convertLL2MC(e);
                this.setCenterIn(i)
            },
            getCenter: function () {
                return this.latLng
            },
            getPath: function () {
                var e = this.getPathIn();
                if (!e || e.length === 0) {
                    return []
                }
                var hN = [];
                for (var T = 0; T < e.length; T++) {
                    hN[T] = ek.convertMC2LL(e[T])
                }
                return hN
            }
        });

        function bp(hN, e, i) {
            w.call(this, i);
            i = i || {};
            if (typeof i.topFillOpacity === "number") {
                this._config.topFillOpacity = i.topFillOpacity
            } else {
                this._config.topFillOpacity = 0.6
            } if (typeof i.sideFillOpacity === "number") {
                this._config.sideFillOpacity = i.sideFillOpacity
            } else {
                this._config.sideFillOpacity = 0.8
            }
            fC(this._config.sideFillOpacity, 0, 1);
            if (i.topFillColor === "") {
                this._config.topFillColor = ""
            } else {
                this._config.topFillColor = i.topFillColor ? i.topFillColor : "#fff"
            } if (i.sideFillColor === "") {
                this._config.sideFillColor = ""
            } else {
                this._config.sideFillColor = i.sideFillColor ? i.sideFillColor : "#fff"
            }
            this._parseFillCacheWebGL = [];
            this.setPoints(hN, i);
            this._config.altitude = e || 0;
            var T = this;
            d7.load("poly", function () {
                T._draw()
            })
        }
        bp.inherits(w, "Prism");
        C.extend(bp.prototype, {
            setPoints: function (hP) {
                var hN = [];
                if (typeof hP === "string" || hP[0] instanceof ho || hP[0] instanceof c0 || this instanceof f4 || hP.length === 0) {
                    var e = this._processSinglePointArray(hP);
                    this._userPoints = e.userPoints;
                    hN = e.innerPoints;
                    this.hasMultipleParts = false
                } else {
                    this._userPoints = [];
                    for (var hO = 0; hO < hP.length; hO++) {
                        var T = this._processSinglePointArray(hP[hO]);
                        this._userPoints.push(T.userPoints);
                        hN.push(T.innerPoints)
                    }
                    this.hasMultipleParts = true
                }
                w.prototype.setPoints.call(this, hN)
            },
            setPathIn: function (e) {
                this.setPoints(e)
            },
            _processSinglePointArray: function (e) {
                var i = w.getGraphPoints(e).slice(0);
                innerPoints = i.slice(0);
                if (innerPoints.length > 1 && !innerPoints[0].equals(innerPoints[innerPoints.length - 1])) {
                    innerPoints.push(new ho(innerPoints[0].lng, innerPoints[0].lat))
                }
                return {
                    userPoints: i,
                    innerPoints: innerPoints
                }
            },
            setPointAt: function (i, e) {
                if (!this._userPoints[i]) {
                    return
                }
                this._clearCache();
                this._userPoints[i] = new ho(e.lng, e.lat);
                this.points[i] = new ho(e.lng, e.lat);
                if (i === 0 && !this.points[0].equals(this.points[this.points.length - 1])) {
                    this.points[this.points.length - 1] = new ho(e.lng, e.lat)
                }
                this._calcBounds()
            },
            getPoints: function () {
                var e = this._userPoints;
                if (e.length === 0) {
                    e = this.points
                }
                return e
            },
            getPathIn: function () {
                return this.getPoints()
            },
            setTopFillOpacity: function (e) {
                if (e > 1 || e < 0) {
                    return
                }
                this._config.topFillOpacity = e;
                this._setDomAttribute("topfillopacity", e)
            },
            getTopFillOpacity: function () {
                return this._config.topFillOpacity
            },
            setSideFillOpacity: function (e) {
                if (e > 1 || e < 0) {
                    return
                }
                this._config.sideFillOpacity = e;
                this._setDomAttribute("sidefillopacity", e)
            },
            getSideFillOpacity: function () {
                return this._config.sideFillOpacity
            },
            setTopFillColor: function (e) {
                this._config.topFillColor = e || "";
                this._setDomAttribute("topfillcolor", e)
            },
            getTopFillColor: function () {
                return this._config.topFillColor
            },
            setSideFillColor: function (e) {
                this._config.sideFillColor = e || "";
                this._setDomAttribute("sidefillcolor", e)
            },
            getSideFillColor: function () {
                return this._config.sideFillColor
            },
            setAltitude: function (e) {
                this._config.altitude = Number(e);
                this.draw();
                var i = new a8("onlineupdate");
                i.overlay = this;
                this.dispatchEvent(i)
            },
            getAltitude: function () {
                return this._config.altitude
            }
        });

        function cd(hR, hP, hS) {
            if (!hR || hR.length === 0) {
                return
            }
            this.userPath = hR;
            var e = [];
            if (typeof hR === "string" || hR[0] instanceof ho || hR[0] instanceof c0) {
                var hT = this._processSinglePointArray(hR);
                for (var hO = 0; hO < hT.innerPoints.length; hO++) {
                    e[hO] = ek.convertLL2MC(hT.innerPoints[hO])
                }
            } else {
                for (var hO = 0; hO < hR.length; hO++) {
                    var hQ = this._processSinglePointArray(hR[hO]);
                    var T = [];
                    for (var hN = 0; hN < hQ.innerPoints.length; hN++) {
                        T[hN] = ek.convertLL2MC(hQ.innerPoints[hN])
                    }
                    e.push(T)
                }
            }
            bp.call(this, e, hP, hS)
        }
        cd.inherits(bp, "PrismOut");
        C.extend(cd.prototype, {
            toString: function () {
                return "Prism"
            },
            setPath: function (hN) {
                if (!hN || hN.length === 0) {
                    return
                }
                this.userPath = hN;
                var T = [];
                for (var e = 0; e < hN.length; e++) {
                    T[e] = ek.convertLL2MC(hN[e])
                }
                this.setPathIn(T)
            },
            getPath: function () {
                return this.userPath;
                var e = this.getPathIn();
                if (!e || e.length === 0) {
                    return []
                }
                var hN = [];
                for (var T = 0; T < e.length; T++) {
                    hN[T] = ek.convertMC2LL(e[T])
                }
                return hN
            }
        });

        function dT(T, e) {
            w.call(this, e);
            e = e || {};
            this._config.type = e.type || "image";
            this._config.url = e.url || "";
            this._config.opacity = typeof e.opacity === "number" ? e.opacity : 1;
            fC(this._config.opacity, 0, 1);
            this._parseFillCacheWebGL = [];
            this.setPoints(T, e);
            var i = this;
            d7.load("poly", function () {
                i._draw()
            })
        }
        dT.inherits(w, "GroundOverlay");
        C.extend(dT.prototype, {
            setPoints: function (i) {
                var e = w.getGraphPoints(i).slice(0);
                this.hasMultipleParts = false;
                w.prototype.setPoints.call(this, e)
            },
            setPathIn: function (e) {
                this.setPoints(e)
            },
            getPoints: function () {
                return this.points
            },
            getPathIn: function () {
                return this.getPoints()
            }
        });

        function cm(hO, T) {
            if (!hO) {
                return
            }
            var hQ = [new ho(hO.sw.lng, hO.ne.lat), new ho(hO.ne.lng, hO.ne.lat), new ho(hO.ne.lng, hO.sw.lat), new ho(hO.sw.lng, hO.sw.lat)];
            var e = w.getGraphPoints(hQ).slice(0);
            var hP = [];
            for (var hN = 0; hN < e.length; hN++) {
                hP[hN] = ek.convertLL2MC(e[hN])
            }
            dT.call(this, hP, T)
        }
        cm.inherits(dT, "GroundOverlayOut");
        C.extend(cm.prototype, {
            toString: function () {
                return "GroundOverlay"
            }
        });
        var by = {};

        function hD(T, i) {
            C.BaseClass.call(this);
            this.content = T;
            this.map = null;
            this._config = {
                width: 0,
                height: 0,
                maxWidth: 600,
                offset: new d6(0, 0),
                title: "",
                maxContent: "",
                enableMaximize: false,
                enableAutoPan: true,
                enableCloseOnClick: true,
                margin: [10, 10, 40, 10],
                collisions: [
                    [10, 10],
                    [10, 10],
                    [10, 10],
                    [10, 10]
                ],
                ifMaxScene: false,
                onClosing: function () {
                    return true
                }
            };
            this.setConfig(i);
            if (this._config.width < 50) {
                this._config.width = 50
            }
            if (this._config.width > 730) {
                this._config.width = 730
            }
            if (this._config.height != 0) {
                if (this._config.height < 50) {
                    this._config.height = 50
                }
                if (this._config.height > 650) {
                    this._config.height = 650
                }
            }
            if (this._config.maxWidth !== 0) {
                if (this._config.maxWidth < 50) {
                    this._config.maxWidth = 50
                }
                if (this._config.maxWidth > 730) {
                    this._config.maxWidth = 730
                }
            }
            this.isWinMax = false;
            this.IMG_PATH = e0.imgPath;
            this.overlay = null;
            var e = this;
            d7.load("simpleInfowindow", function () {
                e._draw()
            })
        }
        hD.inherits(C.BaseClass, "SimpleInfoWindow");
        C.extend(hD.prototype, {
            setWidth: function (e) {
                e = e * 1;
                if (!e && e != 0 || isNaN(e) || e < 0) {
                    return
                }
                if (e != 0) {
                    if (e < 50) {
                        e = 50
                    }
                    if (e > 730) {
                        e = 730
                    }
                }
                this._config.width = e
            },
            setHeight: function (e) {
                e = e * 1;
                e -= 10;
                if (!e && e != 0 || isNaN(e) || e < 0) {
                    return
                }
                if (e != 0) {
                    if (e < 50) {
                        e = 50
                    }
                    if (e > 650) {
                        e = 650
                    }
                }
                this._config.height = e
            },
            setMaxWidth: function (e) {
                e = e * 1;
                if (!e && e != 0 || isNaN(e) || e < 0) {
                    return
                }
                if (e != 0) {
                    if (e < 50) {
                        e = 50
                    }
                    if (e > 730) {
                        e = 730
                    }
                }
                this._config.maxWidth = e
            },
            setTitle: function (e) {
                this._config.title = e || ""
            },
            setContent: function (e) {
                this.content = e || ""
            },
            setMaxContent: function (e) {
                this._config.maxContent = e || ""
            },
            redraw: function () { },
            enableAutoPan: function () {
                this._config.enableAutoPan = true
            },
            disableAutoPan: function () {
                this._config.enableAutoPan = false
            },
            enableCloseOnClick: function () {
                this._config.enableCloseOnClick = true
            },
            disableCloseOnClick: function () {
                this._config.enableCloseOnClick = false
            },
            enableMaximize: function () {
                this._config.enableMaximize = true
            },
            disableMaximize: function () {
                this._config.enableMaximize = false
            },
            show: function () {
                this._visible = true
            },
            hide: function () {
                this._visible = false
            },
            close: function () {
                this.hide()
            },
            dispose: function () {
                C.BaseClass.prototype.decontrol.call(this)
            },
            maximize: function () {
                this.isWinMax = true
            },
            restore: function () {
                this.isWinMax = false
            },
            setConfig: function (i) {
                if (!i) {
                    return
                }
                for (var e in i) {
                    if (typeof (this._config[e]) == typeof (i[e])) {
                        this._config[e] = i[e]
                    }
                }
            },
            isVisible: function () {
                return this.isOpen()
            },
            isOpen: function () {
                return false
            },
            getPoint: function () {
                if (this.overlay && this.overlay.getPoint) {
                    return this.overlay.getPoint()
                }
            },
            getOffset: function () {
                return this._config.offset
            },
            dispose: function () {
                C.BaseClass.prototype.decontrol.call(this)
            },
            toString: function () {
                return "SimpleInfoWindow"
            }
        });
        c5.prototype.openSimpleInfoWindow = function (hN, e) {
            if (!hN || hN.toString() != "SimpleInfoWindow" || !e || e.toString() != "Point") {
                return
            }
            var i = this.temp;
            if (!i.marker) {
                var T = new g7(e0.imgPath + "blank.gif", {
                    width: 1,
                    height: 1
                });
                i.marker = new dn(e, {
                    icon: T,
                    width: 1,
                    height: 1,
                    offset: new d6(0, 0),
                    infoWindowOffset: new d6(0, 0),
                    clickable: false
                });
                i.marker._fromMap = 1
            } else {
                i.marker.setPoint(e)
            }
            this.addOverlay(i.marker);
            i.marker.show();
            i.marker.openSimpleInfoWindow(hN)
        };
        c5.prototype.closeSimpleInfoWindow = function () {
            var e = this.temp.infoWin || this.temp._infoWin;
            if (e && e.overlay) {
                e.overlay.closeSimpleInfoWindow()
            }
        };
        cS.prototype.openSimpleInfoWindow = function (e) {
            if (this.map) {
                this.map.closeSimpleInfoWindow();
                e._visible = true;
                this.map.temp._infoWin = e;
                e.overlay = this;
                C.BaseClass.call(e, e.hashCode)
            }
        };
        cS.prototype.closeSimpleInfoWindow = function () {
            if (this.map && this.map.temp._infoWin) {
                this.map.temp._infoWin._visible = false;
                this.map.temp._infoWin.decontrol();
                this.map.temp._infoWin = null
            }
        };

        function eg(e, i) {
            e = isNaN(e) ? 0 : e;
            i = isNaN(i) ? 0 : i;
            this.x = e;
            this.y = i
        }
        eg.prototype.equals = function (e) {
            if (!e) {
                return false
            }
            return e.x === this.x && e.y === this.y
        };
        eg.prototype.clone = function () {
            return new eg(this.x, this.y)
        };
        eg.prototype.toString = function () {
            return "Pixel"
        };

        function d6(i, e) {
            if (typeof i !== "number") {
                this.width = parseFloat(i)
            } else {
                this.width = i
            } if (typeof e !== "number") {
                this.height = parseFloat(e)
            } else {
                this.height = e
            }
        }
        d6.prototype.equals = function (e) {
            return !!(e && this.width === e.width && this.height === e.height)
        };
        d6.prototype.toString = function () {
            return "Size"
        };
        var bE = {
            B_NORMAL_MAP: {
                tileUrls: eo(e0.tileDomain, e0.rasterTilePath),
                vectorTileUrls: eo(e0.tileDomain, e0.vectorTilePath),
                tileSize: 256,
                baseUnits: 256,
                zoomLevelMin: 3,
                zoomLevelMax: 19,
                minDataZoom: 3,
                maxDataZoom: 19,
                minZoom: 3,
                maxZoom: 19,
                webgl: {
                    minZoom: 3,
                    maxZoom: 25
                },
                zoomLevelBase: 18,
                errorUrl: e0.imgPath + "bg.png",
                bounds: new dP(new ho(-21364736, -11708041.66), new ho(23855104, 12474104.17)),
                imgExtend: "png"
            },
            B_SATELLITE_MAP: {
                tileUrls: ["https://maponline0.bdimg.com/starpic/?qt=satepc&", "https://maponline1.bdimg.com/starpic/?qt=satepc&", "https://maponline2.bdimg.com/starpic/?qt=satepc&", "https://maponline3.bdimg.com/starpic/?qt=satepc&"],
                tileSize: 256,
                baseUnits: 256,
                zoomLevelMin: 3,
                zoomLevelMax: 19,
                minDataZoom: 3,
                maxDataZoom: 19,
                minZoom: 3,
                maxZoom: 19,
                zoomLevelBase: 18,
                errorUrl: e0.imgPath + "bg.png",
                bounds: new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712)),
                imgExtend: "png"
            },
            B_STREET_MAP: {
                tileUrls: eo(e0.tileDomain, e0.rasterTilePath),
                tileSize: 256,
                baseUnits: 256,
                zoomLevelMin: 3,
                zoomLevelMax: 19,
                minDataZoom: 3,
                maxDataZoom: 19,
                minZoom: 3,
                maxZoom: 19,
                zoomLevelBase: 18,
                errorUrl: e0.imgPath + "bg.png",
                bounds: new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712)),
                imgExtend: "png"
            },
            BMAP_CUSTOM_LAYER: {
                tileUrls: [""],
                tileSize: 256,
                baseUnits: 256,
                zoomLevelMin: 1,
                zoomLevelMax: 19,
                minDataZoom: 3,
                maxDataZoom: 19,
                minZoom: 3,
                maxZoom: 19,
                zoomLevelBase: 18,
                errorUrl: e0.imgPath + "blank.gif",
                bounds: new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712)),
                imgExtend: "png"
            },
            B_EARTH_MAP: {
                tileUrls: [""],
                tileSize: 256,
                baseUnits: 256,
                zoomLevelMin: 3,
                zoomLevelMax: 19,
                minDataZoom: 3,
                maxDataZoom: 19,
                minZoom: 3,
                maxZoom: 19,
                webgl: {
                    minZoom: 3,
                    maxZoom: 21
                },
                zoomLevelBase: 18,
                errorUrl: e0.imgPath + "blank.gif",
                bounds: new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712)),
                imgExtend: "png"
            }
        };
        var b3 = bE;

        function bQ(hS, i, hO, T, hN) {
            this.mgr = hS;
            this.position = hO;
            this._cbks = [];
            this.name = hS.getTileName(T, hN, hS.map.config.style);
            this.info = T;
            this._transparentPng = hN.isTransparentPng();
            var hT = S("img");
            dj(hT);
            hT.galleryImg = false;
            var hR = hT.style;
            hR.position = "absolute";
            hR.width = hS.tileSize + "px";
            hR.height = hS.tileSize + "px";
            hR.left = hO[0] + "px";
            hR.top = hO[1] + "px";
            this.img = hT;
            this.src = i;
            if (ab && hO._offsetX === 0) {
                hR.opacity = 0;
                hR.willChange = "opacity"
            }
            var hQ = this;
            this.img.onload = function (h1) {
                if (!hQ.mgr) {
                    return
                }
                var hW = hQ.mgr;
                var hU = hW.bufferTiles;
                if (hW.bufferNumber > 0) {
                    hU[hQ.name] = hQ;
                    hU.push(hQ.name)
                }
                var hY = hU.length - hW.bufferNumber;
                for (var hZ = 0; hY > 0 && hZ < hU.length; hZ++) {
                    var h0 = hU[hZ];
                    if (!hW.mapTiles[h0]) {
                        if (hU[h0]) {
                            hU[h0].mgr = null;
                            var hX = hU[h0].img;
                            if (hX.parentNode) {
                                fn(hX);
                                hX.parentNode.removeChild(hX)
                            }
                            hX = null;
                            hU[h0].img = null;
                            hU[h0] = null;
                            delete hU[h0]
                        }
                        hU.splice(hZ, 1);
                        hZ--;
                        hY--
                    }
                }
                hQ.loaded = true;
                hW.imgNumber++;
                if (!g9(hQ.img)) {
                    if (hN.tilesDiv) {
                        hN.tilesDiv.appendChild(hQ.img)
                    }
                }
                var h1 = new a8("onimagechange");
                h1.action = "show";
                h1.tile = hQ.name;
                hW.map.dispatchEvent(h1);
                if (ab && hO._offsetX === 0) {
                    var hV = new o({
                        fps: 10,
                        duration: 300,
                        render: function (e) {
                            if (hQ.img && hQ.img.style) {
                                hQ.img.style.opacity = e * 1
                            }
                        },
                        finish: function () {
                            if (hQ.img && hQ.img.style) {
                                delete hQ.img.style.opacity;
                                hQ.img.style.willChange = "auto"
                            }
                        }
                    })
                }
                hQ._callCbks()
            };
            this.img.onerror = function (hW) {
                hQ.error = true;
                hQ._callCbks();
                if (!hQ.mgr) {
                    return
                }
                var hU = hQ.mgr;
                var hV = b3[hN.mapType];
                if (hV.errorUrl) {
                    hQ.img.src = hV.errorUrl
                }
                if (!g9(hQ.img)) {
                    if (hN.tilesDiv) {
                        hN.tilesDiv.appendChild(hQ.img)
                    }
                }
            };
            hT = null;
            var hP = new a8("onimagebefore");
            hP.tile = hQ.name;
            hS.map.dispatchEvent(hP)
        }
        bQ.prototype._addLoadCbk = function (e) {
            this._cbks.push(e)
        };
        bQ.prototype._load = function () {
            if (FeBrowser.ie <= 6 && FeBrowser.ie > 0 && this._transparentPng) {
                this.img.src = e0.imgPath + "blank.gif"
            } else {
                this.img.src = this.src
            }
        };
        bQ.prototype._callCbks = function () {
            var T = this;
            for (var e = 0; e < T._cbks.length; e++) {
                T._cbks[e]()
            }
            T._cbks.length = 0
        };
        var ab = (!C.Browser.ie || C.Browser.ie > 8);

        function fa(e) {
            this.tileLayers = [];
            this.map = e;
            this.bufferNumber = 300;
            this.mapTiles = [];
            this.bufferTiles = [];
            this.config = b3[this.map.mapType];
            this.errorUrl = this.config.errorUrl;
            this.tileSize = this.config.tileSize;
            this.baseUnits = this.config.baseUnits;
            this.baseZoomLevel = this.config.zoomLevelBase;
            this.tileURLs = this.config.tileUrls;
            this.imgNumber = 0;
            this.numLoading = 0;
            this.temp = {}
        }
        bl.register(function (i) {
            if (i._renderType === "webgl") {
                return
            }
            var e = i.tileMgr = new fa(i);
            i.addEventListener("mousewheel", function (T) {
                e.mouseWheel(T)
            });
            i.addEventListener("dblclick", function (T) {
                e.dblClick(T)
            });
            i.addEventListener("rightdblclick", function (T) {
                e.dblClick(T)
            });
            i.addEventListener("minuspress", function (T) {
                e.keypress(T)
            });
            i.addEventListener("pluspress", function (T) {
                e.keypress(T)
            });
            i.addEventListener("load", function (T) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    return
                }
                e.loadTiles()
            });
            i.addEventListener("zoomstartcode", function (T) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    return
                }
                e._zoom(T)
            });
            i.addEventListener("moving", function (T) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    return
                }
                e.moveGridTiles()
            });
            i.addEventListener("resize", function (T) {
                if (this.mapType === BMAP_EARTH_MAP) {
                    return
                }
                e.resizeMap(T)
            });
            i.addEventListener("addtilelayer", function (T) {
                e.addTileLayer(T)
            });
            i.addEventListener("removetilelayer", function (T) {
                e.removeTileLayer(T)
            })
        });
        C.extend(fa.prototype, {
            addTileLayer: function (hN) {
                var T = this;
                var i = hN.target;
                T.tileLayers.push(i);
                if (T.map.loaded) {
                    T.moveGridTiles()
                }
            },
            removeTileLayer: function (hU) {
                var hV = this;
                var hS = hU.target;
                var hQ = hS.mapType;
                var hP = hV.mapTiles;
                var hX = hV.bufferTiles;
                for (var T in hX) {
                    var hN = T.split("-")[1];
                    if (hN == hQ) {
                        delete hX[T]
                    }
                }
                for (var T in hP) {
                    var hN = T.split("-")[1];
                    if (hN == hQ) {
                        delete hP[T]
                    }
                }
                if (hV.zoomsDiv && hV.zoomsDiv.parentNode) {
                    hV.zoomsDiv.parentNode.removeChild(hV.zoomsDiv);
                    hV.zoomsDiv.innerHTML = ""
                }
                var hO = hV.map;
                if (hO.deepZoom) {
                    var hW = hO.deepZoom.preDeepZoomDiv;
                    if (hW && hW.parentNode) {
                        hW.parentNode.removeChild(hW)
                    }
                }
                for (var hT = 0, hR = hV.tileLayers.length; hT < hR; hT++) {
                    if (hS == hV.tileLayers[hT]) {
                        hV.tileLayers.splice(hT, 1)
                    }
                }
                hV.moveGridTiles()
            },
            hideDeepZoomDiv: function () {
                var i = this,
                    T = i.map;
                if (T.deepZoom) {
                    var e = T.deepZoom.preDeepZoomDiv;
                    if (e && e.style.display != "none") {
                        e.style.display = "none"
                    }
                }
            },
            getTileLayer: function (hO) {
                var hN = this;
                for (var T = 0, e = hN.tileLayers.length; T < e; T++) {
                    tilelayer = hN.tileLayers[T];
                    if (tilelayer.mapType == hO) {
                        return tilelayer
                    }
                }
                return null
            },
            _zoom: function (T) {
                var i = this;
                if (i.zoomsDiv && i.zoomsDiv.style.display != "none") {
                    i.zoomsDiv.style.display = "none"
                }
                i.hideDeepZoomDiv();
                i.moveGridTiles()
            },
            resizeMap: function (i) {
                this.loaded = false;
                this.moveGridTiles()
            },
            _checkTilesLoaded: function () {
                this.numLoading--;
                var e = this;
                if (this.numLoading == 0) {
                    if (this._checkLoadedTimer) {
                        clearTimeout(this._checkLoadedTimer);
                        this._checkLoadedTimer = null
                    }
                    this._checkLoadedTimer = setTimeout(function () {
                        if (e.numLoading == 0) {
                            e.map.dispatchEvent(new a8("ontilesloaded"))
                        }
                        e._checkLoadedTimer = null
                    }, 80)
                }
            },
            getTileName: function (e, T, i) {
                var hO = T.mapType;
                var hN = "TILE-" + hO + "-" + i + "-" + e[0] + "-" + e[1] + "-" + e[2];
                return hN
            },
            hideTile: function (hN, T) {
                var i = hN.img;
                if (g9(i)) {
                    if (hN.loaded) {
                        this.imgNumber--
                    }
                    if (i.parentNode) {
                        fn(i);
                        i.parentNode.removeChild(i)
                    }
                }
                var hO = new a8("onimagechange");
                hO.tile = this.getTileName(hN.info, T, this.map.config.style);
                hO.action = "hide";
                delete this.mapTiles[hN.name];
                if (!hN.loaded) {
                    fn(i);
                    hN._callCbks();
                    i = null;
                    hN.img = null;
                    hN.mgr = null
                }
                this.map.dispatchEvent(hO)
            },
            loadTiles: function () {
                var i = this;
                if (C.Browser.ie) {
                    try {
                        document.execCommand("BackgroundImageCache", false, true)
                    } catch (T) { }
                }
                if (this.zoomsDiv && this.zoomsDiv.style.display != "none") {
                    this.zoomsDiv.style.display = "none"
                }
                i.hideDeepZoomDiv();
                i.moveGridTiles()
            },
            getCell: function (hO, hN) {
                var e = this.baseUnits * Math.pow(2, (this.baseZoomLevel - hN));
                var T = parseInt(hO.lng / e);
                var i = parseInt(hO.lat / e);
                return [T, i, e * (T + 0.5), e * (i + 0.5)]
            },
            moveGridTiles: function () {
                var h1 = this.map,
                    ia = h1.getMapType(),
                    h8 = this.tileLayers.length;
                var h6 = h1.centerPoint;
                if (ia !== BMAP_SATELLITE_MAP) {
                    h6 = d0.calcLoopCenterPoint(h6)
                }
                var hS = h1.width;
                var ip = h1.getZoomUnits();
                var h7 = ip * hS;
                var ic = h6.lng - h7 / 2;
                var hX = h6.lng + h7 / 2;
                var h0 = d0.isAddWidth(ic, hX);
                for (var ig = 0; ig < h8; ig++) {
                    var hO = this.tileLayers[ig];
                    if (hO.baseLayer || h8 == 1) {
                        this.tilesDiv = hO.tilesDiv
                    }
                    var h2 = b3[hO.mapType];
                    var hN = h1.zoomLevel;
                    var ij = h1.getZoomUnits(h1.zoomLevel);
                    var hW = h2.baseUnits * Math.pow(2, (h2.zoomLevelBase - hN));
                    var hU = Math.floor(h6.lng / hW);
                    var ie = Math.floor(h6.lat / hW);
                    var hZ = h2.tileSize;
                    var h3 = [hU, ie, (h6.lng - hU * hW) / hW * hZ, (h6.lat - ie * hW) / hW * hZ];
                    var hV = h0 ? h1.width / 2 * 1.5 : h1.width / 2;
                    var hY = h3[0] - Math.ceil((hV - h3[2]) / hZ);
                    var io = h3[1] - Math.ceil((h1.height / 2 - h3[3]) / hZ);
                    var ih = h3[0] + Math.ceil((hV + h3[2]) / hZ);
                    var h4 = h3[1] + Math.ceil((h1.height / 2 + h3[3]) / hZ);
                    var hT = [];
                    for (var il = hY; il < ih; il++) {
                        for (var ik = io; ik < h4; ik++) {
                            hT.push([il, ik]);
                            var h9 = "id_" + il + "_" + ik + "_" + hN;
                            hT[h9] = true
                        }
                    }
                    if (hO.mapType !== BMAP_SATELLITE_MAP) {
                        hT = d0.calcLoopTiles(hT, hN)
                    }
                    hT.sort((function (i) {
                        return function (id, ir) {
                            return ((0.4 * Math.abs(id[0] - i[0]) + 0.6 * Math.abs(id[1] - i[1])) - (0.4 * Math.abs(ir[0] - i[0]) + 0.6 * Math.abs(ir[1] - i[1])))
                        }
                    })([h3[0], h3[1]]));
                    var T = this.mapTiles;
                    var e = -h6.lng / ij;
                    var iq = h6.lat / ij;
                    var ib = [e, iq];
                    for (var h5 in T) {
                        var hQ = T[h5];
                        var im = hQ.info;
                        if (!im) {
                            continue
                        }
                        var h9 = "id_" + im[0] + "_" + im[1] + "_" + im[2];
                        if (!hT[h9]) {
                            this.hideTile(hQ, hO)
                        }
                    }
                    var hP = -h1.offsetX + h1.width / 2;
                    var hR = -h1.offsetY + h1.height / 2;
                    hO.tilesDiv.style.left = Math.round(e + hP) - ib[0] + "px";
                    hO.tilesDiv.style.top = Math.round(iq + hR) - ib[1] + "px";
                    this.numLoading += hT.length;
                    for (var il = 0, ii = hT.length; il < ii; il++) {
                        this.showTile([hT[il][0], hT[il][1], h1.zoomLevel], ib, hO, il, h1.config.style)
                    }
                }
            },
            showTile: function (hQ, hP, hT, hY) {
                this.centerPos = hP;
                var hR = b3[hT.mapType];
                var hU = this.map.config.style;
                var hN = this.getTileName(hQ, hT, hU);
                var hO = (hQ[0] * hR.tileSize) + hP[0];
                var T = (-1 - hQ[1]) * hR.tileSize + hP[1];
                var hX = [hO, T];
                var hS = null;
                if (hT.mapType !== BMAP_SATELLITE_MAP) {
                    hS = d0.calcLoopParam(hQ[0], hQ[2]);
                    var hW = hS.offsetX;
                    hX[0] += hW;
                    hX._offsetX = hW
                }
                var h1 = this;
                var h0 = this.mapTiles[hN];
                if (h0) {
                    h0.img.style.left = hX[0] + "px";
                    h0.img.style.top = hX[1] + "px";
                    if (h0.loaded) {
                        this._checkTilesLoaded()
                    } else {
                        h0._addLoadCbk(function () {
                            h1._checkTilesLoaded()
                        })
                    }
                    return
                }
                h0 = this.bufferTiles[hN];
                if (h0) {
                    this.imgNumber++;
                    hT.tilesDiv.insertBefore(h0.img, hT.tilesDiv.lastChild);
                    this.mapTiles[hN] = h0;
                    h0.img.style.left = hX[0] + "px";
                    h0.img.style.top = hX[1] + "px";
                    if (h0.loaded) {
                        this._checkTilesLoaded()
                    } else {
                        h0._addLoadCbk(function () {
                            h1._checkTilesLoaded()
                        })
                    }
                    var hZ = new a8("onimagechange");
                    hZ.action = "cache";
                    hZ.tile = this.getTileName(hQ, hT, hU);
                    this.map.dispatchEvent(hZ)
                } else {
                    var hV = new eg(hQ[0], hQ[1]);
                    if (hS) {
                        hV.x = hS.col
                    }
                    var i = hT.getTilesUrl(hV, hQ[2]);
                    h0 = new bQ(this, i, hX, hQ, hT);
                    h0._addLoadCbk(function () {
                        h1._checkTilesLoaded()
                    });
                    h0._load();
                    this.mapTiles[hN] = h0;
                    bv(this.map)
                }
            },
            mouseWheel: function (hR) {
                var hQ = this.map;
                if (!hQ.config.enableWheelZoom) {
                    return
                }
                var hS = hQ.zoomLevel + (hR.trend === true ? 1 : -1);
                var hO = hQ._getProperZoom(hS);
                if (hO.exceeded) {
                    var T = new a8("onzoomexceeded");
                    T.targetZoom = hS;
                    hQ.dispatchEvent(T);
                    return
                }
                hQ.dispatchEvent(new a8("onzoomstart"));
                hQ.lastLevel = hQ.zoomLevel;
                hQ.zoomLevel = hO.zoom;
                var i = hR.pixel;
                var hN = hQ.pixelToPointIn(i, {
                    zoom: hQ.lastLevel
                });
                var hP = hQ.getZoomUnits(hQ.zoomLevel);
                hQ.centerPoint = new ho(hN.lng + hP * (hQ.width / 2 - i.x), hN.lat - hP * (hQ.height / 2 - i.y));
                this.zoom(i)
            },
            dblClick: function (T) {
                var i = this.map;
                if (!i.config.enableDblclickZoom) {
                    return
                }
                if (i.mapType === "B_EARTH_MAP") {
                    return
                }
                if (i.currentOperation === dR.dragging) {
                    return
                }
                if (T.type == "onrightdblclick") {
                    i.zoomOut(T.point)
                } else {
                    i.zoomIn(T.point)
                }
            },
            keypress: function (T) {
                var i = this.map;
                if (i.getMapType() === BMAP_EARTH_MAP) {
                    return
                }
                T.type == "onpluspress" ? i.zoomIn() : i.zoomOut()
            }
        });

        function cO(hN) {
            this.opts = hN || {};
            this.copyright = this.opts.copyright || {};
            this.transparentPng = this.opts.transparentPng || false;
            this.png8 = this.opts.png8 || false;
            this.baseLayer = this.opts.baseLayer || false;
            this.dataType = this.opts.dataType || 1;
            this.isFlat = this.opts.isFlat === false ? false : true;
            this.showLabel = this.opts.showLabel === false ? false : true;
            var e = this.opts.tileTypeName || "web";
            this.tileType = cI.getInstance(e);
            this.clipTile = this.opts.clipTile || false;
            this._type = "tilelayer";
            var i = f1() ? 128 : 256;
            this.cacheSize = this.opts.cacheSize || i;
            var T = this;
            this.tileCache = new eW(this.cacheSize, {
                clearCallback: function (hO) {
                    if (hO.label) {
                        if (hO.label.textImageBitmap) {
                            hO.label.textImageBitmap.close()
                        }
                        if (hO.label.indoorTextImageBitmap) {
                            hO.label.indoorTextImageBitmap.close()
                        }
                    }
                    T._removeIndoorData(hO)
                }
            });
            this.scaler = a3() >= 1.5 ? 2 : 1;
            this.normalUdt = aB("ditu", "normal").udt;
            this.numLoading = 0;
            this.useThumbData = false;
            if (this.baseLayer) {
                this.useThumbData = true
            }
            if (typeof this.opts.customLayer === "boolean") {
                this.customLayer = this.opts.customLayer
            } else {
                this.customLayer = true
            }
        }
        cO.inherits(ea, "TileLayer");
        C.extend(cO.prototype, {
            isTransparentPng: function () {
                return this.transparentPng
            },
            getTilesUrl: function (hU, e) {
                var T = b3[this.mapType];
                if (typeof T != "object") {
                    return null
                }
                var hN = hU.x;
                var hV = hU.y;
                if (this.mapType !== BMAP_SATELLITE_MAP) {
                    var hV = d0.calcLoopParam(hV, e).col
                }
                var i = "";
                if (this.opts.tileUrlTemplate) {
                    i = this.opts.tileUrlTemplate;
                    i = i.replace(/\{X\}/, hV);
                    i = i.replace(/\{Y\}/, hN);
                    i = i.replace(/\{Z\}/, e)
                } else {
                    if (this.mapType == BMAPGL_NORMAL_MAP) {
                        var hT = this.isCanvasMap ? 0 : 1;
                        var hP = T.tileUrls[Math.abs(hV + hN) % T.tileUrls.length];
                        if (window.offLineIPAddress) {
                            hP = window.offLineIPAddress + "tile5/"
                        }
                        var hO = this.map.config.style;
                        i = hP + "?qt=vtile&x=" + hN + "&y=" + hV + "&z=" + e + (hO === "default" ? "" : ("&styleId=" + e0.mapStyleNameIdPair[hO])) + "&styles=pl&udt=" + this.normalUdt + "&scaler=" + this.scaler + "&showtext=" + hT;
                        i = i.replace(/-(\d+)/gi, "M$1")
                    }
                    if (this.mapType == BMAP_SATELLITE_MAP) {
                        var hQ = aB("ditu", "satellite");
                        var hS = hQ.ver;
                        var hR = hQ.udt;
                        i = T.tileUrls[Math.abs(hV + hN) % T.tileUrls.length] + "u=x=" + hN + ";y=" + hV + ";z=" + e + ";v=" + hS + ";type=sate&fm=46&udt=" + hR;
                        i = i.replace(/-(\d+)/gi, "M$1")
                    }
                }
                return i
            },
            initialize: function (hO) {
                this.map = hO;
                if (hO._renderType === "webgl") {
                    var hN = null;
                    if (this.customLayer !== false) {
                        hN = this.getTilesUrl
                    }
                    C.extend(this, fP);
                    this.labelProcessor = new dg(this);
                    this.callbackDataQueue = [];
                    if (hN) {
                        this.getTilesUrl = hN
                    }
                    var e = this;
                    hO.on("indoor_data_refresh", function (hP) {
                        if (!e.baseLayer) {
                            return
                        }
                        e._refreshIndoorData(hP.uid, hP.floor)
                    });
                    hO.on("custom_labels_ready", function (hP) {
                        if (!e.baseLayer) {
                            return
                        }
                        e._doWorkAfterLabelImageLoad(hP.virtualTile, hP.labelCanvas, null, hP.imgKey)
                    });
                    hO.on("glmoduleloaded", function () {
                        if (!e.baseLayer) {
                            return
                        }
                        e.updateAllIconsTextureCoords()
                    })
                }
                if (!hO.temp.layerZIndex) {
                    hO.temp.layerZIndex = 0
                }
                this.zIndex = this.zIndex || 0;
                if (this.baseLayer) {
                    this.zIndex = 0
                }
                if (!hO.temp.layid) {
                    hO.temp.layid = 0
                }
                if (!this.opts.mapType) {
                    this.mapType = "BMAP_CUSTOM_LAYER_" + hO.temp.layid;
                    hO.temp.layid++
                } else {
                    this.mapType = this.opts.mapType
                }
                var i = b3[this.mapType];
                if (!i) {
                    b3[this.mapType] = {
                        tileUrls: [],
                        tileSize: 256,
                        baseUnits: 256,
                        zoomLevelMin: 1,
                        zoomLevelMax: 19,
                        minZoom: 3,
                        maxZoom: 19,
                        minDataZoom: 3,
                        maxDataZoom: 19,
                        zoomLevelBase: 18,
                        errorUrl: e0.imgPath + "/blank.gif",
                        bounds: new dP(new ho(-21364736, -10616832), new ho(23855104, 15859712)),
                        imgExtend: "png"
                    }
                }
                if (hO._renderType !== "webgl") {
                    var T = dF(hO.platform, '<div style="position:absolute;z-index:' + this.zIndex + '"></div>');
                    T.style.display = "";
                    T.style.left = Math.ceil(-hO.offsetX + hO.width / 2) + "px";
                    T.style.top = Math.ceil(-hO.offsetY + hO.height / 2) + "px";
                    this.tilesDiv = T
                }
                this.isCanvasMap = hO.isCanvasMap();
                this.lastZoom = hO.getZoom()
            },
            remove: function () {
                if (this.tilesDiv && this.tilesDiv.parentNode) {
                    this.tilesDiv.innerHTML = "";
                    this.tilesDiv.parentNode.removeChild(this.tilesDiv)
                }
                delete this.tilesDiv
            },
            getCopyright: function () {
                return this.copyright
            },
            getMapType: function () {
                return this.mapType
            },
            setZIndex: function (e) {
                this.zIndex = e;
                if (this.tilesDiv) {
                    this.tilesDiv.style.zIndex = e
                }
            }
        });

        function c1(i, e, T) {
            this.bounds = i;
            this.content = e;
            this.mapType = T
        }
        c1.inherits(ea, "Copyright");
        var gk = {
            get: function (e) {
                if (!gk.singleton) {
                    gk.singleton = new ai(e)
                }
                return gk.singleton
            }
        };

        function ai(i) {
            this._map = i;
            this._tileMgr = i.tileMgr;
            this._animationDiv = null;
            this._preAnimationDiv = null;
            this._animation = null;
            this._baseLayerDiv = null;
            this._transformStyleName = a5.ifSupportCSS3("transform", true);
            this._transformOriginStyleName = a5.ifSupportCSS3("transformOrigin", true);
            this._preZoomTimes = 1;
            this._preRenderTick = 1;
            this._enableCanvas2dMap = !!(i.getRenderType() === "canvas");
            this._isIE9 = !!(C.Browser.ie === 9);
            var e = this;
            i.addEventListener("maptypechange", function () {
                e.hide()
            });
            i.addEventListener("load", function () {
                e.hide()
            })
        }
        C.extend(ai.prototype, {
            prepareLayer: function () {
                var hN = this._map;
                var e = this._tileMgr;
                this._canvas2dMapMgr = hN.canvas2dMapMgr;
                var T = this._baseLayerDiv = e.tilesDiv;
                if (!this._animationDiv) {
                    var i = this._preAnimationDiv;
                    if (i) {
                        i.parentNode && i.parentNode.removeChild(i);
                        this._preAnimationDiv = null
                    }
                    this._preAnimationDiv = this._animationDiv = T.cloneNode(true);
                    hN.platform.insertBefore(this._animationDiv, hN.platform.firstChild)
                }
                this.show()
            },
            prepareAniParam: function () {
                var hN = this._animationDiv;
                if (!hN) {
                    return
                }
                var e = hN.children.length;
                var T;
                this._zoomAniInfo = [];
                for (var hO = e - 1; hO > -1; hO--) {
                    var hP = {};
                    T = hN.children[hO].style;
                    hP.top = parseInt(T.top, 10);
                    hP.left = parseInt(T.left, 10);
                    this._zoomAniInfo[hO] = hP
                }
            },
            prepareLabelLayer: function () {
                var hO = this._map;
                if (this._enableCanvas2dMap && hO.canvas2dMapMgr) {
                    if (this.touchZoomLabelCanvas) {
                        this.touchZoomLabelCanvas.parentNode.removeChild(this.touchZoomLabelCanvas)
                    }
                    var i = hO.canvas2dMapMgr._labelCanvas;
                    this.touchZoomLabelCanvas = i.cloneNode(false);
                    var e = this.touchZoomLabelCanvas.getContext("2d");
                    e.drawImage(i, 0, 0);
                    hO.platform.insertBefore(this.touchZoomLabelCanvas, hO.platform.firstChild);
                    var hN = parseInt(i.style.left, 10);
                    var T = parseInt(i.style.top, 10);
                    this.touchZoomLabelCanvas.style.zIndex = 9;
                    this.touchZoomLabelCanvas.style[this._transformOriginStyleName] = (this._fixPosition.x - (hO.offsetX + hN)) + "px " + (this._fixPosition.y - (hO.offsetY + T)) + "px";
                    i.style.visibility = "hidden"
                }
            },
            show: function () {
                if (this._animationDiv) {
                    this._animationDiv.style.visibility = ""
                }
            },
            showLabel: function () {
                var i = this._map;
                if (this._enableCanvas2dMap && i.canvas2dMapMgr) {
                    var e = i.canvas2dMapMgr._labelCanvas;
                    if (e) {
                        e.style.visibility = ""
                    }
                    if (this.touchZoomLabelCanvas) {
                        this.touchZoomLabelCanvas.style.zIndex = -2;
                        this.touchZoomLabelCanvas.style.visibility = "hidden"
                    }
                }
            },
            hide: function () {
                if (this._animationDiv) {
                    this._animationDiv.style.visibility = "hidden"
                }
                if (this._preAnimationDiv) {
                    this._preAnimationDiv.style.visibility = "hidden"
                }
            },
            hideNonAnimationLayers: function () {
                var hN = this._map;
                if (hN.getRenderType() === "dom") {
                    if (hN.overlayDiv) {
                        hN.overlayDiv.style.visibility = "hidden"
                    }
                    if (hN.overlayDivEx) {
                        hN.overlayDivEx.style.visibility = "hidden"
                    }
                }
                var hP = hN.tileMgr.tileLayers;
                var hO;
                for (var T = 0, e = hP.length; T < e; T++) {
                    hO = hP[T];
                    hO.tilesDiv.style.visibility = "hidden"
                }
            },
            showNonAnimationLayers: function () {
                var hN = this._map;
                if (hN.getRenderType() === "dom") {
                    if (hN.overlayDiv) {
                        hN.overlayDiv.style.visibility = ""
                    }
                    if (hN.overlayDivEx) {
                        hN.overlayDivEx.style.visibility = ""
                    }
                }
                var hP = hN.tileMgr.tileLayers;
                var hO;
                for (var T = 0, e = hP.length; T < e; T++) {
                    hO = hP[T];
                    hO.tilesDiv.style.visibility = ""
                }
            },
            setFixPosition: function (e) {
                this._fixPosition = e
            },
            setZoom: function (e, hT) {
                var hQ = this._fixPosition;
                var hZ = this._map;
                var h0 = this._baseLayerDiv;
                var hR = {
                    x: hQ.x - parseInt(h0.style.left, 10) - hZ.offsetX,
                    y: hQ.y - parseInt(h0.style.top, 10) - hZ.offsetY
                };
                var hN = this._animationDiv;
                if (!hN) {
                    return
                }
                var hX = hN.children.length;
                var hV;
                var hY = this._transformStyleName;
                var hP = this._transformOriginStyleName;
                var h1 = this;
                var h3;
                var hS;
                for (var hW = hX - 1; hW > -1; hW--) {
                    var hU = this._zoomAniInfo[hW];
                    hV = hN.children[hW].style;
                    var hO = hU.left - hR.x;
                    var T = hU.top - hR.y;
                    hU.dx = hO * e - hO;
                    hU.dy = T * e - T;
                    hU.preDx = hO - hO;
                    hU.preDy = T - T;
                    h3 = hU.preDx + (hU.dx - hU.preDx);
                    hS = hU.preDy + (hU.dy - hU.preDy) + hT;
                    hV.left = hU.left + h3 + "px";
                    hV.top = hU.top + hS + "px";
                    hV.width = hV.height = 256 * e + "px"
                }
                if (this._enableCanvas2dMap) {
                    var h2 = !h1._isIE9 ? "translate3d(0px, " + hT + "px, 0) scale(" + e + ")" : "translate(0px, " + hT + "px) scale(" + e + ")";
                    this.touchZoomLabelCanvas.style[hY] = h2
                }
            },
            setZoomFinish: function () {
                this._animationDiv = null
            },
            startAnimation: function (hQ) {
                this.prepareLayer();
                this.hideNonAnimationLayers();
                var h9 = this._map;
                if (this.touchZoomLabelCanvas) {
                    this.touchZoomLabelCanvas.style.display = "none"
                }
                hQ = hQ || {};
                var h7 = hQ.zoomCount || 0;
                var hV = hQ.fixPosition;
                var h5 = hQ.fixMCPosition;
                var hT = hQ.pixOffset;
                this._zoomCount = h7;
                var hN = h9.getZoom();
                var h8 = hN + h7;
                var e = h9.config.enableContinuousZoom;
                var hZ = 0.5;
                var hU = 5;
                var T = Math.pow(2, h7);
                var ib = this._baseLayerDiv;
                var hW = {
                    x: hV.x - parseInt(ib.style.left, 10) - h9.offsetX,
                    y: hV.y - parseInt(ib.style.top, 10) - h9.offsetY
                };
                var hR = this._animationDiv;
                var h3 = hR.children.length;
                var id = this._preZoomTimes;
                var h6 = [];
                var h4 = this._transformStyleName;
                var hS = this._transformOriginStyleName;
                for (var h2 = h3 - 1; h2 > -1; h2--) {
                    var h0 = {};
                    var h1 = hR.children[h2].style;
                    h0.top = parseInt(h1.top, 10);
                    h0.left = parseInt(h1.left, 10);
                    var hP = h0.left - hW.x;
                    var hO = h0.top - hW.y;
                    h0.dx = hP * T - hP;
                    h0.dy = hO * T - hO;
                    h0.preDx = hP * id - hP;
                    h0.preDy = hO * id - hO;
                    h6[h2] = h0
                }
                var ia = this;
                var hY;
                var ic;
                var hX;
                this._zoomAni = new o({
                    fps: 60,
                    duration: e ? 500 : 1,
                    transition: function (i) {
                        i = i * hU / (2 * hZ);
                        return hU * i - hZ * i * i
                    },
                    render: function (io) {
                        io = io * (4 * hZ) / (hU * hU);
                        hY = id + io * (T - id);
                        var ig = hN + ez(hY);
                        var il = null;
                        var ik = 0;
                        var ip = 0;
                        if (hQ.onAnimationBeforeLooping) {
                            var iq = hQ.onAnimationBeforeLooping(io, ig);
                            il = iq.loopingCenter;
                            ik = iq.yDiff;
                            ip = iq.totalYDiff
                        }
                        for (var ih = h6.length - 1; ih > -1; ih--) {
                            var ii = h6[ih];
                            if (hR.children[ih]) {
                                var im = hR.children[ih].style;
                                ic = ii.preDx + (ii.dx - ii.preDx) * io - hT.width * io;
                                hX = ii.preDy + (ii.dy - ii.preDy) * io - hT.height * io + ik;
                                im.left = ii.left + ic + "px";
                                im.top = ii.top + hX + "px";
                                im.height = im.width = 256 * hY + "px"
                            }
                        }
                        var ie = hT.width * io;
                        var ij = hT.height * io;
                        if (h9.isRestrict) {
                            ia._enableCanvas2dMap && ia._canvas2dMapMgr.clearLabel()
                        } else {
                            ia._enableCanvas2dMap && ia._canvas2dMapMgr.drawLabel(hY, hV, hN, h8, h7, io, ie, ij, ip, ik)
                        }
                        ia._preZoomTimes = hY;
                        ia._preRenderTick = io;
                        hQ.onAnimationLooping && hQ.onAnimationLooping(io, ig, il)
                    },
                    finish: function () {
                        ia._preZoomTimes = 1;
                        ia._zoomAni = null;
                        ia._animationDiv = null;
                        hQ.onAnimationFinish && hQ.onAnimationFinish();
                        ia.showNonAnimationLayers()
                    }
                });
                return this._zoomAni
            },
            stopAnimation: function () {
                if (this._zoomAni) {
                    this._zoomAni.stop();
                    this._zoomAni = null
                }
            }
        });

        function c(e) {
            this._initVars(e);
            this._initColorCanvas();
            this._bindEvent(e)
        }
        C.extend(c.prototype, {
            _initVars: function (e) {
                this._map = e._map;
                this._canvas2dMapMgr = e;
                this._labelCtx = e._labelCtx;
                this.ratio = this._map.config.ratio;
                this.sizeRatio = this.ratio > 1 ? 2 : 1;
                this.RANK1 = 1000000;
                this.RANK2 = 2000000;
                this.RANK3 = 3000000;
                this.RANK4 = 4000000;
                this.RANK5 = 5000000
            },
            _initColorCanvas: function () {
                var i = 256,
                    T = S("canvas"),
                    e = T.style;
                e.width = i + "px";
                e.height = i + "px";
                T.width = i;
                T.height = i;
                this._colorCvsSize = i;
                this._colorCvs = T;
                this._colorCtx = T.getContext("2d")
            },
            getLabelImageData: function (h0) {
                var hZ = h0.textImg;
                var T = h0.textPos;
                var hX = this.ratio;
                var hV = this.sizeRatio / hX;
                var hO = this._colorCtx;
                var hS = this._colorCvsSize;
                hO.clearRect(0, 0, hS, hS);
                var hU = 0;
                var e = 0;
                var hR = 0;
                for (var hT = 0; hT < T.length; hT++) {
                    if (T[hT].width > hU) {
                        hU = T[hT].width;
                        e = hT;
                        hR = T[hT].drawX
                    }
                }
                hU /= hV;
                var hW = 0;
                for (var hT = 0, hQ = T.length; hT < hQ; hT++) {
                    var hY = T[hT];
                    var h1;
                    if (hT === e) {
                        h1 = 0
                    } else {
                        h1 = hY.drawX - hR
                    }
                    hO.drawImage(hZ, hY.srcX, hY.srcY, hY.width, hY.height, h1, hW, hY.width / hV, hY.height / hV);
                    if (hY.width / hV > hU) {
                        hU = hY.width / hV
                    }
                    hW += hY.height / hV + 2 * hX
                }
                var hN = hO.getImageData(0, 0, hU, hW);
                var hP = hO.getImageData(0, 0, hU, hW);
                return [hN, hP]
            },
            _bindEvent: function (i) {
                var e = this,
                    T = i._map;
                T.addEventListener("onspotmouseover", function (hQ) {
                    if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) {
                        return
                    }
                    if (hQ.spots.length > 0) {
                        var hP = hQ.spots[0].userdata.uid;
                        var hO = hQ.spots[0].userdata.name;
                        var hN = e.findLabelByUid(hP, hO);
                        hN && e._toHighLightColor(hN)
                    }
                });
                T.addEventListener("onspotmouseout", function (hQ) {
                    if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) {
                        return
                    }
                    if (hQ.spots.length > 0) {
                        var hP = hQ.spots[0].userdata.uid;
                        var hO = hQ.spots[0].userdata.name;
                        var hN = e.findLabelByUid(hP, hO);
                        hN && e._toDefaultColor(hN)
                    }
                });
                T.addEventListener("onspotclick", function (hQ) {
                    if (!this.isCanvasMap() || !this.temp.isPermitSpotOver) {
                        return
                    }
                    if (hQ.spots && hQ.spots.length > 0) {
                        var hP = hQ.spots[0].userdata.uid;
                        var hO = hQ.spots[0].userdata.name;
                        var hN = e.findLabelByUid(hP, hO);
                        hN && e._changeBaseMapState(hN)
                    } else {
                        e._recoverNormalState()
                    }
                });
                T.on("spot_status_reset", function () {
                    e._recoverNormalState()
                });
                T.on("spot_highlight", function (hO) {
                    var hN = e.findLabelByUid(hO.uid);
                    hN && e._changeBaseMapState(hN)
                })
            },
            _getTextBound: function (hY) {
                if (!hY.textPos) {
                    return null
                }
                var hW = this.ratio;
                var hU = this.sizeRatio / hW;
                var T = hY.textPos;
                var hX = hY.baseDrawX;
                var hV = hY.baseDrawY;
                var hS = hX * hW + (T[0].drawX - hX) / hU;
                var hQ = hV * hW + (T[0].drawY - hV) / hU;
                var hO = hS + T[0].width / hU;
                var e = hQ + T[0].height / hU;
                for (var hT = 0, hR = T.length; hT < hR; hT++) {
                    var hZ = T[hT];
                    var hP = hX * hW + (hZ.drawX - hX) / hU;
                    if (hP < hS) {
                        hS = hP
                    }
                    var hN = hV * hW + (hZ.drawY - hV) / hU;
                    if (hN < hQ) {
                        hQ = hN
                    }
                    if (hP + hZ.width > hO) {
                        hO = hP + hZ.width
                    }
                    if (hN + hZ.height > e) {
                        e = hN + hZ.height
                    }
                }
                return [hS, hQ, hO, e]
            },
            _toHighLightColor: function (T) {
                if (T._tempRank && T._tempRank == this.RANK5) {
                    return
                }
                var hR = this._getTextBound(T);
                if (!hR) {
                    return
                }
                var hN = Math.round(hR[0]);
                var i = Math.round(hR[1]);
                var e = this.getLabelImageData(T);
                var hP = e[0];
                var hO = e[1];
                var hQ = this._canvas2dMapMgr.getFilterImageData(hP, this.RANK5);
                T._oldImgData = hO;
                this._labelCtx.putImageData(hQ, hN, i)
            },
            _toDefaultColor: function (e) {
                if (e._tempRank && e._tempRank == this.RANK5) {
                    return
                }
                if (e._oldImgData) {
                    var i = this.sizeRatio;
                    var T = this._getTextBound(e);
                    if (!T) {
                        return
                    }
                    this._labelCtx.putImageData(e._oldImgData, Math.round(T[0]), Math.round(T[1]));
                    e._oldImgData = null
                }
            },
            _changeBaseMapState: function (hN) {
                var T = this._canvas2dMapMgr;
                var i = hN.guid;
                var e = hN.guidExt;
                var hO = {
                    guid: i,
                    name: hN.name,
                    guidExt: e
                };
                T._labelStrategy.setStrategyInfo(hO);
                T._loadData()
            },
            _recoverNormalState: function () {
                var e = this._canvas2dMapMgr;
                e._labelStrategy.setStrategyInfo(null);
                e._loadData()
            },
            findLabelByUid: function (hP, hN) {
                var hR = this._canvas2dMapMgr,
                    e = hR._computedLabel;
                for (var hO = 0, T = e.length; hO < T; hO++) {
                    var hQ = e[hO];
                    if (!hR.isClickableLabel(hQ)) {
                        continue
                    }
                    if (hP && hQ.guid === hP) {
                        return hQ
                    }
                    if (hN && hQ.name === hN) {
                        return hQ
                    }
                }
                return null
            }
        });

        function d9(e) {
            this._initVars(e)
        }
        C.extend(d9.prototype, {
            _initVars: function (e) {
                this._map = e._map;
                this._canvas2dMapMgr = e;
                this.ratio = this._map.config.ratio;
                this._strategyInfo = null;
                this.RANK1 = 1000000;
                this.RANK2 = 2000000;
                this.RANK3 = 3000000;
                this.RANK4 = 4000000;
                this.RANK5 = 5000000
            },
            setStrategyInfo: function (e) {
                this._strategyInfo = e
            },
            preComputeLabel: function (hT, iN, iw, h5, iH, i1) {
                var ip = [],
                    h1 = hT._centerX,
                    hZ = hT._centerY,
                    i2 = h5 * iH;
                var iC = this.ratio;
                var hS = this._map.getZoom();
                var ij = 0;
                if (hS === 5) {
                    ij = 4
                }
                if (hS === 8) {
                    ij = -6
                }
                hT.sort(function (i3, i) {
                    if (i3.x * i3.y < i.x * i.y) {
                        return -1
                    } else {
                        return 1
                    }
                });
                for (var il = 0, ih = hT.length; il < ih; il++) {
                    var iS = hT[il],
                        ib = iS.x,
                        h8 = iS.y,
                        h6 = iS.z;
                    var id = d0.calcLoopParam(ib, h6).offsetX;
                    var iA = ib * i2,
                        iz = (h8 + 1) * i2,
                        hN = (iA - h1) / h5 + iN / 2 + id,
                        T = (hZ - iz) / h5 + iw / 2;
                    for (var ii = 0, iW = iS.length; ii < iW; ii++) {
                        var hV = iS[ii],
                            h2 = undefined,
                            h0 = undefined,
                            iU = undefined,
                            iT = undefined;
                        var iJ = hV.baseDrawX = hN + hV.baseX;
                        var iI = hV.baseDrawY = T + hV.baseY;
                        if (hV.type == "fixed") {
                            var iu = hV.iconPos,
                                h4 = hV.textPos,
                                iY = hV.textImg;
                            if (iu) {
                                iu.drawX = hN + iu.destX;
                                iu.drawY = T + iu.destY;
                                h2 = iu.drawX;
                                h0 = iu.drawY;
                                iU = iu.drawX + iu.width;
                                iT = iu.drawY + iu.height
                            }
                            if (h4 && iY) {
                                for (var iK = 0; iK < h4.length; iK++) {
                                    var iX = h4[iK];
                                    iX.drawX = hN + iX.destX;
                                    iX.drawY = T + iX.destY;
                                    if (!h2) {
                                        h2 = iX.drawX;
                                        h0 = iX.drawY;
                                        iU = iX.drawX + iX.width;
                                        iT = iX.drawY + iX.height
                                    } else {
                                        if (iX.drawX < h2) {
                                            h2 = iX.drawX
                                        }
                                        if (iX.drawY < h0) {
                                            h0 = iX.drawY
                                        }
                                        if (iX.drawX + iX.width > iU) {
                                            iU = iX.drawX + iX.width
                                        }
                                        if (iX.drawY + iX.height > iT) {
                                            iT = iX.drawY + iX.height
                                        }
                                    }
                                }
                            }
                        } else {
                            hV.tileX = hN;
                            hV.tileY = T;
                            h2 = hN + hV.minXOriginal;
                            h0 = T + hV.minYOriginal;
                            iU = hN + hV.maxXOriginal;
                            iT = T + hV.maxYOriginal
                        } if (h2 != undefined) {
                            var iM = iJ + (h2 - iJ) / iC;
                            var iL = iI + (h0 - iI) / iC;
                            var im = iJ + (iU - iJ) / iC;
                            var ik = iI + (iT - iI) / iC;
                            hV.minX = iM;
                            hV.minY = iL;
                            hV.maxX = im;
                            hV.maxY = ik;
                            var iQ = (iM + im) / 2,
                                iP = (iL + ik) / 2,
                                ix = h1 + (iQ - iN / 2) * h5,
                                iv = hZ + (iw / 2 - iP) * h5;
                            hV.geoX = ix;
                            hV.geoY = iv;
                            ip.push(hV)
                        }
                    }
                }
                if (i1) {
                    for (var il = 0, ih = i1.length; il < ih; il++) {
                        var ig = i1[il];
                        var iF = ig[0];
                        var hW = ig[1];
                        var iu = iF.iconPos;
                        var hQ = iu.geoX;
                        var hO = iu.geoY;
                        var iJ = (hQ - h1) / h5 + iN / 2;
                        var iI = (hZ - hO) / h5 + iw / 2;
                        var h2 = iJ + iu.destX;
                        var h0 = iI + iu.destY;
                        var iU = h2 + iu.width;
                        var iT = h0 + iu.height;
                        iF.textPos = iF.textPos || iF._textPos;
                        var h4 = iF.textPos;
                        var iO = h4[0];
                        var ia = iJ + iO.destX;
                        var hY = iI + iO.destY;
                        if (hY < h0) {
                            h0 = hY
                        }
                        if (ia + iO.width > iU) {
                            iU = ia + iO.width
                        }
                        if (hY + iO.height > iT) {
                            iT = hY + iO.height
                        }
                        if (h4.length === 2) {
                            var h9 = h4[1];
                            var h7 = iJ + h9.destX;
                            var hX = iI + h9.destY;
                            if (hX < h0) {
                                h0 = hX
                            }
                            if (h7 + h9.width > iU) {
                                iU = h7 + h9.width
                            }
                            if (hX + h9.height > iT) {
                                iT = hX + h9.height
                            }
                        }
                        iF._tempBounds = [h2, h0, iU, iT];
                        var iu = hW.iconPos;
                        var hQ = iu.geoX;
                        var hO = iu.geoY;
                        var iJ = (hQ - h1) / h5 + iN / 2;
                        var iI = (hZ - hO) / h5 + iw / 2;
                        var h2 = iJ + iu.destX;
                        var h0 = iI + iu.destY;
                        var iU = h2 + iu.width;
                        var iT = h0 + iu.height;
                        hW.textPos = hW.textPos || hW._textPos;
                        var h4 = hW.textPos;
                        var iO = h4[0];
                        var ia = iJ + iO.destX;
                        var hY = iI + iO.destY;
                        if (ia < h2) {
                            h2 = ia
                        }
                        if (hY < h0) {
                            h0 = hY
                        }
                        if (hY + iO.height > iT) {
                            iT = hY + iO.height
                        }
                        if (h4.length === 2) {
                            var h9 = h4[1];
                            var h7 = iJ + h9.destX;
                            var hX = iI + h9.destY;
                            if (h7 < h2) {
                                h2 = h7
                            }
                            if (hX < h0) {
                                h0 = hX
                            }
                            if (hX + h9.height > iT) {
                                iT = hX + h9.height
                            }
                        }
                        hW._tempBounds = [h2, h0, iU, iT]
                    }
                    for (var il = 0, ih = i1.length; il < ih; il++) {
                        var ig = i1[il];
                        var iF = ig[0];
                        var hW = ig[1];
                        if (il === 0 && hW.textPos) {
                            hW._textPos = hW.textPos;
                            delete hW.textPos
                        }
                        var iR = iF;
                        if (!iF.textPos && hW.textPos) {
                            iR = hW
                        }
                        var iV = iR._tempBounds;
                        for (ii = il + 1; ii < ih; ii++) {
                            var ie = i1[ii];
                            var iq = ie[0];
                            var i0 = ie[1];
                            var h3 = 0;
                            var iZ = iq._tempBounds;
                            if (!(iV[2] < iZ[0] || iV[0] > iZ[2] || iV[3] < iZ[1] || iV[1] > iZ[3])) {
                                h3++;
                                if (iq.textPos) {
                                    iq._textPos = iq.textPos;
                                    delete iq.textPos
                                }
                            }
                            var iZ = i0._tempBounds;
                            if (!(iV[2] < iZ[0] || iV[0] > iZ[2] || iV[3] < iZ[1] || iV[1] > iZ[3])) {
                                h3++;
                                if (i0.textPos) {
                                    i0._textPos = i0.textPos;
                                    delete i0.textPos
                                }
                            }
                            if (h3 >= 2) {
                                if (iR.textPos) {
                                    iR._textPos = iR.textPos;
                                    delete iR.textPos
                                }
                            }
                        }
                    }
                    for (var il = 0, ih = i1.length; il < ih; il++) {
                        var ig = i1[il];
                        var iF = ig[0];
                        var hW = ig[1];
                        var ir = iF;
                        if (!iF.textPos && hW.textPos) {
                            ir = hW
                        }
                        var iu = ir.iconPos;
                        var hQ = iu.geoX;
                        var hO = iu.geoY;
                        var iJ = ir.baseDrawX = (hQ - h1) / h5 + iN / 2;
                        var iI = ir.baseDrawY = (hZ - hO) / h5 + iw / 2;
                        iu.drawX = iJ + iu.destX;
                        iu.drawY = iI + iu.destY;
                        var h2 = iu.drawX;
                        var h0 = iu.drawY;
                        var iU = iu.drawX + iu.width;
                        var iT = iu.drawY + iu.height;
                        var h4 = ir.textPos;
                        if (h4) {
                            var iO = h4[0];
                            iO.drawX = iJ + iO.destX;
                            iO.drawY = iI + iO.destY;
                            if (iO.drawX < h2) {
                                h2 = iO.drawX
                            }
                            if (iO.drawY < h0) {
                                h0 = iO.drawY
                            }
                            if (iO.drawX + iO.width > iU) {
                                iU = iO.drawX + iO.width
                            }
                            if (iO.drawY + iO.height > iT) {
                                iT = iO.drawY + iO.height
                            }
                            if (h4.length === 2) {
                                var h9 = h4[1];
                                h9.drawX = iJ + h9.destX;
                                h9.drawY = iI + h9.destY;
                                if (h9.drawX < h2) {
                                    h2 = h9.drawX
                                }
                                if (h9.drawY < h0) {
                                    h0 = h9.drawY
                                }
                                if (h9.drawX + h9.width > iU) {
                                    iU = h9.drawX + h9.width
                                }
                                if (h9.drawY + h9.height > iT) {
                                    iT = h9.drawY + h9.height
                                }
                            }
                        }
                        var iM = iJ + (h2 - iJ) / iC;
                        var iL = iI + (h0 - iI) / iC;
                        var im = iJ + (iU - iJ) / iC;
                        var ik = iI + (iT - iI) / iC;
                        ir.minX = iM;
                        ir.minY = iL;
                        ir.maxX = im;
                        ir.maxY = ik;
                        var iE = (iM + im) / 2;
                        var iD = (iL + ik) / 2;
                        var hR = h1 + (iE - iN / 2) * h5;
                        var hP = hZ + (iw / 2 - iD) * h5;
                        ir.geoX = hR;
                        ir.geoY = hP;
                        ip.push(ir)
                    }
                }
                var iG = this._strategyInfo;
                if (iG) {
                    var io = iG.guid;
                    var iy = iG.name;
                    var ic = iG.guidExt;
                    for (var il = 0, ih = ip.length; il < ih; il++) {
                        var hU = ip[il];
                        delete hU._tempRank;
                        if (!this._canvas2dMapMgr.isClickableLabel(hU) || (ic === 1 && !hU.guidExt)) {
                            continue
                        }
                        if ((io && io === hU.guid) || (iy && iy === hU.name)) {
                            hU._tempRank = this.RANK5
                        }
                    }
                } else {
                    for (var il = 0, ih = ip.length; il < ih; il++) {
                        var hU = ip[il];
                        if (hU.type == "line" || !hU.iconPos) {
                            continue
                        }
                        delete hU._tempRank
                    }
                }
                ip.sort(function (i4, i3) {
                    var i5 = i4._tempRank ? i4._tempRank : i4.rank,
                        i = i3._tempRank ? i3._tempRank : i3.rank;
                    if (i5 === i) {
                        return i4.baseX - i3.baseX
                    }
                    return i - i5
                });
                for (var il = 0, ih = ip.length; il < ih; il++) {
                    var iR = ip[il];
                    iR.isDel = false;
                    iR.isFadeout = false;
                    iR._schedule = 0;
                    iR._isIgnore = false;
                    iR.arrIntersectIndex = [];
                    for (ii = il + 1; ii < ih; ii++) {
                        var it = ip[ii];
                        if (!(iR.maxX - ij < it.minX || iR.minX > it.maxX - ij || iR.maxY - ij < it.minY || iR.minY > it.maxY - ij)) {
                            iR.arrIntersectIndex.push(ii)
                        }
                    }
                }
                for (var il = 0, ih = ip.length; il < ih; il++) {
                    var hU = ip[il];
                    if (hU.isDel == false) {
                        var e = hU.arrIntersectIndex;
                        for (var ii = 0, iW = e.length; ii < iW; ii++) {
                            var iB = ip[e[ii]];
                            iB.isDel = true;
                            if (iB.guidExt === 1) {
                                iB.isDel = false
                            }
                        }
                    }
                }
                return ip
            }
        });

        function ah(e) {
            this._map = e;
            this._initCanvas();
            this._initVars();
            this._bindEvent();
            this._tileType = cI.getInstance("na")
        }
        bl.register(function (i) {
            if (i.getRenderType() === "canvas") {
                var e = i.config.style;
                if (bl["FeatureStyle" + e]) {
                    i.canvas2dMapMgr = new ah(i)
                } else {
                    i.loadMapStyleFiles(function () {
                        i.canvas2dMapMgr = new ah(i);
                        i.canvas2dMapMgr._loadData()
                    })
                }
            }
        });
        C.extend(ah.prototype, {
            _initCanvas: function () {
                var hQ = this._map,
                    hO = hQ.getSize(),
                    hN = hO.width,
                    i = hO.height,
                    e = hQ.platform,
                    hR = S("canvas"),
                    hP = hR.style;
                var T = this.ratio = hQ.config.ratio;
                this._width = hN;
                this._height = i;
                hP.cssText = "position: absolute;left:0;top:0;width:" + hN + "px;height:" + i + "px;z-index:100;";
                hR.width = hN * T;
                hR.height = i * T;
                this._labelCanvas = hR;
                this._labelCtx = hR.getContext("2d");
                e.appendChild(hR)
            },
            _initVars: function () {
                var e = aB("ditu", "normal");
                this._udt = e.udt;
                this._version = e.ver;
                this._labelDataUrls = b3.B_NORMAL_MAP.vectorTileUrls;
                this._style = bl["FeatureStyle" + this._map.config.style];
                this._labelCount = 0;
                this._vectorDrawLib = new aX(this);
                this._cache = {
                    maxNum: 500,
                    delNum: 50,
                    arrCache: []
                };
                this._computedLabel = null;
                this._spotData = null;
                this._labelStrategy = new d9(this);
                this._labelClick = new c(this);
                this._biz = new gJ(this);
                this._map.temp.isPermitSpotOver = true;
                this.labelStyleParam = "pl";
                if (this._map.getMapType() === BMAP_SATELLITE_MAP) {
                    this.labelStyleParam = "sl"
                }
                this.statRequestCount = 0;
                this.statResponseCount = 0
            },
            _resizeHandler: function (hP) {
                var hR = this,
                    i = hR._map,
                    hO = i.getSize(),
                    T = hO.width,
                    hT = hO.height;
                var hQ = this.ratio;
                var hU = this._labelCanvas,
                    hN = hU.style;
                hN.width = T + "px";
                hN.height = hT + "px";
                hU.width = T * hQ;
                hU.height = hT * hQ;
                hR._width = T;
                hR._height = hT;
                var hS = true;
                hR._loadData(hS)
            },
            _bindEvent: function () {
                var e = this,
                    i = e._map;
                i.addEventListener("load", function (T) {
                    e.clearLabel();
                    e._loadData()
                });
                i.addEventListener("zoomend", function (T) {
                    if (!T.notClearLabel) {
                        e.clearLabel()
                    }
                    e._loadData()
                });
                i.addEventListener("moveend", function (T) {
                    e._loadData()
                });
                i.addEventListener("resize", function (T) {
                    e._resizeHandler(T)
                });
                i.addEventListener("maptypechange", function (T) {
                    if (T.mapType === BMAP_EARTH_MAP) {
                        e.hideLabelCanvas()
                    } else {
                        e.showLabelCanvas();
                        if (T.mapType === BMAPGL_NORMAL_MAP) {
                            e.labelStyleParam = "pl"
                        } else {
                            if (T.mapType === BMAP_SATELLITE_MAP) {
                                e.labelStyleParam = "sl"
                            }
                        }
                        e._loadData()
                    }
                });
                i.addEventListener("streetlayer_show", function (T) {
                    if (this.isCanvasMap()) {
                        e.showLabelCanvas()
                    }
                });
                i.addEventListener("streetlayer_hide", function (T) {
                    if (this.isCanvasMap()) {
                        e.hideLabelCanvas()
                    }
                });
                i.addEventListener("loadbizdata", function (hN) {
                    var T = hN.data;
                    e._biz.proecessBizData(T, function () {
                        e.updateLabel()
                    })
                });
                i.addEventListener("unloadbizdata", function (T) {
                    e._biz.clearBizData();
                    e.updateLabel()
                });
                e.isDrawText = false;
                setTimeout(function () {
                    if (!e.isDrawText) {
                        i.dispatchEvent(new a8("onmapwhitescreen"))
                    }
                }, 10000)
            },
            getStyle: function () {
                return this._style
            },
            _getZoomUnits: function (e) {
                return Math.pow(2, 18 - e)
            },
            _createCacheForm: function (T, hR, hQ, i) {
                var hP = this;
                var e = hP._cache;
                var hN = e.arrCache;
                var hS = this._getLabelId(T, hR, hQ, i);
                var hO = {
                    id: hS,
                    updateLabelCounter: 0
                };
                hN.push(hO);
                hN[hS] = hO;
                return hO
            },
            _getLabelId: function (i, hN, T, e) {
                return "_" + i + "_" + hN + "_" + T + "_" + e + "_" + this.labelStyleParam
            },
            _getCache: function (i, hN, T, e) {
                return this._cache.arrCache[this._getLabelId(i, hN, T, e)]
            },
            _setCacheValue: function (hO, h1, hZ, hN, hU) {
                var hW = this;
                var e = hW._cache;
                var hQ = e.arrCache;
                var hS = e.maxNum;
                var hP = e.delNum;
                var h0 = this._getLabelId(hO, h1, hZ, hN);
                var hV = hQ[h0];
                if (hU) {
                    hV.lb = hU
                }
                if (hQ.length > hS) {
                    var T = hQ.splice(0, hP);
                    for (var hT = 0, hR = T.length; hT < hR; hT++) {
                        var hX = T[hT],
                            hY = hX.id;
                        if (hQ[hY].lb) {
                            hQ[hY].lb = null
                        }
                        hQ[hY] = null;
                        delete hQ[hY]
                    }
                    T = null
                }
            },
            _loadData: function (hZ) {
                var ik = this._map;
                if (!ik.isCanvasMap()) {
                    return
                }
                var hS = ik.getCenterIn();
                var ij = d0.calcLoopCenterPoint(hS);
                var hR = this._tileType;
                var hU = this._width / 2;
                var h6 = this._height;
                var h7 = ik.getZoom();
                var h3 = hR.getDataZoom(h7);
                var hW = ik.getZoomUnits(h7);
                var h2 = hW * hU;
                var ii = ij.lng - h2;
                var ih = ij.lng + h2;
                var h0 = d0.isAddWidth(ii, ih);
                hU = h0 ? hU * 1.5 : hU;
                var h1 = hR.getTileSize(h7);
                var hO = hR.getMercatorSize(h7, h3);
                var hV = Math.floor(ij.lng / hO);
                var hX = Math.floor(ij.lat / hO);
                var hP = [hV, hX, (ij.lng - hV * hO) / hO * h1, (ij.lat - hX * hO) / hO * h1];
                var h9 = hP[0] - Math.ceil((hU - hP[2]) / h1);
                var ie = hP[1] - Math.ceil((h6 / 2 - hP[3]) / h1);
                var h5 = hP[0] + Math.ceil((hU + hP[2]) / h1);
                var ia = hP[1] + Math.ceil((h6 / 2 + hP[3]) / h1);
                ik.temp.isPermitSpotOver = false;
                var e = [];
                for (var ic = h9; ic < h5; ic++) {
                    for (var ib = ie; ib < ia; ib++) {
                        e.push([ic, ib, h3]);
                        var h4 = "id_" + ic + "_" + ib + "_" + h7;
                        e[h4] = true
                    }
                }
                e._zoom = h3;
                e = d0.calcLoopTiles(e, h7);
                e.sort((function (i) {
                    return function (id, im) {
                        return ((0.4 * Math.abs(id[0] - i[0]) + 0.6 * Math.abs(id[1] - i[1])) - (0.4 * Math.abs(im[0] - i[0]) + 0.6 * Math.abs(im[1] - i[1])))
                    }
                })([hP[0], hP[1]]));
                var hY = this._cache.arrCache;
                this._curViewLabels = [];
                var hN = "viewKey_" + Math.floor(hS.lng) + "_" + Math.floor(hS.lat) + "_" + h7;
                this.statRequestCount = 0;
                this.statResponseCount = 0;
                this._labelCount += e.length;
                var hT = h7;
                for (var ic = 0, h8 = e.length; ic < h8; ic++) {
                    var hV = e[ic][0];
                    var hX = e[ic][1];
                    var T = e[ic][2];
                    var hQ = this._getLabelId(hV, hX, T, hT);
                    var ig = hY[hQ];
                    if (!ig) {
                        ig = this._createCacheForm(hV, hX, T, hT)
                    }
                    if (typeof ig.lb === "undefined") {
                        ig.lb = null;
                        this._loadLabelData(hV, hX, T, hT, h1, hN);
                        this.statRequestCount++
                    } else {
                        if (ig.lb) {
                            this._curViewLabels.push(ig.lb);
                            this._labelCount--
                        } else {
                            if (hZ) {
                                this._loadLabelData(hV, hX, T, hT, h1, hN)
                            }
                            ig.updateLabelCounter++
                        }
                    }
                }
                if (this._labelCount === 0) {
                    this.updateLabel()
                }
                var il = this;
                if (il.errorTimer) {
                    clearTimeout(il.errorTimer)
                }
                il.errorTimer = setTimeout(function () {
                    if (il._labelCount !== 0) {
                        il._labelCount = 0;
                        il.updateLabel()
                    }
                    var im = new a8("onloaddatatimeout");
                    var io = 0;
                    var id = 0;
                    var ip = 0;
                    var i = 0;
                    if (il.statRequestCount === il.statResponseCount) {
                        io = 1
                    } else {
                        id = 1
                    } if (id === 1) {
                        i = il.statRequestCount - il.statResponseCount;
                        ip = il.statResponseCount
                    }
                    im.noTimeoutCount = io;
                    im.timeoutCount = id;
                    im.timeoutNoLoaded = i;
                    im.timeoutLoaded = ip;
                    il._map.dispatchEvent(im)
                }, 500)
            },
            clearLabel: function () {
                var e = this._width;
                var T = this._height;
                var i = this.ratio;
                this._labelCtx.clearRect(0, 0, e * i, T * i)
            },
            updateLabel: function () {
                var i = this._map;
                var e = i.getCenterIn();
                var hN = this._width;
                var hQ = this._height;
                var hT = i.getZoom();
                var hS = this._tileType.getTileSize(hT);
                var hR = this._getZoomUnits(hT);
                var T = this._labelCtx;
                this._labelCanvas.style.left = -i.offsetX + "px";
                this._labelCanvas.style.top = -i.offsetY + "px";
                var hP = this._curViewLabels;
                hP._centerX = e.lng;
                hP._centerY = e.lat;
                var hO = this._biz.bizLabels;
                this._computedLabel = this._labelStrategy.preComputeLabel(hP, hN, hQ, hR, hS, hO);
                this._computedLabel._zoom = hT;
                this.clearLabel();
                this._vectorDrawLib.drawIconAndText(T, this._computedLabel, hT);
                this._addSpotData();
                i.temp.isPermitSpotOver = true;
                if (hP.length > 0) {
                    this.isDrawText = true
                }
            },
            _loadLabelData: function (hW, hV, hU, T, hX, e) {
                var hP = hW.toString();
                var hN = hV.toString();
                var hR = "cbk_" + hP.replace("-", "_") + "_" + hN.replace("-", "__") + "_" + Math.floor(hU);
                var h1 = ex + "." + hR;
                var h0 = this._labelDataUrls;
                var hT = Math.abs(hW + hV) % h0.length;
                var h6 = h0[hT];
                if (window.offLineIPAddress) {
                    h6 = window.offLineIPAddress + "pvd/"
                }
                var i = this.labelStyleParam;
                var hZ = "?qt=vtile";
                var h2 = "";
                if (this._map.config.style !== "default") {
                    h2 = "&styleId=" + e0.mapStyleNameIdPair[this._map.config.style]
                }
                var hY = "x={x}&y={y}&z={z}&udt={udt}&v={v}&styles={styles}" + h2 + "&textonly=1&textimg=1&scaler={scaler}&fn=" + encodeURIComponent(h1);
                var h3 = d0.calcLoopParam(hW, hU).col;
                var hS = this.ratio > 1 ? 2 : 1;
                var hQ = hY.replace(/{x}/, h3).replace(/{y}/, hV).replace(/{z}/, Math.floor(hU)).replace(/{styles}/, i).replace(/{udt}/, this._udt).replace(/{v}/, this._version).replace(/{scaler}/, hS);
                var hO = h6 + hZ + "&param=" + window.encodeURIComponent(gh(hQ));
                var h5 = this;
                var h4 = h5._map;
                bl[hR] = function (h7) {
                    h5._vectorDrawLib.parseLabelData(h7, hW, hV, hU, T, hX, function (ic) {
                        var h9 = h4.getCenterIn();
                        var id = h4.getZoom();
                        var ig = "viewKey_" + Math.floor(h9.lng) + "_" + Math.floor(h9.lat) + "_" + id;
                        h5._labelCount--;
                        var ih = h5._getCache(hW, hV, hU, T).updateLabelCounter;
                        h5._labelCount -= ih;
                        var ia = h5._curViewLabels;
                        if (ig === e || (h5._labelCount < 0 && id === hU)) {
                            ia.push(ic)
                        }
                        if (ig === e) {
                            h5.statResponseCount++
                        }
                        if (h5._labelCount <= 0) {
                            var h8 = (new Date()).getTime();
                            h5.updateLabel();
                            var ib = (new Date()).getTime();
                            var ie = new a8("oncanvasmaploaded");
                            ie.drawTime = ib - h8;
                            if (h5.statResponseCount === h5.statRequestCount) {
                                ie.isAllLoadedDrawing = true
                            }
                            h4.dispatchEvent(ie)
                        }
                        h5._setCacheValue(hW, hV, hU, T, ic);
                        delete bl[hR]
                    })
                };
                hi.load(hO)
            },
            drawLabel: function (T, hN, hU, i, hS, hO, e, hP, hT, hQ) {
                var hR = this;
                if (!hR._computedLabel) {
                    return
                }
                if (hR._computedLabel._zoom !== hU) {
                    hR.clearLabel();
                    return
                }
                hR._map.temp.isPermitSpotOver = false;
                hR.clearLabel();
                hR._vectorDrawLib.zoomingIconAndText(this._labelCtx, hR._computedLabel, T, hN, i, hS, hO, e, hP, hT, hQ)
            },
            _addSpotData: function () {
                this._spotData = [];
                var hU = this._map.getZoom();
                for (var hP = 0, hO = this._computedLabel.length; hP < hO; hP++) {
                    var hR = this._computedLabel[hP];
                    if (!this.isClickableLabel(hR) || (hR.guidExt === 1 && hR.startScale > hU)) {
                        continue
                    }
                    var hQ = [];
                    hQ[0] = (hR.minX - hR.maxX) / 2;
                    hQ[1] = (hR.minY - hR.maxY) / 2;
                    hQ[2] = (hR.maxX - hR.minX) / 2;
                    hQ[3] = (hR.maxY - hR.minY) / 2;
                    var hN = null;
                    if (hR.iconPos) {
                        hN = new ho(hR.iconPos.geoX, hR.iconPos.geoY)
                    }
                    var T = hR.name ? hR.name.replace("\\\\", "<br>") : "";
                    if (hR.iconPos && hR.iconPos.iconType.indexOf("ditie") > -1 && this._map.getZoom() > 14) {
                        T = ""
                    }
                    var hT = {
                        n: T,
                        pt: new ho(hR.geoX, hR.geoY),
                        userdata: {
                            iconPoint: hN,
                            uid: hR.guid,
                            name: T,
                            type: hR.iconPos ? hR.iconPos.iconType : "",
                            iconImg: hR.iconImg,
                            mapPoi: true,
                            adver_log: hR.adver_log || ""
                        },
                        bd: hQ,
                        tag: "MAP_SPOT_INFO"
                    };
                    this._spotData.push(hT)
                }
                var hS = new a8("onspotsdataready");
                hS.spots = this._spotData;
                this._map._spotDataOnCanvas = this._spotData;
                this._map.dispatchEvent(hS)
            },
            isClickableLabel: function (e) {
                if (e.isDel || (!e.guid && !e.name)) {
                    return false
                }
                return true
            },
            getFilterImageData: function (T, hQ) {
                var hR = T.data,
                    hP = this._labelStrategy,
                    hQ = parseInt(hQ);
                for (var hS = 0, hO = hR.length; hS < hO; hS += 4) {
                    var e = hR[hS],
                        hT = hR[hS + 1],
                        hU = hR[hS + 2],
                        hV = hR[hS + 3];
                    if (hV === 0) {
                        continue
                    }
                    var hN = Math.round((e + hT + hU) / 3);
                    var hW = hN - 90;
                    hW = hW < 0 ? 0 : hW;
                    if (hQ === hP.RANK5) {
                        hR[hS] = 51 + hW * 1.3;
                        hR[hS + 1] = 133 + hW * 0.8;
                        hR[hS + 2] = 255
                    }
                }
                return T
            },
            showLabelCanvas: function () {
                this._labelCanvas.style.visibility = ""
            },
            hideLabelCanvas: function () {
                this._labelCanvas.style.visibility = "hidden"
            }
        });
        var b6 = 5;
        var dU = 4;
        var hm = 3;
        var fc = 2;
        var hG = 1;
        var dX = 0;
        var hJ = 3;
        var hc = 5;
        var I = {
            3: {
                start: 3,
                base: 3
            },
            4: {
                start: 4,
                base: 5
            },
            5: {
                start: 4,
                base: 5
            },
            6: {
                start: 6,
                base: 7
            },
            7: {
                start: 6,
                base: 7
            },
            8: {
                start: 8,
                base: 9
            },
            9: {
                start: 8,
                base: 9
            },
            10: {
                start: 10,
                base: 10
            },
            11: {
                start: 11,
                base: 12
            },
            12: {
                start: 11,
                base: 12
            },
            13: {
                start: 11,
                base: 12
            },
            14: {
                start: 14,
                base: 15
            },
            15: {
                start: 14,
                base: 15
            },
            16: {
                start: 16,
                base: 17
            },
            17: {
                start: 16,
                base: 17
            },
            18: {
                start: 18,
                base: 19
            },
            19: {
                start: 18,
                base: 19
            },
            20: {
                start: 18,
                base: 19
            },
            21: {
                start: 18,
                base: 19
            }
        };

        function aX(hN) {
            this._canvas2dMapMgr = hN;
            var i = this.ratio = hN._map.config.ratio;
            this._featureStyle = null;
            this._map = hN._map;
            var T = fw();
            var e = "udt=" + T.udt + "&v=" + T.ver;
            this.sizeRatio = this.ratio > 1 ? 2 : 1;
            this._binaryCache = {};
            this._iconCache = {};
            this._initColorCanvas()
        }
        C.extend(aX.prototype, {
            _initColorCanvas: function () {
                var i = 256,
                    T = S("canvas"),
                    e = T.style;
                e.width = i + "px";
                e.height = i + "px";
                T.width = i;
                T.height = i;
                this._colorCvs = T;
                this._colorCtx = T.getContext("2d")
            },
            parseLabelData: function (i, hP, hO, hN, e, hS, hR) {
                if (!this._featureStyle) {
                    this._featureStyle = this._canvas2dMapMgr.getStyle()
                }
                if (!i || !i[0]) {
                    hR([]);
                    return
                }
                var hQ = this._map.getZoomUnits();
                var T = this;
                this.loadTextPng(i, hS, hP, hO, hN, e, hQ, hR)
            },
            loadTextPng: function (h4, hV, hT, hS, hQ, i, hO, hN) {
                var h3 = this;
                var e = h4[5];
                var h2 = this._map;
                var hZ = h2.getZoom();
                var T = h2.getSize();
                var h0 = T.width;
                var hY = T.height;
                var h1 = h2.getCenterIn();
                var hR = h1.lng;
                var hP = h1.lat;
                var hX = hT * hV * hO;
                var hW = (hS + 1) * hV * hO;
                if (e) {
                    var hU = new Image();
                    hU.onload = function () {
                        h3.calcIconAndTextInfo(h4, hU, hV, hT, hS, hQ, i, hO, hX, hW, hN);
                        delete this.onload
                    };
                    hU.src = e
                } else {
                    setTimeout(function () {
                        h3.calcIconAndTextInfo(h4, null, hV, hT, hS, hQ, i, hO, hX, hW, hN)
                    }, 1)
                }
            },
            calcIconAndTextInfo: function (h6, hX, hY, hW, hT, hR, hN, hP, h0, hZ, hO) {
                var h5 = this;
                var h4 = h5._featureStyle;
                var hU = [];
                hU.x = hW;
                hU.y = hT;
                hU.z = hR;
                var hV = h5._canvas2dMapMgr,
                    T = hW * hP * hY,
                    h3 = (hT + 1) * hP * hY,
                    hQ = {
                        tileLeft: T,
                        tileTop: h3,
                        zoomUnits: hP
                    };
                var e = [];
                if (h6[0]) {
                    for (var h1 = 0; h1 < h6[0].length; h1++) {
                        if (h6[0][h1][0] === hJ) {
                            e.push(h6[0][h1])
                        }
                    }
                }
                var hS = h6[2] || [];
                for (var h1 = 0; h1 < e.length; h1++) {
                    this._getFixedLabelInfo(e[h1], hX, hN, hP, hY, h0, hZ, hU)
                }
                var h2 = Math.pow(2, hN - hR);
                for (h1 = 0; h1 < hS.length; h1++) {
                    this._getLineLabelInfo(hS[h1], hX, hR, hN, hP, hY, h0, hZ, h2, hU)
                }
                hO(hU)
            },
            _getFixedLabelInfo: function (hX, h1, hO, hS, h2, h5, h4, h7) {
                var hW = hX[1];
                if (!hW) {
                    return
                }
                var h9 = this._map.getZoom();
                var ii = this._map.config.style;
                var ij = this._featureStyle;
                var hT = hO;
                if (hT === 9) {
                    hT = 8
                }
                for (var ie = 0; ie < hW.length; ie++) {
                    var ik = hW[ie];
                    var e = ik[0];
                    var hN = ei.getStyleFromCache(ii, e, "point", hT, ij);
                    var id = ei.getStyleFromCache(ii, e, "pointText", hT, ij);
                    if ((!id || id.length === 0) && (!hN || hN.length === 0)) {
                        if (hT === 5) {
                            var hR = ik[1];
                            if (!hR) {
                                continue
                            }
                            for (var ia = 0; ia < hR.length; ia++) {
                                var h8 = hR[ia][4];
                                if (h8 && h8[7] === "北京") {
                                    hN = ei.getStyleFromCache(ii, e, "point", 6, ij);
                                    id = ei.getStyleFromCache(ii, e, "pointText", 6, ij);
                                    break
                                } else {
                                    continue
                                }
                            }
                        } else {
                            continue
                        }
                    }
                    var hR = ik[1];
                    if (!hR) {
                        continue
                    }
                    var ig = null;
                    var hU = 1;
                    var T = 0;
                    var h0 = 0;
                    if (hN && hN[0]) {
                        hN = hN[0];
                        ig = hN.icon;
                        hU = hN.zoom ? hN.zoom / 100 : 1
                    } else {
                        hN = null
                    }
                    for (var ia = 0; ia < hR.length; ia++) {
                        var h8 = hR[ia][4];
                        if (!h8) {
                            continue
                        }
                        var ic = h8[2];
                        if (!this._isVisible(ic, h9)) {
                            continue
                        }
                        var hV = h8[12];
                        if (id && id.length > 0 && !hV) {
                            continue
                        }
                        var hZ = Math.round(h8[0] / 100);
                        var hY = Math.round(h8[1] / 100);
                        var ib = {
                            lng: h5 + hZ,
                            lat: h4 - (h2 * hS - hY)
                        };
                        var hQ = hZ / hS;
                        var hP = h2 - hY / hS;
                        var h3 = h8[7] || "";
                        var ih = h8[5];
                        var h6 = {
                            type: "fixed",
                            name: h3,
                            textImg: h1,
                            rank: h8[4],
                            baseX: hQ,
                            baseY: hP,
                            iconPos: null,
                            textPos: null,
                            guid: h8[3] || "",
                            tracer: ic,
                            direction: ih,
                            startScale: 3
                        };
                        if ((ih !== dU && hV || !hV) && ig !== null) {
                            h6.iconPos = this._getIconPosition(ig, hU, hQ, hP, ib);
                            if (h6.iconPos) {
                                T = h6.iconPos.width;
                                h0 = h6.iconPos.height
                            }
                        }
                        if (T === 0) {
                            h6.direction = dU
                        }
                        if (hV) {
                            h6.textPos = this._getTextDrawData(h8, hQ, hP, T, h0)
                        }
                        if (h6.textPos || h6.iconPos) {
                            h7.push(h6)
                        }
                    }
                }
            },
            _isVisible: function (e, i) {
                var hN;
                if (!this._binaryCache[e]) {
                    hN = e.toString(2);
                    if (hN.length < 8) {
                        hN = new Array(8 - hN.length + 1).join("0") + hN
                    }
                    this._binaryCache[e] = hN
                }
                hN = this._binaryCache[e];
                var T = I[i].start;
                return hN[i - T] === "1"
            },
            _getIconPosition: function (hR, hP, T, i, e) {
                var hN = this._map.config.style;
                var hS = bl["iconSetInfo" + hN][hR];
                if (!hS) {
                    if (hR.charCodeAt(0) >= 48 && hR.charCodeAt(0) <= 57) {
                        hS = bl["iconSetInfo" + hN]["_" + hR]
                    }
                }
                if (!hS) {
                    return null
                }
                var hO = hS[0];
                var hQ = hS[1];
                hO = hO * hP;
                hQ = hQ * hP;
                return {
                    srcX: 0,
                    srcY: 0,
                    destX: T - hO / 2,
                    destY: i - hQ / 2,
                    width: hO,
                    height: hQ,
                    geoX: e.lng,
                    geoY: e.lat,
                    mcPt: e,
                    iconType: hR
                }
            },
            _getTextDrawData: function (hY, hX, hW, hN, hU) {
                var h3 = hY[5];
                if (typeof h3 !== "number") {
                    h3 = 0
                }
                var hS = this.ratio;
                var hR = hS / 2;
                hN *= hR;
                hU *= hR;
                var hT = hY[12];
                var hO = hT.length;
                var h6 = 0;
                var h5 = 0;
                var h2 = [];
                var h1 = 0;
                var h4 = 0;
                for (var h0 = 0; h0 < hO; h0++) {
                    h4 += Math.round(hT[h0][3])
                }
                for (var h0 = 0; h0 < hO; h0++) {
                    var hQ = hT[h0];
                    var hP = hQ[0];
                    var i = hQ[1];
                    var T = hQ[2];
                    var e = hQ[3];
                    var h7 = 2 * hS;
                    var hZ = 0;
                    if (hN !== 0) {
                        hZ = 2 * hS
                    }
                    if (hN === 0) {
                        h3 = dU
                    }
                    switch (h3) {
                        case hm:
                            var hV = hW - h4 / 2 - h7 * (hO - 1) / 2;
                            h6 = hX - T - hN / 2 - hZ;
                            h5 = hV + h1 + h7 * h0;
                            break;
                        case hG:
                            var hV = hW - h4 / 2 - h7 * (hO - 1) / 2;
                            h6 = hX + hN / 2 + hZ;
                            h5 = hV + h1 + h7 * h0;
                            break;
                        case fc:
                            var hV = hW - hU / 2 - h4 - h7 * (hO - 1) - h7;
                            h6 = hX - T / 2;
                            h5 = hV + h1 + h7 * h0;
                            break;
                        case dX:
                            var hV = hW + hU / 2 + h7 / 2;
                            h6 = hX - T / 2;
                            h5 = hV + h1 + h7 * h0;
                            break;
                        case dU:
                            var hV = hW - e / 2 - h7 * (hO - 1) / 2;
                            h6 = hX - T / 2;
                            h5 = hV + h1 + h7 * h0;
                            break
                    }
                    h1 += e;
                    if (T > 0 && e > 0) {
                        h2.push({
                            srcX: hP,
                            srcY: i,
                            destX: h6,
                            destY: h5,
                            width: T,
                            height: e
                        })
                    }
                }
                if (h2.length > 0) {
                    return h2
                }
                return null
            },
            _getLineLabelInfo: function (hV, hN, hO, ia, ip, h2, h8, h7, h9, h1) {
                if (hV.length !== 10) {
                    return
                }
                var ic = this.ratio;
                var T = this.ratio;
                var ik = hV[7].length;
                var h3 = hV[1];
                var im = hV[3];
                var iu = hV[8];
                var hR = hV[4];
                var e = 2;
                var hP = hR.slice(0, e);
                for (var iq = e; iq < hR.length; iq += e) {
                    hP[iq] = hP[iq - e] + hR[iq];
                    hP[iq + 1] = hP[iq - (e - 1)] + hR[iq + 1]
                }
                for (var iq = e; iq < hR.length; iq += e) {
                    if (iq % (im * e) === 0 || iq % (im * e) === 1) {
                        continue
                    }
                    hP[iq] = hP[iq - e] + hR[iq] / h9;
                    hP[iq + 1] = hP[iq - (e - 1)] + hR[iq + 1] / h9
                }
                for (var it = 0; it < ik; it++) {
                    var io = hV[7][it];
                    if (!this._isVisible(io, ia)) {
                        continue
                    }
                    var ie = hV[6][it];
                    var h0 = it * im * e;
                    hR = hP.slice(h0, h0 + im * e);
                    var h4 = [];
                    var id = undefined;
                    var ib = undefined;
                    var hZ = undefined;
                    var hY = undefined;
                    var iu = hV[9].slice(0);
                    if (ie) {
                        iu.reverse()
                    }
                    var ii;
                    var ig;
                    for (var ir = 0; ir < im; ir++) {
                        var hX = hV[5][im * it + ir];
                        var ij = hR[ir * e] / 100;
                        var ih = hR[ir * e + 1] / 100;
                        var hW = iu[ir];
                        var hS = hW[0];
                        var hU = hW[1];
                        var hQ = hW[2];
                        var hT = hW[3];
                        var h6;
                        var h5;
                        var iw;
                        var iv;
                        if (ir === 0) {
                            ii = iw = ij / ip;
                            ig = h2 - ih / ip;
                            iv = ih / ip
                        } else {
                            iw = ij / ip;
                            iv = ih / ip
                        }
                        var iy = ii + (iw - ii) * T - hQ / 2;
                        var ix = ig + (h2 - iv - ig) * T - hT / 2;
                        if (id === undefined) {
                            id = ii - hQ / 2;
                            ib = ig - hT / 2;
                            hZ = id + hQ;
                            hY = ib + hT
                        } else {
                            if (iy < id) {
                                id = iy
                            }
                            if (ix < ib) {
                                ib = ix
                            }
                            if (iy + hQ > hZ) {
                                hZ = iy + hQ
                            }
                            if (ix + hT > hY) {
                                hY = ix + hT
                            }
                        }
                        h4.push({
                            angle: hX,
                            srcX: hS,
                            srcY: hU,
                            destX: iy,
                            destY: ix,
                            width: hQ,
                            height: hT
                        })
                    }
                    var il = {
                        type: "line",
                        textImg: hN,
                        rank: h3,
                        baseX: ii,
                        baseY: ig,
                        arrWordPos: h4,
                        minXOriginal: id,
                        minYOriginal: ib,
                        maxXOriginal: hZ,
                        maxYOriginal: hY,
                        text: ""
                    };
                    h1.push(il)
                }
            },
            alterColor: function (hQ, e, hP) {
                var T = this._colorCtx,
                    i = this._canvas2dMapMgr;
                T.clearRect(0, 0, hQ.width, hQ.height);
                T.drawImage(e, hQ.srcX, hQ.srcY, hQ.width, hQ.height, 0, 0, hQ.width, hQ.height);
                var hO = T.getImageData(0, 0, hQ.width, hQ.height),
                    hN = i.getFilterImageData(hO, hP);
                T.putImageData(hN, 0, 0)
            },
            drawIconAndText: function (h2, h1, e) {
                var hT = this.ratio;
                var hR = this.sizeRatio / hT;
                var hV = 2 / hT;
                var id = this;
                for (var h5 = 0, h3 = h1.length; h5 < h3; h5++) {
                    var hU = h1[h5];
                    if (hU.isDel == false) {
                        var hO = hU.baseDrawX;
                        var hN = hU.baseDrawY;
                        if (hU.type == "fixed") {
                            var hQ = hU.iconPos,
                                h6 = hU.textPos,
                                hZ = hU.textImg,
                                h9 = hU.startScale;
                            if (hQ && h9 <= e) {
                                var T = this._iconCache[hQ.iconType];
                                if (T) {
                                    if (T.img) {
                                        h2.drawImage(T.img, 0, 0, T.img.width, T.img.height, Math.round(hO * hT + (hQ.drawX - hO) / hV), Math.round(hN * hT + (hQ.drawY - hN) / hV), hQ.width / hV, hQ.height / hV)
                                    } else {
                                        T.drawLabels.push(hU)
                                    }
                                } else {
                                    if (!T) {
                                        this._iconCache[hQ.iconType] = {
                                            img: null,
                                            drawLabels: [hU]
                                        };
                                        var ig = new Image();
                                        ig._iconName = hQ.iconType;
                                        ig.onload = function () {
                                            var im = id._iconCache[this._iconName];
                                            im.img = this;
                                            this.onload = null;
                                            for (var ii = 0; ii < im.drawLabels.length; ii++) {
                                                var ik = im.drawLabels[ii];
                                                var ij = ik.baseDrawX;
                                                var ih = ik.baseDrawY;
                                                var il = ik.iconPos;
                                                h2.drawImage(this, 0, 0, this.width, this.height, Math.round(ij * hT + (il.drawX - ij) / hV), Math.round(ih * hT + (il.drawY - ih) / hV), il.width / hV, il.height / hV)
                                            }
                                            im.drawPos = []
                                        };
                                        ig.src = e0.getIconSetPath(id._map.config.style) + hQ.iconType + ".png"
                                    }
                                }
                            }
                            if (h6 && hZ && h9 <= e) {
                                for (var hS = 0; hS < h6.length; hS++) {
                                    var h0 = h6[hS];
                                    if (!hU._tempRank) {
                                        h2.drawImage(hZ, h0.srcX, h0.srcY, h0.width, h0.height, Math.round(hO * hT + (h0.drawX - hO) / hR), Math.round(hN * hT + (h0.drawY - hN) / hR), h0.width / hR, h0.height / hR)
                                    } else {
                                        this.alterColor(h0, hZ, hU._tempRank);
                                        h2.drawImage(this._colorCvs, 0, 0, h0.width, h0.height, Math.round(hO * hT + (h0.drawX - hO) / hR), Math.round(hN * hT + (h0.drawY - hN) / hR), h0.width / hR, h0.height / hR)
                                    }
                                }
                            }
                        } else {
                            var hP = hU.arrWordPos,
                                hZ = hU.textImg,
                                hY = hU.tileX,
                                hW = hU.tileY;
                            for (var h4 = 0, hX = hP.length; h4 < hX; h4++) {
                                var h7 = hP[h4];
                                var ie = Math.round(hY + h7.destX);
                                var ic = Math.round(hW + h7.destY);
                                var h8 = h7.angle;
                                ie = hO * hT + ie - hO;
                                ic = hN * hT + ic - hN;
                                if (h8 > 10 && h8 < 350) {
                                    h2.save();
                                    var ib = Math.round(ie + h7.width / 2);
                                    var ia = Math.round(ic + h7.height / 2);
                                    h2.translate(ib, ia);
                                    h2.rotate(-h8 / 180 * Math.PI);
                                    h2.drawImage(hZ, h7.srcX, h7.srcY, h7.width, h7.height, -Math.round(h7.width / 2), -Math.round(h7.height / 2), h7.width / hR, h7.height / hR);
                                    h2.restore()
                                } else {
                                    h2.drawImage(hZ, h7.srcX, h7.srcY, h7.width, h7.height, ie, ic, h7.width / hR, h7.height / hR)
                                }
                            }
                        }
                    }
                }
            },
            isCollide: function (hP, hY, hX, e, hR, T, hT) {
                for (var hO = 0, hN = T.length; hO < hN; hO++) {
                    var hS = T[hO],
                        hQ = 1 / Math.pow(2, hT + 1),
                        hW = hQ * hS[3] / 2,
                        hV = hQ * hS[4] / 2,
                        hU = hS[0];
                    if (hU != hP) {
                        if (!(hY + e < hS[1] - hW || hY > hS[1] + hS[3] + hW || hX + hR < hS[2] - hV || hX > hS[2] + hS[4] + hV)) {
                            return true
                        }
                    }
                }
                return false
            },
            zoomingIconAndText: function (id, h7, hN, ib, ic, iH, il, hV, it, ik, h4) {
                var iI = this.ratio;
                var hW = this.sizeRatio / iI;
                var iJ = 2 / iI;
                var iT = iI / 2;
                var iD = ib.x;
                var iC = ib.y;
                var ie = 2 * iI;
                if (h4 !== 0) {
                    iC += ik
                }
                var hZ = undefined,
                    hS = undefined,
                    hP = undefined,
                    hU = undefined,
                    h3 = undefined;
                var ir = iH > 0 ? true : false;
                if (!ir) {
                    hZ = [];
                    var iw = 1 - il
                }
                for (var iP = 0, iN = h7.length; iP < iN; iP++) {
                    var iK = h7[iP];
                    if (iK.isDel == false) {
                        var iU = iK.baseDrawX;
                        var iR = iK.baseDrawY;
                        id.save();
                        id.translate(-hV * iI, -it * iI);
                        if (iK.isFadeout) {
                            if (!ir && iK._schedule <= il && !iK._isIgnore) {
                                id.globalAlpha = iw;
                                iK._schedule = il
                            } else {
                                iK._isIgnore = true;
                                continue
                            }
                        }
                        if (iK.type == "fixed") {
                            var ig = iK.iconPos,
                                io = iK.textPos,
                                hQ = iK.textImg,
                                ih = iK.startScale;
                            var T;
                            var iA = 0;
                            if (ig) {
                                iA = ie
                            }
                            if (ig && !iK.iconImg && this._iconCache[ig.iconType]) {
                                T = this._iconCache[ig.iconType].img
                            }
                            if (ig && ih <= ic && T) {
                                hU = ig.width;
                                h3 = ig.height;
                                hS = (iD + (iU - iD) * hN) * iI - hU / 2 / iJ;
                                hP = (iC + (iR - iC) * hN) * iI - h3 / 2 / iJ + h4;
                                if (!ir && this.isCollide(iP, hS, hP, hU, h3, hZ, iH)) {
                                    iK.isFadeout = true
                                }
                                id.drawImage(T, ig.srcX, ig.srcY, T.width, T.height, Math.round(hS), Math.round(hP), hU / iJ, h3 / iJ);
                                !ir && hZ.push([iP, hS, hP, hU, h3])
                            }
                            if (io && hQ && ih <= ic) {
                                var im;
                                var ip;
                                var h6 = 0;
                                var ij = 0;
                                if (ig) {
                                    h6 = ig.width;
                                    ij = ig.height
                                }
                                var iB = io.length;
                                var hY = 0;
                                var iq = 0;
                                for (var h8 = 0; h8 < iB; h8++) {
                                    var iM = io[h8];
                                    iq += iM.height;
                                    if (hY < iM.width) {
                                        hY = iM.width
                                    }
                                }
                                iq += (h8 - 1) * ie;
                                if (!ir && this.isCollide(iP, hS, hP, hY, iq, hZ, iH)) {
                                    iK.isFadeout = true
                                }
                                var iL = 0;
                                for (var h8 = 0; h8 < iB; h8++) {
                                    var iM = io[h8];
                                    switch (iK.direction) {
                                        case hm:
                                            im = -(h6 / 2 / iJ + iM.width + iA);
                                            ip = -iq / 2 + iL + ie * h8;
                                            break;
                                        case hG:
                                            im = h6 / 2 / iJ + iA;
                                            ip = -iq / 2 + iL + ie * h8;
                                            break;
                                        case fc:
                                            im = -iM.width / 2;
                                            ip = -ij / 2 / iJ - iq + iL - ie * (h8 + 1);
                                            break;
                                        case dX:
                                            im = -iM.width / 2;
                                            ip = ij / 2 / iJ + iL + ie * (h8 + 1);
                                            break;
                                        case dU:
                                            im = -iM.width / 2;
                                            ip = -iq / 2 + iL + ie * h8;
                                            break
                                    }
                                    iL += iM.height;
                                    hS = (iD + (iU - iD) * hN) * iI + im / hW;
                                    hP = (iC + (iR - iC) * hN) * iI + ip / hW; + h4;
                                    hU = iM.width;
                                    h3 = iM.height;
                                    if (!iK._tempRank) {
                                        id.drawImage(hQ, iM.srcX, iM.srcY, hU, h3, Math.round(hS), Math.round(hP), hU / hW, h3 / hW)
                                    } else {
                                        this.alterColor(iM, hQ, iK._tempRank);
                                        id.drawImage(this._colorCvs, 0, 0, hU, h3, Math.round(hS), Math.round(hP), hU / hW, h3 / hW)
                                    } !ir && hZ.push([iP, hS, hP, hU, h3])
                                }
                            }
                        } else {
                            var h5 = iK.arrWordPos,
                                hQ = iK.textImg,
                                iS = iK.tileX,
                                iQ = iK.tileY;
                            var hX = h5[0];
                            var hT = Math.round(iS + hX.destX);
                            var hR = Math.round(iQ + hX.destY);
                            for (var iO = 0, iz = h5.length; iO < iz; iO++) {
                                var iG = h5[iO];
                                var iW = Math.round(iS + iG.destX);
                                var iV = Math.round(iQ + iG.destY);
                                var ia = iG.angle;
                                var iy = Math.round((iD + (iU - iD) * hN) * iI - hX.width / 2 + iW - hT);
                                var ix = Math.round((iC + (iR - iC) * hN) * iI - hX.height / 2 + iV - hR);
                                hS = iy;
                                hP = ix;
                                hU = iG.width;
                                h3 = iG.height;
                                if (!ir && this.isCollide(iP, hS, hP, hU, h3, hZ, iH)) {
                                    iK.isFadeout = true
                                }
                                if (ia > 10 && ia < 350) {
                                    var iF = iy + iG.width / 2;
                                    var iE = ix + iG.height / 2;
                                    var hO = ia / 180 * Math.PI;
                                    var ii = Math.cos(hO);
                                    var h0 = Math.sin(hO);
                                    var iv = ii;
                                    var h1 = ii;
                                    var iu = h0;
                                    var h2 = -h0;
                                    var h9 = iF - iF * ii - iE * h0;
                                    var e = iE + iF * h0 - iE * ii;
                                    id.save();
                                    id.transform(iv, h2, iu, h1, h9, e);
                                    id.drawImage(hQ, iG.srcX, iG.srcY, hU, h3, hS, hP, hU / hW, h3 / hW);
                                    id.restore()
                                } else {
                                    id.drawImage(hQ, iG.srcX, iG.srcY, hU, h3, hS, hP, hU / hW, h3 / hW)
                                } !ir && hZ.push([iP, hS, hP, hU, h3])
                            }
                        }
                        id.restore()
                    }
                }
            }
        });

        function gJ(e) {
            this.initVars(e)
        }
        C.extend(gJ.prototype, {
            initVars: function (e) {
                this._map = e._map;
                this._canvas2dMapMgr = e;
                this.base64Prefix = "data:image/png;base64,";
                this.bizData = null;
                this.objTextsPng = null;
                this.arrIconsPng = null;
                this.bizLabels = null
            },
            proecessBizData: function (hP, hT) {
                var hR = this;
                this.bizData = hP;
                this.objTextsPng = null;
                this.arrIconsPng = null;
                var T = hP.textsPng;
                var hV = hP.iconsPng;
                if (!T || !hV) {
                    return
                }
                var hS = new Image();
                hS.onload = function () {
                    hR.objTextsPng = this;
                    hR.calcIconAndTextInfo(hT);
                    this.onload = null
                };
                hS.src = this.base64Prefix + T;
                var hU = hV.length;
                var e = [];
                for (var hO = 0; hO < hU; hO++) {
                    var hQ = hV[hO];
                    var hN = new Image();
                    (function (i) {
                        hN.onload = function () {
                            hU--;
                            e[i] = this;
                            if (hU === 0) {
                                hR.arrIconsPng = e;
                                hR.calcIconAndTextInfo(hT)
                            }
                            this.onload = null
                        }
                    })(hO);
                    hN.src = this.base64Prefix + hQ
                }
            },
            calcIconAndTextInfo: function (hW) {
                if (this.objTextsPng && this.arrIconsPng) {
                    var hS = this.bizData;
                    var hQ = hS.pois;
                    var e = [];
                    for (var hT = 0, hP = hQ.length; hT < hP; hT++) {
                        var hN = hQ[hT];
                        var hR = this.arrIconsPng[hN.iconPng];
                        var hO = hR.height / 2;
                        var hV = {
                            type: "fixed",
                            name: "",
                            textImg: this.objTextsPng,
                            iconImg: hR,
                            rank: hN.rank,
                            iconPos: {
                                srcX: 0,
                                srcY: 0,
                                destX: -hR.width / 2,
                                destY: -hO / 2,
                                width: hR.width,
                                height: hO,
                                geoX: hN.x,
                                geoY: hN.y,
                                iconType: "vectorCustom"
                            },
                            textPos: this.calcTextPos(hN.pos, hR),
                            startScale: hN.from < 12 ? 12 : hN.from,
                            guid: hN.guid,
                            guidExt: 1,
                            adver_log: hN.adver_log || ""
                        };
                        var T = {
                            type: "fixed",
                            textDirLeft: "left",
                            name: "",
                            textImg: this.objTextsPng,
                            iconImg: hR,
                            rank: hN.rank,
                            iconPos: {
                                srcX: 0,
                                srcY: 0,
                                destX: -hR.width / 2,
                                destY: -hO / 2,
                                width: hR.width,
                                height: hO,
                                geoX: hN.x,
                                geoY: hN.y,
                                iconType: "vectorCustom"
                            },
                            textPos: this.calcTextPosLeft(hN.pos, hR),
                            startScale: hN.from < 12 ? 12 : hN.from,
                            guid: hN.guid,
                            guidExt: 1,
                            adver_log: hN.adver_log || ""
                        };
                        var hU = [hV, T];
                        e.push(hU)
                    }
                    this.bizLabels = e;
                    hW && hW()
                }
            },
            calcTextPos: function (hQ, T) {
                var i = [];
                var hP = hQ.length / 4;
                var hO = T.width / 2;
                if (hP === 1) {
                    var hN = {
                        srcX: hQ[0],
                        srcY: hQ[1],
                        destX: hO,
                        destY: -hQ[3] / 2,
                        width: hQ[2],
                        height: hQ[3]
                    };
                    i.push(hN)
                } else {
                    var hN = {
                        srcX: hQ[0],
                        srcY: hQ[1],
                        destX: hO,
                        destY: -hQ[3],
                        width: hQ[2],
                        height: hQ[3]
                    };
                    var e = {
                        srcX: hQ[4],
                        srcY: hQ[5],
                        destX: hO,
                        destY: 0,
                        width: hQ[6],
                        height: hQ[7]
                    };
                    i.push(hN);
                    i.push(e)
                }
                return i
            },
            calcTextPosLeft: function (hQ, T) {
                var i = [];
                var hP = hQ.length / 4;
                var hO = T.width / 2;
                if (hP === 1) {
                    var hN = {
                        srcX: hQ[0],
                        srcY: hQ[1],
                        destX: -hO - hQ[2],
                        destY: -hQ[3] / 2,
                        width: hQ[2],
                        height: hQ[3]
                    };
                    i.push(hN)
                } else {
                    var hN = {
                        srcX: hQ[0],
                        srcY: hQ[1],
                        destX: -hO - hQ[2],
                        destY: -hQ[3],
                        width: hQ[2],
                        height: hQ[3]
                    };
                    var e = {
                        srcX: hQ[4],
                        srcY: hQ[5],
                        destX: -hO - hQ[2],
                        destY: 0,
                        width: hQ[6],
                        height: hQ[7]
                    };
                    i.push(hN);
                    i.push(e)
                }
                return i
            },
            clearBizData: function () {
                this.bizData = null;
                this.bizLabels = null
            }
        });

        function c4() { }
        C.extend(c4.prototype, {
            centerAndZoomIn: function (T, hT, hU) {
                hU = hU || {};
                if (!this.loaded) {
                    this.firstTileLoad = false
                }
                hT = this._getProperZoom(hT).zoom;
                if (hU.noAnimation !== true && this.loaded) {
                    var hP = this._ifUseAnimation(T, hT);
                    if (hP) {
                        this.flyToIn(T, hT, hU);
                        return
                    }
                }
                var hR = this;
                if (!T && !hT) {
                    return
                }
                this._stopAllAnimations();
                if (T && !T.equals(this.centerPoint)) {
                    this.fire(new a8("oncenter_changed"))
                }
                if (hT && hT !== this.zoomLevel) {
                    this.fire(new a8("onzoom_changed"))
                }
                T = T || this.centerPoint;
                hT = hT || this.zoomLevel;
                hT = this._getProperZoom(hT).zoom;
                if (this.mapType === BMAP_EARTH_MAP) {
                    if (!this._earth) {
                        this.mapType = BMAPGL_NORMAL_MAP;
                        this.temp.originMapType = BMAP_EARTH_MAP;

                        function hS() {
                            hR._earth = new bl.Earth(hR, {
                                showRealSunlight: hR.config.showRealSunlight,
                                showMilkyway: hR.config.showMilkyway,
                                earthBackground: hR.config.earthBackground
                            });
                            hR._proxyEarthEvents();
                            hR._changeEarthMapType(BMAP_EARTH_MAP);
                            C.extend(hR, bl.EarthView.prototype);
                            delete hR.temp.originMapType
                        }
                        d7.load("earth", function () {
                            if (bl["FeatureStyle" + hR.config.style]) {
                                hS()
                            } else {
                                hR.loadMapStyleFiles(function () {
                                    hS()
                                })
                            }
                        })
                    }
                }
                this.lastLevel = this.zoomLevel || hT;
                this.zoomLevel = hT;
                var hQ = new a8("onload");
                hQ.point = T;
                hQ.zoom = hT;
                this.centerPoint = new ho(T.lng, T.lat);
                this.defaultZoomLevel = this.defaultZoomLevel || this.zoomLevel;
                this.defaultCenter = this.defaultCenter || this.centerPoint;
                if (this.mapType !== BMAP_EARTH_MAP) {
                    this.centerPoint = this.restrictCenter(this.centerPoint)
                }
                if (!this.loaded && !(this.temp.originMapType === BMAP_EARTH_MAP)) {
                    var i = this.config.defaultMaxBounds;
                    var hO = new c1(i, "baidu", this.mapType);
                    var hN = new cO({
                        mapType: this.mapType,
                        copyright: hO,
                        dataType: gp,
                        customLayer: false,
                        baseLayer: true,
                        tileTypeName: "na"
                    });
                    hN._isInnerLayer = true;
                    this.addTileLayer(hN);
                    if (this.mapType === BMAP_SATELLITE_MAP && this._isHybridShow === true) {
                        this._addHybirdMap()
                    }
                    this.baseLayerAdded = true;
                    this.on("zoom_changed", function () {
                        if (this._heading === 0) {
                            return
                        }
                        if (this.getZoom() < 7 && this.config.restrictCenter === true) {
                            hR.resetHeading()
                        }
                    })
                }
                this.loaded = true;
                this.dispatchEvent(hQ);
                hU.callback && hU.callback()
            },
            _ifUseAnimation: function (hN, hS) {
                var hR = this.getSize();
                var T = {
                    zoom: this.zoomLevel
                };
                var hU = {
                    zoom: hS
                };
                var hT = this.pointToPixelIn(this.centerPoint);
                var hO = this.pointToPixelIn(hN, T);
                var hQ = this.pointToPixelIn(this.centerPoint, hU);
                var hW = this.pointToPixelIn(hN, hU);
                var hP = Math.abs(hT.x - hO.x);
                var i = Math.abs(hT.y - hO.y);
                var e = Math.abs(hQ.x - hW.x);
                var hV = Math.abs(hQ.y - hW.y);
                if ((hP > hR.width || i > hR.height) && (e > hR.width || hV > hR.height)) {
                    return false
                }
                return true
            },
            _setPlatformPosition: function (hU, hT, hW) {
                hW = hW || {};
                if (hU === 0 && hT === 0 && !hW.point) {
                    return
                }
                if (isNaN(hW.initMapOffsetX)) {
                    hW.initMapOffsetX = this.offsetX
                }
                if (isNaN(hW.initMapOffsetY)) {
                    hW.initMapOffsetY = this.offsetY
                }
                var hQ = dH(this._heading);
                if (this._tilt > 0) {
                    hT = hT / Math.cos(dH(this._tilt))
                }
                var hV = hU * Math.cos(hQ) + hT * Math.sin(hQ);
                var hS = -hU * Math.sin(hQ) + hT * Math.cos(hQ);
                hV = hV + hW.initMapOffsetX;
                hS = hS + hW.initMapOffsetY;
                if (hW.point) {
                    var i = this.restrictCenter(hW.point);
                    if (!i.equals(this.centerPoint)) {
                        this.centerPoint = i.clone();
                        this.fire(new a8("oncenter_changed"))
                    }
                } else {
                    var hN = this.offsetX - hV;
                    var e = this.offsetY - hS;
                    var hR = this.centerPoint.lng;
                    var hP = this.centerPoint.lat;
                    var hO = new ho(hR, hP);
                    var T = this.getZoomUnits();
                    this.centerPoint = this.restrictCenter(new ho(hO.lng + hN * T, hO.lat - e * T), T);
                    this.fire(new a8("oncenter_changed"))
                }
                this.offsetX = hV;
                this.offsetY = hS;
                this.dispatchEvent(new a8("onmoving"))
            },
            restrictCenter: function (hN, hO) {
                if (this.config.restrictCenter === false) {
                    return hN
                }
                hO = hO || this.getZoomUnits();
                var T = this.pixelToPointIn(new eg(0, 0), {
                    center: hN
                });
                var i = this.pixelToPointIn(new eg(0, this.height), {
                    center: hN
                });
                if (this.zoomLevel < 5) {
                    if (T.lat > c5.MAX_LAT && i.lat < c5.MIN_LAT) {
                        var hP = c5.MAX_LAT - hN.lat;
                        var e = hN.lat - c5.MIN_LAT;
                        var hR;
                        if (hP < e) {
                            hR = hP / (this.height / 2)
                        } else {
                            hR = e / (this.height / 2)
                        }
                        var hQ = 18 - ez(hR);
                        this.zoomLevel = hQ;
                        return hN
                    }
                }
                if (T.lat > c5.MAX_LAT) {
                    hN.lat = c5.MAX_LAT - this.height / 2 * hO
                } else {
                    if (i.lat < c5.MIN_LAT) {
                        hN.lat = c5.MIN_LAT + this.height / 2 * hO
                    }
                }
                return hN
            },
            zoomTo: function (e, hY, hZ) {
                var hU = b3[this.mapType];
                if (!hU) {
                    return
                }
                var hT = this._getProperZoom(e);
                e = hT.zoom;
                if (this.zoomLevel === e) {
                    hZ.callback && hZ.callback();
                    return
                }
                var hP = e;
                this.lastLevel = this.zoomLevel;
                hZ = hZ || {};
                if (this.zoomEventStatus === "idle") {
                    this.fire(new a8("onzoomstart"));
                    this.zoomEventStatus = "zooming"
                }
                if (!hY && (this.getInfoWindow() && this.temp.infoWin && this.temp.infoWin.isOpen())) {
                    hY = this.getInfoWindow().getPoint()
                }
                var T = null;
                if (hZ.fixPixel) {
                    T = hZ.fixPixel
                } else {
                    if (hY) {
                        T = this.pointToPixelIn(hY, {
                            useRound: false
                        })
                    }
                }
                var hQ = this.pixelToPointIn(T);
                var hR = this.centerPoint.clone();
                this.fixPoint = hY;
                this.fixPixel = T;
                this.fixCenter = hR;
                this.mousePosMCPoint = hQ;
                if (hZ.noAnimation) {
                    e = hT.zoom;
                    this.zoomLevel = e;
                    this.fire(new a8("onzoom_changed"));
                    var hO = this.getCurrentMaxTilt();
                    if (this._tilt > hO) {
                        this._tilt = hO
                    }
                    if (hY) {
                        if (this._heading % 360 !== 0 || this._tilt > 0) {
                            var i = this._webglMapCamera.fromScreenPixelToMC(T.x, T.y, {
                                center: hR,
                                zoom: this.zoomLevel
                            });
                            if (i) {
                                var hV = i.sub(hQ);
                                var hN = hR.sub(hV);
                                this.centerPoint = this.restrictCenter(hN)
                            }
                        } else {
                            var hS = this.getZoomUnits();
                            var hN = new ho(hY.lng - hS * (T.x - this.width / 2), hY.lat + hS * (T.y - this.height / 2));
                            this.centerPoint = this.restrictCenter(hN, hS)
                        }
                        this.fire(new a8("oncenter_changed"))
                    }
                    this._checkFireZoomend();
                    hZ.callback && hZ.callback();
                    return
                }
                this._animationInfo.zoom = {
                    current: this.zoomLevel,
                    diff: e - this.zoomLevel,
                    target: e
                };
                var hW = this;
                hW._checkFireZoomend();
                var hX = this._tilt;
                if (this.fixPoint || hX > c5.MAX_DRAG_TILT_L2) {
                    hZ.renderCallback = function () {
                        var h3 = hW.getCurrentMaxTilt();
                        if (hW._tilt > h3) {
                            hW._tilt = h3
                        }
                        var h4 = hW.fixPixel;
                        if (!hW.fixPixel || !hW.fixPoint) {
                            return
                        }
                        var h0 = hW.fixPixel;
                        var ia = hW.fixPoint;
                        var h7 = hW.fixCenter;
                        var h5 = hW.mousePosMCPoint;
                        if (hW._heading % 360 !== 0 || hW._tilt > 0) {
                            var h1 = hW._webglMapCamera.fromScreenPixelToMC(h0.x, h0.y, {
                                center: h7,
                                zoom: hW.zoomLevel,
                                tilt: hW._tilt
                            });
                            if (h1) {
                                var h9 = h1.sub(h5);
                                var h2 = h7.sub(h9);
                                hW.centerPoint = hW.restrictCenter(h2)
                            }
                        } else {
                            var h6 = h0;
                            var h8 = hW.getZoomUnits();
                            var h2 = new ho(ia.lng - h8 * (h6.x - hW.width / 2), ia.lat + h8 * (h6.y - hW.height / 2));
                            hW.centerPoint = hW.restrictCenter(h2, h8)
                        }
                        hW.fire(new a8("oncenter_changed"))
                    }
                }
                if (hZ.fromMouseWheel === true) {
                    this._startInfiniteZoomAnimation(hZ);
                    hZ.callback && hZ.callback();
                    return
                }
                this._startAnimation(hZ)
            },
            _checkFireZoomend: function () {
                var e = this;
                if (e.fireZoomendTimer) {
                    clearTimeout(e.fireZoomendTimer)
                }
                e.fireZoomendTimer = setTimeout(function () {
                    if (e.zoomEventStatus === "zooming") {
                        e.fire(new a8("onzoomend"));
                        e.zoomEventStatus = "idle"
                    }
                    e.fireZoomendTimer = null
                }, 150)
            },
            deepZoomMedia: function (e) {
                var i = this;
                if (!i.temp.isStdCtrlBusy) {
                    i.temp.isStdCtrlBusy = true;
                    i.deepZoomTo(i.zoomLevel + e);
                    setTimeout(function () {
                        i.temp.isStdCtrlBusy = false
                    }, 400)
                }
            },
            deepZoomTo: function (e) {
                this.zoomTo(e)
            },
            flyToIn: function (T, ii, h2) {
                h2 = h2 || {};
                var hO = this._getProperZoom(ii);
                ii = hO.zoom;
                if (this.centerPoint.equals(T) && this.zoomLevel === ii && typeof h2.heading !== "number" && typeof h2.tilt !== "number") {
                    return
                }
                var e = this.getHeading() % 360;
                var hU = this.getTilt();
                var h0 = 0;
                var h4 = 0;
                var hX = this.getBounds().containsPoint(T);
                if (typeof h2.heading === "number") {
                    h0 = h2.heading
                } else {
                    if (hX) {
                        h0 = e
                    }
                } if (typeof h2.tilt === "number") {
                    h4 = h2.tilt
                } else {
                    if (hX) {
                        h4 = hU
                    }
                }
                this._heading = e;
                var ie = h0 - e;
                var ia = h4 - hU;
                var hY = this;
                var hQ = this.zoomLevel;
                var hR = 1.42;
                var h6 = this.zoomScale(ii - hQ);
                var ik = this.getZoomUnits();
                var hW = this.centerPoint.div(ik);
                var il = T.div(ik);
                var id = this.worldSize();
                var h9 = hR;
                var h8 = Math.max(this.width, this.height);
                var h7 = h8 / h6;
                var hV = il.sub(hW).mag();
                var i = h9 * h9;

                function ih(io) {
                    var im = (h7 * h7 - h8 * h8 + (io ? -1 : 1) * i * i * hV * hV) / (2 * (io ? h7 : h8) * i * hV);
                    return Math.log(Math.sqrt(im * im + 1) - im)
                }

                function hN(im) {
                    return (Math.exp(im) - Math.exp(-im)) / 2
                }

                function hS(im) {
                    return (Math.exp(im) + Math.exp(-im)) / 2
                }

                function h1(im) {
                    return hN(im) / hS(im)
                }
                var hT = ih(0);
                var ib = function (im) {
                    return (hS(hT) / hS(hT + h9 * im))
                };
                var ic = function (im) {
                    return h8 * ((hS(hT) * h1(hT + h9 * im) - hN(hT)) / i) / hV
                };
                var hP = (ih(1) - hT) / h9;
                if (Math.abs(hV) < 0.000001 || hP === Infinity || isNaN(hP)) {
                    if (Math.abs(h8 - h7) < 0.000001) {
                        this._animationInfo.zoom = {
                            current: this.zoomLevel,
                            diff: ii - this.zoomLevel
                        };
                        this._animationInfo.center = {
                            current: this.centerPoint,
                            diff: T.sub(this.centerPoint)
                        };
                        this._animationInfo.heading = {
                            current: e,
                            diff: h0 - e
                        };
                        this._animationInfo.tilt = {
                            current: hU,
                            diff: h4 - hU
                        };
                        this.setLock(true);
                        this._startAnimation({
                            callback: function (im) {
                                hY.setLock(false);
                                if (h2.callback) {
                                    h2.callback(im)
                                }
                            },
                            duration: h2.duration
                        });
                        return
                    }
                    var ij = h7 < h8 ? -1 : 1;
                    hP = Math.abs(Math.log(h7 / h8)) / h9;
                    ic = function () {
                        return 0
                    };
                    ib = function (im) {
                        return Math.exp(ij * h9 * im)
                    }
                }
                var ig = 1.7;
                if (hP < 0.3) {
                    ig = 0.8
                } else {
                    if (hP > 5) {
                        ig = (hP - 5) / 2 + ig
                    }
                }
                var h3 = h2.duration || 1000 * hP / ig;
                if (isNaN(h3)) {
                    var h5 = {};
                    for (var hZ in h2) {
                        h5[hZ] = h2[hZ];
                        h5.noAnimation = true
                    }
                    this.centerAndZoomIn(T, ii, h5);
                    return
                }
                this.fire(new a8("onmovestart"));
                this.fire(new a8("onzoomstart"));
                this.setLock(true);
                this._startAnimation({
                    duration: h3,
                    renderCallback: function (im, io) {
                        var ip = im * hP;
                        var it = ic(ip);
                        var ir = hQ + hY.scaleZoom(1 / ib(ip));
                        if (ir < hY.getMinZoom()) {
                            ir = hY.getMinZoom()
                        }
                        if (ir > hY.getMaxZoom()) {
                            ir = hY.getMaxZoom()
                        }
                        if (ir !== hY.zoomLevel) {
                            hY.zoomLevel = ir;
                            hY.fire(new a8("onzoom_changed"))
                        }
                        hY.centerPoint = hW.add(il.sub(hW).mult(it)).mult(ik);
                        hY.fire(new a8("oncenter_changed"));
                        if (typeof h0 === "number") {
                            var iq = im / 0.7;
                            if (iq > 1) {
                                iq = 1
                            }
                            hY.setHeading(e + ie * im, {
                                noAnimation: true
                            })
                        }
                        if (typeof h4 === "number") {
                            hY.setTilt(hU + ia * im, {
                                noAnimation: true
                            })
                        }
                    },
                    callback: function (im, io) {
                        hY.setLock(false);
                        if (io && io.stop === true) {
                            hY.fire(new a8("onmoveend"));
                            hY.fire(new a8("onzoomend"));
                            h2.callback && h2.callback(im);
                            return
                        }
                        if (ii !== hY.zoomLevel) {
                            hY.zoomLevel = ii;
                            hY.fire(new a8("onzoom_changed"))
                        }
                        hY.fire(new a8("onmoveend"));
                        hY.fire(new a8("onzoomend"));
                        h2.callback && h2.callback(im)
                    }
                })
            },
            zoomScale: function (e) {
                return Math.pow(2, e)
            },
            scaleZoom: function (e) {
                return Math.log(e) / Math.LN2
            },
            panToIn: function (i, T) {
                T = T || {};
                if (!i || i.equals(this.centerPoint)) {
                    T.callback && T.callback();
                    return
                }
                var hN = this.pointToPixelIn(i);
                var e = Math.round(this.width / 2);
                var hP = Math.round(this.height / 2);
                var hO = this._ifUseAnimation(i, this.zoomLevel);
                if (T.noAnimation === true || hO === false) {
                    this._stopAllAnimations();
                    this._panToIn(e - hN.x, hP - hN.y, i);
                    T.callback && T.callback();
                    return
                }
                this.flyToIn(i, this.zoomLevel, T)
            },
            _panToIn: function (i, e, hN) {
                var T = this.temp;
                if (T.operating === true) {
                    return
                }
                if (T.dragAni) {
                    T.dragAni.stop(false, {
                        readyToMove: true
                    });
                    T.dragAni = null
                }
                this.dispatchEvent(new a8("onmovestart"));
                this._setPlatformPosition(i, e, {
                    point: hN
                });
                this.dispatchEvent(new a8("onmoveend"))
            },
            _stopAllAnimations: function (e) {
                e = e || {};
                if (this._ani) {
                    this._ani.stop(!!e.goToEnd, {
                        stopCurrentAnimation: e.stopCurrentAnimation
                    });
                    this._ani = null
                }
                if (this._infiniteAni) {
                    this._infiniteAni.stop();
                    this._infiniteAni = null
                }
            },
            panBy: function (i, e, T) {
                i = Math.round(i) || 0;
                e = Math.round(e) || 0;
                T = T || {};
                if (Math.abs(i) <= this.width && Math.abs(e) <= this.height && T.noAnimation !== true) {
                    this._panBy(i, e, T)
                } else {
                    this._panToIn(i, e, T.point);
                    T.callback && T.callback()
                }
            },
            _panBy: function (i, e, hO) {
                if (this.temp.operating === true) {
                    return
                }
                hO = hO || {};
                this.dispatchEvent(new a8("onmovestart"));
                var hN = this;
                var T = hN.temp;
                T.pl = hN.offsetX;
                T.pt = hN.offsetY;
                if (T.tlPan) {
                    T.tlPan.cancel()
                }
                if (T.dragAni) {
                    T.dragAni.stop(false, {
                        readyToMove: true
                    });
                    T.dragAni = null
                }
                T.tlPan = new o({
                    fps: hO.fps || hN.config.fps,
                    duration: hO.duration || hN.config.actionDuration,
                    transition: hO.transition || ck.easeInOutQuad,
                    render: function (hP) {
                        this.terminative = hN.temp.operating;
                        if (hN.temp.operating) {
                            return
                        }
                        hN._setPlatformPosition(i * hP, e * hP, {
                            initMapOffsetX: T.pl,
                            initMapOffsetY: T.pt
                        })
                    },
                    finish: function (hP) {
                        hN.dispatchEvent(new a8("onmoveend"));
                        hN.temp.tlPan = false;
                        if (hN.temp.stopArrow === true) {
                            hN.temp.stopArrow = false;
                            if (hN.temp.arrow !== 0) {
                                hN._arrow()
                            }
                        }
                    }
                })
            },
            _startAnimation: function (i) {
                var hO = this._animationInfo;
                var T = this;
                i = i || {};
                if (T._ani) {
                    T._ani.stop(!!i.goToEnd, {
                        stopCurrentAnimation: i.stopCurrentAnimation
                    })
                }
                if (T._infiniteAni) {
                    T._infiniteAni.stop();
                    T._infiniteAni = null
                }
                var hP = i.duration || 500;
                var hQ = i.transition || ck.ease;
                var e = new a8("onanimation_start");
                this.fire(e);
                if (i.unstopable) {
                    hO = this._animationInfoUnstopable
                }
                var hN = new o({
                    duration: hP,
                    transition: hQ,
                    render: function (hT, hS) {
                        for (var hR in hO) {
                            if (!hO.hasOwnProperty(hR)) {
                                continue
                            }
                            var hV = hO[hR].current;
                            var hU = hO[hR].diff;
                            T._setValueTick(hR, hV, hU, hT)
                        }
                        if (i.renderCallback) {
                            i.renderCallback(hT, hS)
                        }
                    },
                    finish: function (hR) {
                        T.fire(new a8("onanimation_end"));
                        if (i.unstopable) {
                            T._animationInfoUnstopable = {};
                            T._unstopableAni = null
                        } else {
                            T._ani = null;
                            T._animationInfo = {}
                        } if (i.mapNeedCbk) {
                            i.mapNeedCbk()
                        }
                        if (i.callback) {
                            i.callback(hR)
                        }
                    },
                    onStop: function (hR) {
                        hR = hR || {};
                        T.fire(new a8("onanimation_end"));
                        if (hR.stopCurrentAnimation) {
                            T._animationInfo = {}
                        }
                        T._ani = null;
                        if (i.mapNeedCbk) {
                            i.mapNeedCbk()
                        }
                        if (i.callback) {
                            i.callback(null, {
                                stop: true
                            })
                        }
                    }
                });
                if (i.unstopable) {
                    T._unstopableAni = hN
                } else {
                    T._ani = hN
                }
            },
            _startInfiniteZoomAnimation: function (e) {
                var i = this;
                if (i._ani) {
                    i._ani.stop(!!e.goToEnd, {
                        stopCurrentAnimation: e.stopCurrentAnimation
                    })
                }
                if (i._infiniteAni) {
                    return
                }
                this.fire(new a8("onanimation_start"));
                i._infiniteAni = new o({
                    duration: 10000,
                    transition: ck.linear,
                    render: function () {
                        var T = i._animationInfo.zoom;
                        if (Math.abs(T.current - T.target) < 0.001) {
                            i._setValue("zoom", T.target);
                            i._infiniteAni.stop();
                            return
                        }
                        T.current += (T.target - T.current) * 0.35;
                        i._setValue("zoom", T.current);
                        if (e.renderCallback) {
                            e.renderCallback()
                        }
                    },
                    finish: function () {
                        i._infiniteAni = null;
                        i._animationInfo = {};
                        i.fire(new a8("onanimation_end"));
                        if (e.callback) {
                            e.callback()
                        }
                    },
                    onStop: function () {
                        i._infiniteAni = null;
                        i._animationInfo = {};
                        i.fire(new a8("onanimation_end"));
                        if (e.callback) {
                            e.callback()
                        }
                    }
                })
            },
            _setValue: function (e, T) {
                if (e === "zoom") {
                    this._preZoomLevel = this.zoomLevel;
                    var i = this._getProperZoom(T);
                    T = i.zoom;
                    if (T !== this.zoomLevel) {
                        this.zoomLevel = T;
                        if (T < 5) {
                            this.restrictCenter(this.centerPoint)
                        }
                        this.fire(new a8("on" + e + "_changed"))
                    }
                    return
                } else {
                    if (e === "center") {
                        this.centerPoint = T
                    }
                }
                this["_" + e] = T;
                this.fire(new a8("on" + e + "_changed"))
            },
            _setValueTick: function (e, hO, hN, i) {
                if (e === "center") {
                    var T = new ho(hO.lng + hN.lng * i, hO.lat + hN.lat * i);
                    this._setValue(e, T);
                    return
                }
                if (e === "zoom") {
                    this._setValue(e, Math.pow(hO, 1 - i) * Math.pow(hO + hN, i));
                    return
                }
                this._setValue(e, hO + hN * i)
            },
            setHeading: function (hN, i) {
                i = i || {};
                if (hN === this._heading) {
                    i.callback && i.callback();
                    return
                }
                var T = fW(this._heading, 360);
                var e = fW(hN, 360);
                if (e === T) {
                    this._heading = hN;
                    i.callback && i.callback();
                    return
                }
                if (i.noAnimation) {
                    this._setValue("heading", hN);
                    i.callback && i.callback();
                    return
                }
                if (i.unstopable) {
                    this._animationInfoUnstopable.heading = {
                        current: this._heading,
                        diff: hN - this._heading
                    }
                } else {
                    this._animationInfo.heading = {
                        current: this._heading,
                        diff: hN - this._heading
                    }
                }
                this._startAnimation(i)
            },
            resetHeading: function (e) {
                var i = this._heading;
                while (i < 0) {
                    i += 360
                }
                i = i % 360;
                if (i > 180) {
                    i -= 360
                }
                this._heading = i;
                e = e || {};
                e.unstopable = true;
                this.setHeading(0, e)
            },
            getHeading: function () {
                return this._heading
            },
            setTilt: function (e, i) {
                i = i || {};
                if (e === this._tilt) {
                    i.callback && i.callback();
                    return
                }
                if (e > c5.MAX_TILT) {
                    e = c5.MAX_TILT
                }
                if (e < c5.MIN_TILT) {
                    e = c5.MIN_TILT
                }
                if (i && i.noAnimation) {
                    this._setValue("tilt", e);
                    i.callback && i.callback();
                    return
                }
                this._animationInfo.tilt = {
                    current: this._tilt,
                    diff: e - this._tilt
                };
                this._startAnimation(i)
            },
            getTilt: function () {
                return this._tilt
            },
            getCenterIn: function () {
                return this.centerPoint
            },
            getZoom: function () {
                return this.zoomLevel
            },
            getCameraPosition: function (T) {
                T = T || {};
                var e = T.center || this.centerPoint;
                var hN = T.zoom || this.zoomLevel;
                var hQ = typeof T.heading === "number" ? T.heading : this._heading;
                var i = typeof T.tilt === "number" ? T.tilt : this._tilt;
                var hP = this._webglMapCamera.generateMVMatrix(e, hN, hQ, i);
                var hO = mat4.create(Float32Array);
                mat4.invert(hO, hP);
                return this._webglMapCamera.getPosition(hO)
            }
        });

        function fL(i) {
            this._jobQueue = [];
            this._idleOnlyJobQueue = [];
            var e = this;
            this.isIdle = true;
            i.on("updateframe", function (hN) {
                var T = 12 - hN.frameTime;
                T = T < 1 ? 1 : T;
                e.isIdle = false;
                if (e.idleWorkTimer) {
                    clearInterval(e.idleWorkTimer);
                    e.idleWorkTimer = null
                }
                e.runJobs(T)
            });
            this._idleWorkerTicker = (function (T) {
                return function () {
                    if (T.isIdle) {
                        T.runJobs();
                        T.runIdleOnlyJobs()
                    }
                }
            })(this);
            i.on("mapglidle", function () {
                e.isIdle = true;
                e.runJobs();
                e.runIdleOnlyJobs();
                e.idleWorkTimer = setInterval(e._idleWorkerTicker, fL.MAX_IDLE_TIME)
            })
        }
        fL.MAX_IDLE_TIME = 50;
        fL.MAX_FRAME_TIME = 6;
        fL.prototype.runJobs = function (i) {
            if (this._jobQueue.length === 0) {
                return
            }
            var hN = fx();
            var e = 0;
            i = i || fL.MAX_FRAME_TIME;
            while (this._jobQueue.length && e < i) {
                var T = this._jobQueue.shift();
                if (T.state !== "invalid") {
                    T.call()
                }
                e = fx() - hN
            }
        };
        fL.prototype.runIdleOnlyJobs = function () {
            if (this._idleOnlyJobQueue.length === 0) {
                return
            }
            var T = fx();
            var e = 0;
            while (this._idleOnlyJobQueue.length && e < fL.MAX_IDLE_TIME) {
                var i = this._idleOnlyJobQueue.shift();
                if (i.state !== "invalid") {
                    i.call()
                }
                e = fx() - T
            }
        };
        fL.prototype.checkIdleRunning = function () {
            if (this.isIdle && !this.idleWorkTimer) {
                this.runJobs();
                this.runIdleOnlyJobs();
                this.idleWorkTimer = setInterval(this._idleWorkerTicker, 50)
            }
        };
        fL.prototype.addJob = function (e) {
            this._jobQueue.push(e);
            this.checkIdleRunning()
        };
        fL.prototype.clearJobs = function () {
            this._jobQueue.length = 0;
            this._idleOnlyJobQueue.length = 0
        };
        fL.prototype.addIdleOnlyJob = function (e) {
            this._idleOnlyJobQueue.push(e);
            this.checkIdleRunning()
        };
        var b8 = {};
        (function (hQ) {
            if (!hU) {
                var hU = 0.000001
            }
            if (!i) {
                var i = (typeof Float32Array !== "undefined") ? Float32Array : Array
            }
            if (!hO) {
                var hO = Math.random
            }
            var T = {};
            var hP = Math.PI / 180;
            T.toRadian = function (hV) {
                return hV * hP
            };
            var hT = {};
            hT.create = function (hW) {
                hW = hW || i;
                var hV = new hW(2);
                hV[0] = 0;
                hV[1] = 0;
                return hV
            };
            hT.clone = function (hV, hX) {
                hX = hX || i;
                var hW = new hX(2);
                hW[0] = hV[0];
                hW[1] = hV[1];
                return hW
            };
            hT.fromValues = function (hV, hY, hX) {
                hX = hX || i;
                var hW = new hX(2);
                hW[0] = hV;
                hW[1] = hY;
                return hW
            };
            hT.copy = function (hW, hV) {
                hW[0] = hV[0];
                hW[1] = hV[1];
                return hW
            };
            hT.set = function (hW, hV, hX) {
                hW[0] = hV;
                hW[1] = hX;
                return hW
            };
            hT.add = function (hX, hW, hV) {
                hX[0] = hW[0] + hV[0];
                hX[1] = hW[1] + hV[1];
                return hX
            };
            hT.subtract = function (hX, hW, hV) {
                hX[0] = hW[0] - hV[0];
                hX[1] = hW[1] - hV[1];
                return hX
            };
            hT.sub = hT.subtract;
            hT.multiply = function (hX, hW, hV) {
                hX[0] = hW[0] * hV[0];
                hX[1] = hW[1] * hV[1];
                return hX
            };
            hT.mul = hT.multiply;
            hT.divide = function (hX, hW, hV) {
                hX[0] = hW[0] / hV[0];
                hX[1] = hW[1] / hV[1];
                return hX
            };
            hT.div = hT.divide;
            hT.min = function (hX, hW, hV) {
                hX[0] = Math.min(hW[0], hV[0]);
                hX[1] = Math.min(hW[1], hV[1]);
                return hX
            };
            hT.max = function (hX, hW, hV) {
                hX[0] = Math.max(hW[0], hV[0]);
                hX[1] = Math.max(hW[1], hV[1]);
                return hX
            };
            hT.scale = function (hX, hW, hV) {
                hX[0] = hW[0] * hV;
                hX[1] = hW[1] * hV;
                return hX
            };
            hT.scaleAndAdd = function (hX, hW, hV, hY) {
                hX[0] = hW[0] + (hV[0] * hY);
                hX[1] = hW[1] + (hV[1] * hY);
                return hX
            };
            hT.distance = function (hX, hW) {
                var hV = hW[0] - hX[0],
                    hY = hW[1] - hX[1];
                return Math.sqrt(hV * hV + hY * hY)
            };
            hT.dist = hT.distance;
            hT.squaredDistance = function (hX, hW) {
                var hV = hW[0] - hX[0],
                    hY = hW[1] - hX[1];
                return hV * hV + hY * hY
            };
            hT.sqrDist = hT.squaredDistance;
            hT.length = function (hW) {
                var hV = hW[0],
                    hX = hW[1];
                return Math.sqrt(hV * hV + hX * hX)
            };
            hT.len = hT.length;
            hT.squaredLength = function (hW) {
                var hV = hW[0],
                    hX = hW[1];
                return hV * hV + hX * hX
            };
            hT.sqrLen = hT.squaredLength;
            hT.negate = function (hW, hV) {
                hW[0] = -hV[0];
                hW[1] = -hV[1];
                return hW
            };
            hT.normalize = function (hY, hX) {
                var hW = hX[0],
                    hZ = hX[1];
                var hV = hW * hW + hZ * hZ;
                if (hV > 0) {
                    hV = 1 / Math.sqrt(hV);
                    hY[0] = hX[0] * hV;
                    hY[1] = hX[1] * hV
                }
                return hY
            };
            hT.dot = function (hW, hV) {
                return hW[0] * hV[0] + hW[1] * hV[1]
            };
            hT.cross = function (hX, hW, hV) {
                var hY = hW[0] * hV[1] - hW[1] * hV[0];
                hX[0] = hX[1] = 0;
                hX[2] = hY;
                return hX
            };
            hT.lerp = function (hX, hW, hV, hY) {
                var h0 = hW[0],
                    hZ = hW[1];
                hX[0] = h0 + hY * (hV[0] - h0);
                hX[1] = hZ + hY * (hV[1] - hZ);
                return hX
            };
            hT.random = function (hV, hX) {
                hX = hX || 1;
                var hW = hO() * 2 * Math.PI;
                hV[0] = Math.cos(hW) * hX;
                hV[1] = Math.sin(hW) * hX;
                return hV
            };
            hT.transformMat2 = function (hY, hX, hW) {
                var hV = hX[0],
                    hZ = hX[1];
                hY[0] = hW[0] * hV + hW[2] * hZ;
                hY[1] = hW[1] * hV + hW[3] * hZ;
                return hY
            };
            hT.transformMat2d = function (hY, hX, hW) {
                var hV = hX[0],
                    hZ = hX[1];
                hY[0] = hW[0] * hV + hW[2] * hZ + hW[4];
                hY[1] = hW[1] * hV + hW[3] * hZ + hW[5];
                return hY
            };
            hT.transformMat3 = function (hY, hX, hW) {
                var hV = hX[0],
                    hZ = hX[1];
                hY[0] = hW[0] * hV + hW[3] * hZ + hW[6];
                hY[1] = hW[1] * hV + hW[4] * hZ + hW[7];
                return hY
            };
            hT.transformMat4 = function (hY, hX, hW) {
                var hV = hX[0],
                    hZ = hX[1];
                hY[0] = hW[0] * hV + hW[4] * hZ + hW[12];
                hY[1] = hW[1] * hV + hW[5] * hZ + hW[13];
                return hY
            };
            hT.rotate = function (hY, hW, hV, h2) {
                var h1 = hW[0] - hV[0];
                var h0 = hW[1] - hV[1];
                var hX = Math.sin(h2);
                var hZ = Math.cos(h2);
                hY[0] = h1 * hZ - h0 * hX + hV[0];
                hY[1] = h1 * hX + h0 * hZ + hV[1];
                return hY
            };
            hT.forEach = (function () {
                var hV = hT.create();
                return function (hY, h2, h3, h1, h0, hW) {
                    var hZ, hX;
                    if (!h2) {
                        h2 = 2
                    }
                    if (!h3) {
                        h3 = 0
                    }
                    if (h1) {
                        hX = Math.min((h1 * h2) + h3, hY.length)
                    } else {
                        hX = hY.length
                    }
                    for (hZ = h3; hZ < hX; hZ += h2) {
                        hV[0] = hY[hZ];
                        hV[1] = hY[hZ + 1];
                        h0(hV, hV, hW);
                        hY[hZ] = hV[0];
                        hY[hZ + 1] = hV[1]
                    }
                    return hY
                }
            })();
            hT.str = function (hV) {
                return "vec2(" + hV[0] + ", " + hV[1] + ")"
            };
            hQ.vec2 = hT;
            var hS = {};
            hS.create = function (hW) {
                hW = hW || i;
                var hV = new hW(3);
                hV[0] = 0;
                hV[1] = 0;
                hV[2] = 0;
                return hV
            };
            hS.clone = function (hV, hX) {
                hX = hX || i;
                var hW = new hX(3);
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                return hW
            };
            hS.fromValues = function (hV, hZ, hX, hY) {
                hY = hY || i;
                var hW = new hY(3);
                hW[0] = hV;
                hW[1] = hZ;
                hW[2] = hX;
                return hW
            };
            hS.copy = function (hW, hV) {
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                return hW
            };
            hS.set = function (hW, hV, hY, hX) {
                hW[0] = hV;
                hW[1] = hY;
                hW[2] = hX;
                return hW
            };
            hS.add = function (hX, hW, hV) {
                hX[0] = hW[0] + hV[0];
                hX[1] = hW[1] + hV[1];
                hX[2] = hW[2] + hV[2];
                return hX
            };
            hS.subtract = function (hX, hW, hV) {
                hX[0] = hW[0] - hV[0];
                hX[1] = hW[1] - hV[1];
                hX[2] = hW[2] - hV[2];
                return hX
            };
            hS.sub = hS.subtract;
            hS.multiply = function (hX, hW, hV) {
                hX[0] = hW[0] * hV[0];
                hX[1] = hW[1] * hV[1];
                hX[2] = hW[2] * hV[2];
                return hX
            };
            hS.mul = hS.multiply;
            hS.divide = function (hX, hW, hV) {
                hX[0] = hW[0] / hV[0];
                hX[1] = hW[1] / hV[1];
                hX[2] = hW[2] / hV[2];
                return hX
            };
            hS.div = hS.divide;
            hS.min = function (hX, hW, hV) {
                hX[0] = Math.min(hW[0], hV[0]);
                hX[1] = Math.min(hW[1], hV[1]);
                hX[2] = Math.min(hW[2], hV[2]);
                return hX
            };
            hS.max = function (hX, hW, hV) {
                hX[0] = Math.max(hW[0], hV[0]);
                hX[1] = Math.max(hW[1], hV[1]);
                hX[2] = Math.max(hW[2], hV[2]);
                return hX
            };
            hS.scale = function (hX, hW, hV) {
                hX[0] = hW[0] * hV;
                hX[1] = hW[1] * hV;
                hX[2] = hW[2] * hV;
                return hX
            };
            hS.scaleAndAdd = function (hX, hW, hV, hY) {
                hX[0] = hW[0] + (hV[0] * hY);
                hX[1] = hW[1] + (hV[1] * hY);
                hX[2] = hW[2] + (hV[2] * hY);
                return hX
            };
            hS.distance = function (hX, hW) {
                var hV = hW[0] - hX[0],
                    hZ = hW[1] - hX[1],
                    hY = hW[2] - hX[2];
                return Math.sqrt(hV * hV + hZ * hZ + hY * hY)
            };
            hS.dist = hS.distance;
            hS.squaredDistance = function (hX, hW) {
                var hV = hW[0] - hX[0],
                    hZ = hW[1] - hX[1],
                    hY = hW[2] - hX[2];
                return hV * hV + hZ * hZ + hY * hY
            };
            hS.sqrDist = hS.squaredDistance;
            hS.length = function (hW) {
                var hV = hW[0],
                    hY = hW[1],
                    hX = hW[2];
                return Math.sqrt(hV * hV + hY * hY + hX * hX)
            };
            hS.len = hS.length;
            hS.squaredLength = function (hW) {
                var hV = hW[0],
                    hY = hW[1],
                    hX = hW[2];
                return hV * hV + hY * hY + hX * hX
            };
            hS.sqrLen = hS.squaredLength;
            hS.negate = function (hW, hV) {
                hW[0] = -hV[0];
                hW[1] = -hV[1];
                hW[2] = -hV[2];
                return hW
            };
            hS.normalize = function (hY, hX) {
                var hW = hX[0],
                    h0 = hX[1],
                    hZ = hX[2];
                var hV = hW * hW + h0 * h0 + hZ * hZ;
                if (hV > 0) {
                    hV = 1 / Math.sqrt(hV);
                    hY[0] = hX[0] * hV;
                    hY[1] = hX[1] * hV;
                    hY[2] = hX[2] * hV
                }
                return hY
            };
            hS.dot = function (hW, hV) {
                return hW[0] * hV[0] + hW[1] * hV[1] + hW[2] * hV[2]
            };
            hS.cross = function (hW, h1, h0) {
                var hV = h1[0],
                    h3 = h1[1],
                    h2 = h1[2],
                    hZ = h0[0],
                    hY = h0[1],
                    hX = h0[2];
                hW[0] = h3 * hX - h2 * hY;
                hW[1] = h2 * hZ - hV * hX;
                hW[2] = hV * hY - h3 * hZ;
                return hW
            };
            hS.lerp = function (hX, hW, hV, hY) {
                var h1 = hW[0],
                    h0 = hW[1],
                    hZ = hW[2];
                hX[0] = h1 + hY * (hV[0] - h1);
                hX[1] = h0 + hY * (hV[1] - h0);
                hX[2] = hZ + hY * (hV[2] - hZ);
                return hX
            };
            hS.random = function (hV, hZ) {
                hZ = hZ || 1;
                var hX = hO() * 2 * Math.PI;
                var hY = (hO() * 2) - 1;
                var hW = Math.sqrt(1 - hY * hY) * hZ;
                hV[0] = Math.cos(hX) * hW;
                hV[1] = Math.sin(hX) * hW;
                hV[2] = hY * hZ;
                return hV
            };
            hS.transformMat4 = function (hY, hX, hW) {
                var hV = hX[0],
                    h0 = hX[1],
                    hZ = hX[2];
                hY[0] = hW[0] * hV + hW[4] * h0 + hW[8] * hZ + hW[12];
                hY[1] = hW[1] * hV + hW[5] * h0 + hW[9] * hZ + hW[13];
                hY[2] = hW[2] * hV + hW[6] * h0 + hW[10] * hZ + hW[14];
                return hY
            };
            hS.transformMat3 = function (hY, hX, hW) {
                var hV = hX[0],
                    h0 = hX[1],
                    hZ = hX[2];
                hY[0] = hV * hW[0] + h0 * hW[3] + hZ * hW[6];
                hY[1] = hV * hW[1] + h0 * hW[4] + hZ * hW[7];
                hY[2] = hV * hW[2] + h0 * hW[5] + hZ * hW[8];
                return hY
            };
            hS.transformQuat = function (h1, h7, hV) {
                var h8 = h7[0],
                    h6 = h7[1],
                    h5 = h7[2],
                    h3 = hV[0],
                    h2 = hV[1],
                    h0 = hV[2],
                    h4 = hV[3],
                    hY = h4 * h8 + h2 * h5 - h0 * h6,
                    hX = h4 * h6 + h0 * h8 - h3 * h5,
                    hW = h4 * h5 + h3 * h6 - h2 * h8,
                    hZ = -h3 * h8 - h2 * h6 - h0 * h5;
                h1[0] = hY * h4 + hZ * -h3 + hX * -h0 - hW * -h2;
                h1[1] = hX * h4 + hZ * -h2 + hW * -h3 - hY * -h0;
                h1[2] = hW * h4 + hZ * -h0 + hY * -h2 - hX * -h3;
                return h1
            };
            hS.rotateX = function (hX, hW, hV, h0) {
                var hZ = [],
                    hY = [];
                hZ[0] = hW[0] - hV[0];
                hZ[1] = hW[1] - hV[1];
                hZ[2] = hW[2] - hV[2];
                hY[0] = hZ[0];
                hY[1] = hZ[1] * Math.cos(h0) - hZ[2] * Math.sin(h0);
                hY[2] = hZ[1] * Math.sin(h0) + hZ[2] * Math.cos(h0);
                hX[0] = hY[0] + hV[0];
                hX[1] = hY[1] + hV[1];
                hX[2] = hY[2] + hV[2];
                return hX
            };
            hS.rotateY = function (hX, hW, hV, h0) {
                var hZ = [],
                    hY = [];
                hZ[0] = hW[0] - hV[0];
                hZ[1] = hW[1] - hV[1];
                hZ[2] = hW[2] - hV[2];
                hY[0] = hZ[2] * Math.sin(h0) + hZ[0] * Math.cos(h0);
                hY[1] = hZ[1];
                hY[2] = hZ[2] * Math.cos(h0) - hZ[0] * Math.sin(h0);
                hX[0] = hY[0] + hV[0];
                hX[1] = hY[1] + hV[1];
                hX[2] = hY[2] + hV[2];
                return hX
            };
            hS.rotateZ = function (hX, hW, hV, h0) {
                var hZ = [],
                    hY = [];
                hZ[0] = hW[0] - hV[0];
                hZ[1] = hW[1] - hV[1];
                hZ[2] = hW[2] - hV[2];
                hY[0] = hZ[0] * Math.cos(h0) - hZ[1] * Math.sin(h0);
                hY[1] = hZ[0] * Math.sin(h0) + hZ[1] * Math.cos(h0);
                hY[2] = hZ[2];
                hX[0] = hY[0] + hV[0];
                hX[1] = hY[1] + hV[1];
                hX[2] = hY[2] + hV[2];
                return hX
            };
            hS.forEach = (function () {
                var hV = hS.create();
                return function (hY, h2, h3, h1, h0, hW) {
                    var hZ, hX;
                    if (!h2) {
                        h2 = 3
                    }
                    if (!h3) {
                        h3 = 0
                    }
                    if (h1) {
                        hX = Math.min((h1 * h2) + h3, hY.length)
                    } else {
                        hX = hY.length
                    }
                    for (hZ = h3; hZ < hX; hZ += h2) {
                        hV[0] = hY[hZ];
                        hV[1] = hY[hZ + 1];
                        hV[2] = hY[hZ + 2];
                        h0(hV, hV, hW);
                        hY[hZ] = hV[0];
                        hY[hZ + 1] = hV[1];
                        hY[hZ + 2] = hV[2]
                    }
                    return hY
                }
            })();
            hS.str = function (hV) {
                return "vec3(" + hV[0] + ", " + hV[1] + ", " + hV[2] + ")"
            };
            hQ.vec3 = hS;
            var hR = {};
            hR.create = function (hW) {
                hW = hW || i;
                var hV = new hW(4);
                hV[0] = 0;
                hV[1] = 0;
                hV[2] = 0;
                hV[3] = 0;
                return hV
            };
            hR.clone = function (hV, hX) {
                hX = hX || i;
                var hW = new hX(4);
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                hW[3] = hV[3];
                return hW
            };
            hR.fromValues = function (hV, h0, hY, hW, hZ) {
                hZ = hZ || i;
                var hX = new hZ(4);
                hX[0] = hV;
                hX[1] = h0;
                hX[2] = hY;
                hX[3] = hW;
                return hX
            };
            hR.copy = function (hW, hV) {
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                hW[3] = hV[3];
                return hW
            };
            hR.set = function (hX, hV, hZ, hY, hW) {
                hX[0] = hV;
                hX[1] = hZ;
                hX[2] = hY;
                hX[3] = hW;
                return hX
            };
            hR.add = function (hX, hW, hV) {
                hX[0] = hW[0] + hV[0];
                hX[1] = hW[1] + hV[1];
                hX[2] = hW[2] + hV[2];
                hX[3] = hW[3] + hV[3];
                return hX
            };
            hR.subtract = function (hX, hW, hV) {
                hX[0] = hW[0] - hV[0];
                hX[1] = hW[1] - hV[1];
                hX[2] = hW[2] - hV[2];
                hX[3] = hW[3] - hV[3];
                return hX
            };
            hR.sub = hR.subtract;
            hR.multiply = function (hX, hW, hV) {
                hX[0] = hW[0] * hV[0];
                hX[1] = hW[1] * hV[1];
                hX[2] = hW[2] * hV[2];
                hX[3] = hW[3] * hV[3];
                return hX
            };
            hR.mul = hR.multiply;
            hR.divide = function (hX, hW, hV) {
                hX[0] = hW[0] / hV[0];
                hX[1] = hW[1] / hV[1];
                hX[2] = hW[2] / hV[2];
                hX[3] = hW[3] / hV[3];
                return hX
            };
            hR.div = hR.divide;
            hR.min = function (hX, hW, hV) {
                hX[0] = Math.min(hW[0], hV[0]);
                hX[1] = Math.min(hW[1], hV[1]);
                hX[2] = Math.min(hW[2], hV[2]);
                hX[3] = Math.min(hW[3], hV[3]);
                return hX
            };
            hR.max = function (hX, hW, hV) {
                hX[0] = Math.max(hW[0], hV[0]);
                hX[1] = Math.max(hW[1], hV[1]);
                hX[2] = Math.max(hW[2], hV[2]);
                hX[3] = Math.max(hW[3], hV[3]);
                return hX
            };
            hR.scale = function (hX, hW, hV) {
                hX[0] = hW[0] * hV;
                hX[1] = hW[1] * hV;
                hX[2] = hW[2] * hV;
                hX[3] = hW[3] * hV;
                return hX
            };
            hR.scaleAndAdd = function (hX, hW, hV, hY) {
                hX[0] = hW[0] + (hV[0] * hY);
                hX[1] = hW[1] + (hV[1] * hY);
                hX[2] = hW[2] + (hV[2] * hY);
                hX[3] = hW[3] + (hV[3] * hY);
                return hX
            };
            hR.distance = function (hY, hW) {
                var hV = hW[0] - hY[0],
                    h0 = hW[1] - hY[1],
                    hZ = hW[2] - hY[2],
                    hX = hW[3] - hY[3];
                return Math.sqrt(hV * hV + h0 * h0 + hZ * hZ + hX * hX)
            };
            hR.dist = hR.distance;
            hR.squaredDistance = function (hY, hW) {
                var hV = hW[0] - hY[0],
                    h0 = hW[1] - hY[1],
                    hZ = hW[2] - hY[2],
                    hX = hW[3] - hY[3];
                return hV * hV + h0 * h0 + hZ * hZ + hX * hX
            };
            hR.sqrDist = hR.squaredDistance;
            hR.length = function (hX) {
                var hV = hX[0],
                    hZ = hX[1],
                    hY = hX[2],
                    hW = hX[3];
                return Math.sqrt(hV * hV + hZ * hZ + hY * hY + hW * hW)
            };
            hR.len = hR.length;
            hR.squaredLength = function (hX) {
                var hV = hX[0],
                    hZ = hX[1],
                    hY = hX[2],
                    hW = hX[3];
                return hV * hV + hZ * hZ + hY * hY + hW * hW
            };
            hR.sqrLen = hR.squaredLength;
            hR.negate = function (hW, hV) {
                hW[0] = -hV[0];
                hW[1] = -hV[1];
                hW[2] = -hV[2];
                hW[3] = -hV[3];
                return hW
            };
            hR.normalize = function (hZ, hY) {
                var hW = hY[0],
                    h1 = hY[1],
                    h0 = hY[2],
                    hX = hY[3];
                var hV = hW * hW + h1 * h1 + h0 * h0 + hX * hX;
                if (hV > 0) {
                    hV = 1 / Math.sqrt(hV);
                    hZ[0] = hY[0] * hV;
                    hZ[1] = hY[1] * hV;
                    hZ[2] = hY[2] * hV;
                    hZ[3] = hY[3] * hV
                }
                return hZ
            };
            hR.dot = function (hW, hV) {
                return hW[0] * hV[0] + hW[1] * hV[1] + hW[2] * hV[2] + hW[3] * hV[3]
            };
            hR.lerp = function (hX, hW, hV, hY) {
                var h1 = hW[0],
                    h0 = hW[1],
                    hZ = hW[2],
                    h2 = hW[3];
                hX[0] = h1 + hY * (hV[0] - h1);
                hX[1] = h0 + hY * (hV[1] - h0);
                hX[2] = hZ + hY * (hV[2] - hZ);
                hX[3] = h2 + hY * (hV[3] - h2);
                return hX
            };
            hR.random = function (hV, hW) {
                hW = hW || 1;
                hV[0] = hO();
                hV[1] = hO();
                hV[2] = hO();
                hV[3] = hO();
                hR.normalize(hV, hV);
                hR.scale(hV, hV, hW);
                return hV
            };
            hR.transformMat4 = function (hZ, hY, hW) {
                var hV = hY[0],
                    h1 = hY[1],
                    h0 = hY[2],
                    hX = hY[3];
                hZ[0] = hW[0] * hV + hW[4] * h1 + hW[8] * h0 + hW[12] * hX;
                hZ[1] = hW[1] * hV + hW[5] * h1 + hW[9] * h0 + hW[13] * hX;
                hZ[2] = hW[2] * hV + hW[6] * h1 + hW[10] * h0 + hW[14] * hX;
                hZ[3] = hW[3] * hV + hW[7] * h1 + hW[11] * h0 + hW[15] * hX;
                return hZ
            };
            hR.transformQuat = function (h1, h7, hV) {
                var h8 = h7[0],
                    h6 = h7[1],
                    h5 = h7[2],
                    h3 = hV[0],
                    h2 = hV[1],
                    h0 = hV[2],
                    h4 = hV[3],
                    hY = h4 * h8 + h2 * h5 - h0 * h6,
                    hX = h4 * h6 + h0 * h8 - h3 * h5,
                    hW = h4 * h5 + h3 * h6 - h2 * h8,
                    hZ = -h3 * h8 - h2 * h6 - h0 * h5;
                h1[0] = hY * h4 + hZ * -h3 + hX * -h0 - hW * -h2;
                h1[1] = hX * h4 + hZ * -h2 + hW * -h3 - hY * -h0;
                h1[2] = hW * h4 + hZ * -h0 + hY * -h2 - hX * -h3;
                return h1
            };
            hR.forEach = (function () {
                var hV = hR.create();
                return function (hY, h2, h3, h1, h0, hW) {
                    var hZ, hX;
                    if (!h2) {
                        h2 = 4
                    }
                    if (!h3) {
                        h3 = 0
                    }
                    if (h1) {
                        hX = Math.min((h1 * h2) + h3, hY.length)
                    } else {
                        hX = hY.length
                    }
                    for (hZ = h3; hZ < hX; hZ += h2) {
                        hV[0] = hY[hZ];
                        hV[1] = hY[hZ + 1];
                        hV[2] = hY[hZ + 2];
                        hV[3] = hY[hZ + 3];
                        h0(hV, hV, hW);
                        hY[hZ] = hV[0];
                        hY[hZ + 1] = hV[1];
                        hY[hZ + 2] = hV[2];
                        hY[hZ + 3] = hV[3]
                    }
                    return hY
                }
            })();
            hR.str = function (hV) {
                return "vec4(" + hV[0] + ", " + hV[1] + ", " + hV[2] + ", " + hV[3] + ")"
            };
            hQ.vec4 = hR;
            var hN = {};
            hN.create = function (hW) {
                hW = hW || i;
                var hV = new hW(4);
                hV[0] = 1;
                hV[1] = 0;
                hV[2] = 0;
                hV[3] = 1;
                return hV
            };
            hN.clone = function (hV, hX) {
                hX = hX || i;
                var hW = new hX(4);
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                hW[3] = hV[3];
                return hW
            };
            hN.copy = function (hW, hV) {
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                hW[3] = hV[3];
                return hW
            };
            hN.identity = function (hV) {
                hV[0] = 1;
                hV[1] = 0;
                hV[2] = 0;
                hV[3] = 1;
                return hV
            };
            hN.transpose = function (hX, hW) {
                if (hX === hW) {
                    var hV = hW[1];
                    hX[1] = hW[2];
                    hX[2] = hV
                } else {
                    hX[0] = hW[0];
                    hX[1] = hW[2];
                    hX[2] = hW[1];
                    hX[3] = hW[3]
                }
                return hX
            };
            hN.invert = function (hZ, hX) {
                var hY = hX[0],
                    hW = hX[1],
                    hV = hX[2],
                    h1 = hX[3],
                    h0 = hY * h1 - hV * hW;
                if (!h0) {
                    return null
                }
                h0 = 1 / h0;
                hZ[0] = h1 * h0;
                hZ[1] = -hW * h0;
                hZ[2] = -hV * h0;
                hZ[3] = hY * h0;
                return hZ
            };
            hN.adjoint = function (hX, hV) {
                var hW = hV[0];
                hX[0] = hV[3];
                hX[1] = -hV[1];
                hX[2] = -hV[2];
                hX[3] = hW;
                return hX
            };
            hN.determinant = function (hV) {
                return hV[0] * hV[3] - hV[2] * hV[1]
            };
            hN.multiply = function (hZ, h4, h2) {
                var hY = h4[0],
                    hX = h4[1],
                    hW = h4[2],
                    hV = h4[3];
                var h5 = h2[0],
                    h3 = h2[1],
                    h1 = h2[2],
                    h0 = h2[3];
                hZ[0] = hY * h5 + hW * h3;
                hZ[1] = hX * h5 + hV * h3;
                hZ[2] = hY * h1 + hW * h0;
                hZ[3] = hX * h1 + hV * h0;
                return hZ
            };
            hN.mul = hN.multiply;
            hN.rotate = function (hZ, h2, h1) {
                var hY = h2[0],
                    hX = h2[1],
                    hW = h2[2],
                    hV = h2[3],
                    h3 = Math.sin(h1),
                    h0 = Math.cos(h1);
                hZ[0] = hY * h0 + hW * h3;
                hZ[1] = hX * h0 + hV * h3;
                hZ[2] = hY * -h3 + hW * h0;
                hZ[3] = hX * -h3 + hV * h0;
                return hZ
            };
            hN.scale = function (hZ, h0, h2) {
                var hY = h0[0],
                    hX = h0[1],
                    hW = h0[2],
                    hV = h0[3],
                    h3 = h2[0],
                    h1 = h2[1];
                hZ[0] = hY * h3;
                hZ[1] = hX * h3;
                hZ[2] = hW * h1;
                hZ[3] = hV * h1;
                return hZ
            };
            hN.str = function (hV) {
                return "mat2(" + hV[0] + ", " + hV[1] + ", " + hV[2] + ", " + hV[3] + ")"
            };
            hN.frob = function (hV) {
                return (Math.sqrt(Math.pow(hV[0], 2) + Math.pow(hV[1], 2) + Math.pow(hV[2], 2) + Math.pow(hV[3], 2)))
            };
            hN.LDU = function (hV, hY, hX, hW) {
                hV[2] = hW[2] / hW[0];
                hX[0] = hW[0];
                hX[1] = hW[1];
                hX[3] = hW[3] - hV[2] * hX[1];
                return [hV, hY, hX]
            };
            hQ.mat2 = hN;
            var e = {};
            e.create = function (hW) {
                hW = hW || i;
                var hV = new hW(16);
                hV[0] = 1;
                hV[1] = 0;
                hV[2] = 0;
                hV[3] = 0;
                hV[4] = 0;
                hV[5] = 1;
                hV[6] = 0;
                hV[7] = 0;
                hV[8] = 0;
                hV[9] = 0;
                hV[10] = 1;
                hV[11] = 0;
                hV[12] = 0;
                hV[13] = 0;
                hV[14] = 0;
                hV[15] = 1;
                return hV
            };
            e.clone = function (hV) {
                var hW = new i(16);
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                hW[3] = hV[3];
                hW[4] = hV[4];
                hW[5] = hV[5];
                hW[6] = hV[6];
                hW[7] = hV[7];
                hW[8] = hV[8];
                hW[9] = hV[9];
                hW[10] = hV[10];
                hW[11] = hV[11];
                hW[12] = hV[12];
                hW[13] = hV[13];
                hW[14] = hV[14];
                hW[15] = hV[15];
                return hW
            };
            e.copy = function (hW, hV) {
                hW[0] = hV[0];
                hW[1] = hV[1];
                hW[2] = hV[2];
                hW[3] = hV[3];
                hW[4] = hV[4];
                hW[5] = hV[5];
                hW[6] = hV[6];
                hW[7] = hV[7];
                hW[8] = hV[8];
                hW[9] = hV[9];
                hW[10] = hV[10];
                hW[11] = hV[11];
                hW[12] = hV[12];
                hW[13] = hV[13];
                hW[14] = hV[14];
                hW[15] = hV[15];
                return hW
            };
            e.identity = function (hV) {
                hV[0] = 1;
                hV[1] = 0;
                hV[2] = 0;
                hV[3] = 0;
                hV[4] = 0;
                hV[5] = 1;
                hV[6] = 0;
                hV[7] = 0;
                hV[8] = 0;
                hV[9] = 0;
                hV[10] = 1;
                hV[11] = 0;
                hV[12] = 0;
                hV[13] = 0;
                hV[14] = 0;
                hV[15] = 1;
                return hV
            };
            e.transpose = function (hY, hX) {
                if (hY === hX) {
                    var h2 = hX[1],
                        h0 = hX[2],
                        hZ = hX[3],
                        hV = hX[6],
                        h1 = hX[7],
                        hW = hX[11];
                    hY[1] = hX[4];
                    hY[2] = hX[8];
                    hY[3] = hX[12];
                    hY[4] = h2;
                    hY[6] = hX[9];
                    hY[7] = hX[13];
                    hY[8] = h0;
                    hY[9] = hV;
                    hY[11] = hX[14];
                    hY[12] = hZ;
                    hY[13] = h1;
                    hY[14] = hW
                } else {
                    hY[0] = hX[0];
                    hY[1] = hX[4];
                    hY[2] = hX[8];
                    hY[3] = hX[12];
                    hY[4] = hX[1];
                    hY[5] = hX[5];
                    hY[6] = hX[9];
                    hY[7] = hX[13];
                    hY[8] = hX[2];
                    hY[9] = hX[6];
                    hY[10] = hX[10];
                    hY[11] = hX[14];
                    hY[12] = hX[3];
                    hY[13] = hX[7];
                    hY[14] = hX[11];
                    hY[15] = hX[15]
                }
                return hY
            };
            e.invert = function (ie, ik) {
                var ip = ik[0],
                    im = ik[1],
                    il = ik[2],
                    ii = ik[3],
                    hZ = ik[4],
                    hY = ik[5],
                    hX = ik[6],
                    hW = ik[7],
                    id = ik[8],
                    ic = ik[9],
                    ib = ik[10],
                    ia = ik[11],
                    ir = ik[12],
                    iq = ik[13],
                    io = ik[14],
                    ij = ik[15],
                    h9 = ip * hY - im * hZ,
                    h8 = ip * hX - il * hZ,
                    h7 = ip * hW - ii * hZ,
                    h6 = im * hX - il * hY,
                    h5 = im * hW - ii * hY,
                    h4 = il * hW - ii * hX,
                    h3 = id * iq - ic * ir,
                    h2 = id * io - ib * ir,
                    h1 = id * ij - ia * ir,
                    h0 = ic * io - ib * iq,
                    ih = ic * ij - ia * iq,
                    ig = ib * ij - ia * io,
                    hV = h9 * ig - h8 * ih + h7 * h0 + h6 * h1 - h5 * h2 + h4 * h3;
                if (!hV) {
                    return null
                }
                hV = 1 / hV;
                ie[0] = (hY * ig - hX * ih + hW * h0) * hV;
                ie[1] = (il * ih - im * ig - ii * h0) * hV;
                ie[2] = (iq * h4 - io * h5 + ij * h6) * hV;
                ie[3] = (ib * h5 - ic * h4 - ia * h6) * hV;
                ie[4] = (hX * h1 - hZ * ig - hW * h2) * hV;
                ie[5] = (ip * ig - il * h1 + ii * h2) * hV;
                ie[6] = (io * h7 - ir * h4 - ij * h8) * hV;
                ie[7] = (id * h4 - ib * h7 + ia * h8) * hV;
                ie[8] = (hZ * ih - hY * h1 + hW * h3) * hV;
                ie[9] = (im * h1 - ip * ih - ii * h3) * hV;
                ie[10] = (ir * h5 - iq * h7 + ij * h9) * hV;
                ie[11] = (ic * h7 - id * h5 - ia * h9) * hV;
                ie[12] = (hY * h2 - hZ * h0 - hX * h3) * hV;
                ie[13] = (ip * h0 - im * h2 + il * h3) * hV;
                ie[14] = (iq * h8 - ir * h6 - io * h9) * hV;
                ie[15] = (id * h6 - ic * h8 + ib * h9) * hV;
                return ie
            };
            e.adjoint = function (h3, h6) {
                var ia = h6[0],
                    h8 = h6[1],
                    h7 = h6[2],
                    h4 = h6[3],
                    hY = h6[4],
                    hX = h6[5],
                    hW = h6[6],
                    hV = h6[7],
                    h2 = h6[8],
                    h1 = h6[9],
                    h0 = h6[10],
                    hZ = h6[11],
                    ic = h6[12],
                    ib = h6[13],
                    h9 = h6[14],
                    h5 = h6[15];
                h3[0] = (hX * (h0 * h5 - hZ * h9) - h1 * (hW * h5 - hV * h9) + ib * (hW * hZ - hV * h0));
                h3[1] = -(h8 * (h0 * h5 - hZ * h9) - h1 * (h7 * h5 - h4 * h9) + ib * (h7 * hZ - h4 * h0));
                h3[2] = (h8 * (hW * h5 - hV * h9) - hX * (h7 * h5 - h4 * h9) + ib * (h7 * hV - h4 * hW));
                h3[3] = -(h8 * (hW * hZ - hV * h0) - hX * (h7 * hZ - h4 * h0) + h1 * (h7 * hV - h4 * hW));
                h3[4] = -(hY * (h0 * h5 - hZ * h9) - h2 * (hW * h5 - hV * h9) + ic * (hW * hZ - hV * h0));
                h3[5] = (ia * (h0 * h5 - hZ * h9) - h2 * (h7 * h5 - h4 * h9) + ic * (h7 * hZ - h4 * h0));
                h3[6] = -(ia * (hW * h5 - hV * h9) - hY * (h7 * h5 - h4 * h9) + ic * (h7 * hV - h4 * hW));
                h3[7] = (ia * (hW * hZ - hV * h0) - hY * (h7 * hZ - h4 * h0) + h2 * (h7 * hV - h4 * hW));
                h3[8] = (hY * (h1 * h5 - hZ * ib) - h2 * (hX * h5 - hV * ib) + ic * (hX * hZ - hV * h1));
                h3[9] = -(ia * (h1 * h5 - hZ * ib) - h2 * (h8 * h5 - h4 * ib) + ic * (h8 * hZ - h4 * h1));
                h3[10] = (ia * (hX * h5 - hV * ib) - hY * (h8 * h5 - h4 * ib) + ic * (h8 * hV - h4 * hX));
                h3[11] = -(ia * (hX * hZ - hV * h1) - hY * (h8 * hZ - h4 * h1) + h2 * (h8 * hV - h4 * hX));
                h3[12] = -(hY * (h1 * h9 - h0 * ib) - h2 * (hX * h9 - hW * ib) + ic * (hX * h0 - hW * h1));
                h3[13] = (ia * (h1 * h9 - h0 * ib) - h2 * (h8 * h9 - h7 * ib) + ic * (h8 * h0 - h7 * h1));
                h3[14] = -(ia * (hX * h9 - hW * ib) - hY * (h8 * h9 - h7 * ib) + ic * (h8 * hW - h7 * hX));
                h3[15] = (ia * (hX * h0 - hW * h1) - hY * (h8 * h0 - h7 * h1) + h2 * (h8 * hW - h7 * hX));
                return h3
            };
            e.determinant = function (ih) {
                var im = ih[0],
                    ik = ih[1],
                    ii = ih[2],
                    ig = ih[3],
                    hY = ih[4],
                    hX = ih[5],
                    hW = ih[6],
                    hV = ih[7],
                    ic = ih[8],
                    ib = ih[9],
                    ia = ih[10],
                    h9 = ih[11],
                    ip = ih[12],
                    io = ih[13],
                    il = ih[14],
                    ij = ih[15],
                    h8 = im * hX - ik * hY,
                    h7 = im * hW - ii * hY,
                    h6 = im * hV - ig * hY,
                    h5 = ik * hW - ii * hX,
                    h4 = ik * hV - ig * hX,
                    h3 = ii * hV - ig * hW,
                    h2 = ic * io - ib * ip,
                    h1 = ic * il - ia * ip,
                    h0 = ic * ij - h9 * ip,
                    hZ = ib * il - ia * io,
                    ie = ib * ij - h9 * io,
                    id = ia * ij - h9 * il;
                return h8 * id - h7 * ie + h6 * hZ + h5 * h0 - h4 * h1 + h3 * h2
            };
            e.multiply = function (h7, ib, h8) {
                var ig = ib[0],
                    ie = ib[1],
                    ic = ib[2],
                    h9 = ib[3],
                    h1 = ib[4],
                    hZ = ib[5],
                    hX = ib[6],
                    hV = ib[7],
                    h6 = ib[8],
                    h5 = ib[9],
                    h4 = ib[10],
                    h3 = ib[11],
                    ii = ib[12],
                    ih = ib[13],
                    id = ib[14],
                    ia = ib[15];
                var h2 = h8[0],
                    h0 = h8[1],
                    hY = h8[2],
                    hW = h8[3];
                h7[0] = h2 * ig + h0 * h1 + hY * h6 + hW * ii;
                h7[1] = h2 * ie + h0 * hZ + hY * h5 + hW * ih;
                h7[2] = h2 * ic + h0 * hX + hY * h4 + hW * id;
                h7[3] = h2 * h9 + h0 * hV + hY * h3 + hW * ia;
                h2 = h8[4];
                h0 = h8[5];
                hY = h8[6];
                hW = h8[7];
                h7[4] = h2 * ig + h0 * h1 + hY * h6 + hW * ii;
                h7[5] = h2 * ie + h0 * hZ + hY * h5 + hW * ih;
                h7[6] = h2 * ic + h0 * hX + hY * h4 + hW * id;
                h7[7] = h2 * h9 + h0 * hV + hY * h3 + hW * ia;
                h2 = h8[8];
                h0 = h8[9];
                hY = h8[10];
                hW = h8[11];
                h7[8] = h2 * ig + h0 * h1 + hY * h6 + hW * ii;
                h7[9] = h2 * ie + h0 * hZ + hY * h5 + hW * ih;
                h7[10] = h2 * ic + h0 * hX + hY * h4 + hW * id;
                h7[11] = h2 * h9 + h0 * hV + hY * h3 + hW * ia;
                h2 = h8[12];
                h0 = h8[13];
                hY = h8[14];
                hW = h8[15];
                h7[12] = h2 * ig + h0 * h1 + hY * h6 + hW * ii;
                h7[13] = h2 * ie + h0 * hZ + hY * h5 + hW * ih;
                h7[14] = h2 * ic + h0 * hX + hY * h4 + hW * id;
                h7[15] = h2 * h9 + h0 * hV + hY * h3 + hW * ia;
                return h7
            };
            e.mul = e.multiply;
            e.translate = function (h7, h9, h2) {
                var h1 = h2[0],
                    h0 = h2[1],
                    hZ = h2[2],
                    ic, ib, ia, h8, hY, hX, hW, hV, h6, h5, h4, h3;
                if (h9 === h7) {
                    h7[12] = h9[0] * h1 + h9[4] * h0 + h9[8] * hZ + h9[12];
                    h7[13] = h9[1] * h1 + h9[5] * h0 + h9[9] * hZ + h9[13];
                    h7[14] = h9[2] * h1 + h9[6] * h0 + h9[10] * hZ + h9[14];
                    h7[15] = h9[3] * h1 + h9[7] * h0 + h9[11] * hZ + h9[15]
                } else {
                    ic = h9[0];
                    ib = h9[1];
                    ia = h9[2];
                    h8 = h9[3];
                    hY = h9[4];
                    hX = h9[5];
                    hW = h9[6];
                    hV = h9[7];
                    h6 = h9[8];
                    h5 = h9[9];
                    h4 = h9[10];
                    h3 = h9[11];
                    h7[0] = ic;
                    h7[1] = ib;
                    h7[2] = ia;
                    h7[3] = h8;
                    h7[4] = hY;
                    h7[5] = hX;
                    h7[6] = hW;
                    h7[7] = hV;
                    h7[8] = h6;
                    h7[9] = h5;
                    h7[10] = h4;
                    h7[11] = h3;
                    h7[12] = ic * h1 + hY * h0 + h6 * hZ + h9[12];
                    h7[13] = ib * h1 + hX * h0 + h5 * hZ + h9[13];
                    h7[14] = ia * h1 + hW * h0 + h4 * hZ + h9[14];
                    h7[15] = h8 * h1 + hV * h0 + h3 * hZ + h9[15]
                }
                return h7
            };
            e.scale = function (hY, hW, hX) {
                var hV = hX[0],
                    h0 = hX[1],
                    hZ = hX[2];
                hY[0] = hW[0] * hV;
                hY[1] = hW[1] * hV;
                hY[2] = hW[2] * hV;
                hY[3] = hW[3] * hV;
                hY[4] = hW[4] * h0;
                hY[5] = hW[5] * h0;
                hY[6] = hW[6] * h0;
                hY[7] = hW[7] * h0;
                hY[8] = hW[8] * hZ;
                hY[9] = hW[9] * hZ;
                hY[10] = hW[10] * hZ;
                hY[11] = hW[11] * hZ;
                hY[12] = hW[12];
                hY[13] = hW[13];
                hY[14] = hW[14];
                hY[15] = hW[15];
                return hY
            };
            e.rotate = function (ig, io, iq, hV) {
                var h5 = hV[0],
                    h4 = hV[1],
                    h3 = hV[2],
                    ih = Math.sqrt(h5 * h5 + h4 * h4 + h3 * h3),
                    ia, il, h9, it, ir, ip, im, h2, h1, h0, hZ, ie, id, ic, ib, h8, h7, h6, ik, ij, ii, hY, hX, hW;
                if (Math.abs(ih) < hU) {
                    return null
                }
                ih = 1 / ih;
                h5 *= ih;
                h4 *= ih;
                h3 *= ih;
                ia = Math.sin(iq);
                il = Math.cos(iq);
                h9 = 1 - il;
                it = io[0];
                ir = io[1];
                ip = io[2];
                im = io[3];
                h2 = io[4];
                h1 = io[5];
                h0 = io[6];
                hZ = io[7];
                ie = io[8];
                id = io[9];
                ic = io[10];
                ib = io[11];
                h8 = h5 * h5 * h9 + il;
                h7 = h4 * h5 * h9 + h3 * ia;
                h6 = h3 * h5 * h9 - h4 * ia;
                ik = h5 * h4 * h9 - h3 * ia;
                ij = h4 * h4 * h9 + il;
                ii = h3 * h4 * h9 + h5 * ia;
                hY = h5 * h3 * h9 + h4 * ia;
                hX = h4 * h3 * h9 - h5 * ia;
                hW = h3 * h3 * h9 + il;
                ig[0] = it * h8 + h2 * h7 + ie * h6;
                ig[1] = ir * h8 + h1 * h7 + id * h6;
                ig[2] = ip * h8 + h0 * h7 + ic * h6;
                ig[3] = im * h8 + hZ * h7 + ib * h6;
                ig[4] = it * ik + h2 * ij + ie * ii;
                ig[5] = ir * ik + h1 * ij + id * ii;
                ig[6] = ip * ik + h0 * ij + ic * ii;
                ig[7] = im * ik + hZ * ij + ib * ii;
                ig[8] = it * hY + h2 * hX + ie * hW;
                ig[9] = ir * hY + h1 * hX + id * hW;
                ig[10] = ip * hY + h0 * hX + ic * hW;
                ig[11] = im * hY + hZ * hX + ib * hW;
                if (io !== ig) {
                    ig[12] = io[12];
                    ig[13] = io[13];
                    ig[14] = io[14];
                    ig[15] = io[15]
                }
                return ig
            };
            e.rotateX = function (hV, h2, h1) {
                var h7 = Math.sin(h1),
                    h0 = Math.cos(h1),
                    h6 = h2[4],
                    h5 = h2[5],
                    h4 = h2[6],
                    h3 = h2[7],
                    hZ = h2[8],
                    hY = h2[9],
                    hX = h2[10],
                    hW = h2[11];
                if (h2 !== hV) {
                    hV[0] = h2[0];
                    hV[1] = h2[1];
                    hV[2] = h2[2];
                    hV[3] = h2[3];
                    hV[12] = h2[12];
                    hV[13] = h2[13];
                    hV[14] = h2[14];
                    hV[15] = h2[15]
                }
                hV[4] = h6 * h0 + hZ * h7;
                hV[5] = h5 * h0 + hY * h7;
                hV[6] = h4 * h0 + hX * h7;
                hV[7] = h3 * h0 + hW * h7;
                hV[8] = hZ * h0 - h6 * h7;
                hV[9] = hY * h0 - h5 * h7;
                hV[10] = hX * h0 - h4 * h7;
                hV[11] = hW * h0 - h3 * h7;
                return hV
            };
            e.rotateY = function (hZ, h6, h5) {
                var h7 = Math.sin(h5),
                    h4 = Math.cos(h5),
                    hY = h6[0],
                    hX = h6[1],
                    hW = h6[2],
                    hV = h6[3],
                    h3 = h6[8],
                    h2 = h6[9],
                    h1 = h6[10],
                    h0 = h6[11];
                if (h6 !== hZ) {
                    hZ[4] = h6[4];
                    hZ[5] = h6[5];
                    hZ[6] = h6[6];
                    hZ[7] = h6[7];
                    hZ[12] = h6[12];
                    hZ[13] = h6[13];
                    hZ[14] = h6[14];
                    hZ[15] = h6[15]
                }
                hZ[0] = hY * h4 - h3 * h7;
                hZ[1] = hX * h4 - h2 * h7;
                hZ[2] = hW * h4 - h1 * h7;
                hZ[3] = hV * h4 - h0 * h7;
                hZ[8] = hY * h7 + h3 * h4;
                hZ[9] = hX * h7 + h2 * h4;
                hZ[10] = hW * h7 + h1 * h4;
                hZ[11] = hV * h7 + h0 * h4;
                return hZ
            };
            e.rotateZ = function (hZ, h2, h1) {
                var h7 = Math.sin(h1),
                    h0 = Math.cos(h1),
                    hY = h2[0],
                    hX = h2[1],
                    hW = h2[2],
                    hV = h2[3],
                    h6 = h2[4],
                    h5 = h2[5],
                    h4 = h2[6],
                    h3 = h2[7];
                if (h2 !== hZ) {
                    hZ[8] = h2[8];
                    hZ[9] = h2[9];
                    hZ[10] = h2[10];
                    hZ[11] = h2[11];
                    hZ[12] = h2[12];
                    hZ[13] = h2[13];
                    hZ[14] = h2[14];
                    hZ[15] = h2[15]
                }
                hZ[0] = hY * h0 + h6 * h7;
                hZ[1] = hX * h0 + h5 * h7;
                hZ[2] = hW * h0 + h4 * h7;
                hZ[3] = hV * h0 + h3 * h7;
                hZ[4] = h6 * h0 - hY * h7;
                hZ[5] = h5 * h0 - hX * h7;
                hZ[6] = h4 * h0 - hW * h7;
                hZ[7] = h3 * h0 - hV * h7;
                return hZ
            };
            e.fromRotationTranslation = function (h8, h6, h4) {
                var h1 = h6[0],
                    h0 = h6[1],
                    hZ = h6[2],
                    h2 = h6[3],
                    h9 = h1 + h1,
                    hV = h0 + h0,
                    h3 = hZ + hZ,
                    hY = h1 * h9,
                    hX = h1 * hV,
                    hW = h1 * h3,
                    h7 = h0 * hV,
                    h5 = h0 * h3,
                    ic = hZ * h3,
                    id = h2 * h9,
                    ib = h2 * hV,
                    ia = h2 * h3;
                h8[0] = 1 - (h7 + ic);
                h8[1] = hX + ia;
                h8[2] = hW - ib;
                h8[3] = 0;
                h8[4] = hX - ia;
                h8[5] = 1 - (hY + ic);
                h8[6] = h5 + id;
                h8[7] = 0;
                h8[8] = hW + ib;
                h8[9] = h5 - id;
                h8[10] = 1 - (hY + h7);
                h8[11] = 0;
                h8[12] = h4[0];
                h8[13] = h4[1];
                h8[14] = h4[2];
                h8[15] = 1;
                return h8
            };
            e.fromQuat = function (h5, h2) {
                var hZ = h2[0],
                    hY = h2[1],
                    hX = h2[2],
                    h0 = h2[3],
                    h6 = hZ + hZ,
                    hV = hY + hY,
                    h1 = hX + hX,
                    hW = hZ * h6,
                    h4 = hY * h6,
                    h3 = hY * hV,
                    ic = hX * h6,
                    ib = hX * hV,
                    h9 = hX * h1,
                    ia = h0 * h6,
                    h8 = h0 * hV,
                    h7 = h0 * h1;
                h5[0] = 1 - h3 - h9;
                h5[1] = h4 + h7;
                h5[2] = ic - h8;
                h5[3] = 0;
                h5[4] = h4 - h7;
                h5[5] = 1 - hW - h9;
                h5[6] = ib + ia;
                h5[7] = 0;
                h5[8] = ic + h8;
                h5[9] = ib - ia;
                h5[10] = 1 - hW - h3;
                h5[11] = 0;
                h5[12] = 0;
                h5[13] = 0;
                h5[14] = 0;
                h5[15] = 1;
                return h5
            };
            e.frustum = function (hZ, hW, h4, hV, h3, h1, h0) {
                var h2 = 1 / (h4 - hW),
                    hY = 1 / (h3 - hV),
                    hX = 1 / (h1 - h0);
                hZ[0] = (h1 * 2) * h2;
                hZ[1] = 0;
                hZ[2] = 0;
                hZ[3] = 0;
                hZ[4] = 0;
                hZ[5] = (h1 * 2) * hY;
                hZ[6] = 0;
                hZ[7] = 0;
                hZ[8] = (h4 + hW) * h2;
                hZ[9] = (h3 + hV) * hY;
                hZ[10] = (h0 + h1) * hX;
                hZ[11] = -1;
                hZ[12] = 0;
                hZ[13] = 0;
                hZ[14] = (h0 * h1 * 2) * hX;
                hZ[15] = 0;
                return hZ
            };
            e.perspective = function (hY, hX, hW, hZ, hV) {
                var h1 = 1 / Math.tan(hX / 2),
                    h0 = 1 / (hZ - hV);
                hY[0] = h1 / hW;
                hY[1] = 0;
                hY[2] = 0;
                hY[3] = 0;
                hY[4] = 0;
                hY[5] = h1;
                hY[6] = 0;
                hY[7] = 0;
                hY[8] = 0;
                hY[9] = 0;
                hY[10] = (hV + hZ) * h0;
                hY[11] = -1;
                hY[12] = 0;
                hY[13] = 0;
                hY[14] = (2 * hV * hZ) * h0;
                hY[15] = 0;
                return hY
            };
            e.ortho = function (hY, hW, h4, hV, h2, h1, h0) {
                var hZ = 1 / (hW - h4),
                    h3 = 1 / (hV - h2),
                    hX = 1 / (h1 - h0);
                hY[0] = -2 * hZ;
                hY[1] = 0;
                hY[2] = 0;
                hY[3] = 0;
                hY[4] = 0;
                hY[5] = -2 * h3;
                hY[6] = 0;
                hY[7] = 0;
                hY[8] = 0;
                hY[9] = 0;
                hY[10] = 2 * hX;
                hY[11] = 0;
                hY[12] = (hW + h4) * hZ;
                hY[13] = (h2 + hV) * h3;
                hY[14] = (h0 + h1) * hX;
                hY[15] = 1;
                return hY
            };
            e.lookAt = function (h9, ih, ii, h1) {
                var ig, ie, ic, hX, hW, hV, h4, h3, h2, ia, id = ih[0],
                    ib = ih[1],
                    h8 = ih[2],
                    h0 = h1[0],
                    hZ = h1[1],
                    hY = h1[2],
                    h7 = ii[0],
                    h6 = ii[1],
                    h5 = ii[2];
                if (Math.abs(id - h7) < hU && Math.abs(ib - h6) < hU && Math.abs(h8 - h5) < hU) {
                    return e.identity(h9)
                }
                h4 = id - h7;
                h3 = ib - h6;
                h2 = h8 - h5;
                ia = 1 / Math.sqrt(h4 * h4 + h3 * h3 + h2 * h2);
                h4 *= ia;
                h3 *= ia;
                h2 *= ia;
                ig = hZ * h2 - hY * h3;
                ie = hY * h4 - h0 * h2;
                ic = h0 * h3 - hZ * h4;
                ia = Math.sqrt(ig * ig + ie * ie + ic * ic);
                if (!ia) {
                    ig = 0;
                    ie = 0;
                    ic = 0
                } else {
                    ia = 1 / ia;
                    ig *= ia;
                    ie *= ia;
                    ic *= ia
                }
                hX = h3 * ic - h2 * ie;
                hW = h2 * ig - h4 * ic;
                hV = h4 * ie - h3 * ig;
                ia = Math.sqrt(hX * hX + hW * hW + hV * hV);
                if (!ia) {
                    hX = 0;
                    hW = 0;
                    hV = 0
                } else {
                    ia = 1 / ia;
                    hX *= ia;
                    hW *= ia;
                    hV *= ia
                }
                h9[0] = ig;
                h9[1] = hX;
                h9[2] = h4;
                h9[3] = 0;
                h9[4] = ie;
                h9[5] = hW;
                h9[6] = h3;
                h9[7] = 0;
                h9[8] = ic;
                h9[9] = hV;
                h9[10] = h2;
                h9[11] = 0;
                h9[12] = -(ig * id + ie * ib + ic * h8);
                h9[13] = -(hX * id + hW * ib + hV * h8);
                h9[14] = -(h4 * id + h3 * ib + h2 * h8);
                h9[15] = 1;
                return h9
            };
            e.str = function (hV) {
                return "mat4(" + hV[0] + ", " + hV[1] + ", " + hV[2] + ", " + hV[3] + ", " + hV[4] + ", " + hV[5] + ", " + hV[6] + ", " + hV[7] + ", " + hV[8] + ", " + hV[9] + ", " + hV[10] + ", " + hV[11] + ", " + hV[12] + ", " + hV[13] + ", " + hV[14] + ", " + hV[15] + ")"
            };
            e.frob = function (hV) {
                return (Math.sqrt(Math.pow(hV[0], 2) + Math.pow(hV[1], 2) + Math.pow(hV[2], 2) + Math.pow(hV[3], 2) + Math.pow(hV[4], 2) + Math.pow(hV[5], 2) + Math.pow(hV[6], 2) + Math.pow(hV[6], 2) + Math.pow(hV[7], 2) + Math.pow(hV[8], 2) + Math.pow(hV[9], 2) + Math.pow(hV[10], 2) + Math.pow(hV[11], 2) + Math.pow(hV[12], 2) + Math.pow(hV[13], 2) + Math.pow(hV[14], 2) + Math.pow(hV[15], 2)))
            };
            hQ.mat4 = e
        })(window);

        function c9() {
            this.result = {
                bkData: [],
                eleData: [
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    []
                ],
                tileLabels: []
            }
        }
        C.extend(c9.prototype, {
            createLayer: function (T, i) {
                var e = this.result.bkData;
                i = i || {};
                if (!e[T]) {
                    e[T] = [
                        [],
                        [],
                        []
                    ]
                }
                e[T].dataType = i.dataType || 2;
                e[T].png8 = i.png8 || false;
                e[T].clipTile = i.clipTile || false
            },
            removeLayer: function (i) {
                var e = this.result.bkData;
                e[i] = null
            },
            getResult: function () {
                return this.result
            },
            setData: function (hP, hO, hQ) {
                var e = this.result.bkData;
                var T = e[hO] ? e[hO][hQ] : null;
                if (!T) {
                    return
                }
                for (var hN = 0; hN < T.length; hN++) {
                    if (T[hN].key && T[hN].key === hP.key) {
                        T[hN] = hP;
                        return
                    }
                }
                T.push(hP)
            },
            setLabelData: function (e) {
                this.result.tileLabels = e
            },
            getLabelData: function () {
                return this.result.tileLabels
            },
            setOverlayData: function (i, e) {
                if (!this.result.eleData[e]) {
                    return
                }
                this.result.eleData[e] = i
            },
            clearLabelOverlayData: function () {
                this.result.eleData[2] = [];
                this.result.eleData[3] = [];
                this.result.eleData[4] = []
            },
            clearData: function (hN) {
                var e = this.result.bkData;
                if (typeof hN === "number") {
                    if (e[hN]) {
                        e[hN][0] = [];
                        e[hN][1] = [];
                        e[hN][2] = []
                    }
                    return
                }
                for (var T = 0; T < e.length; T++) {
                    if (!e[T]) {
                        continue
                    }
                    e[T][0] = [];
                    e[T][1] = [];
                    e[T][2] = []
                }
            },
            sortThumbData: function (i) {
                var e = this.result.bkData;
                var T = e[i];
                if (!T) {
                    return
                }
                if (T[0] && T[0].length > 0) {
                    T[0].sort(function (hO, hN) {
                        return hO.tileInfo.useZoom - hN.tileInfo.useZoom
                    })
                }
            }
        });
        var fe = (function () {
            var hX = new Int8Array(4);
            var T = new Int32Array(hX.buffer, 0, 1);
            var hS = new Float32Array(hX.buffer, 0, 1);

            function hZ(h6) {
                T[0] = h6;
                return hS[0]
            }

            function i(h6) {
                hS[0] = h6;
                return T[0]
            }

            function hT(h6) {
                var h8 = (h6[3] << 24 | h6[2] << 16 | h6[1] << 8 | h6[0]);
                var h7 = hZ(h8 & 4278190079);
                return h7
            }
            var hO = 0;
            var hR = 1;
            var hV = 2;
            var h3 = 0;
            var h0 = 1;
            var hY = 2;
            var hP = 9;

            function hW(h6, h7) {
                var h8;
                if (h7 % 2 === 0) {
                    h8 = [-h6[1], h6[0]]
                } else {
                    h8 = [h6[1], -h6[0]]
                }
                return h8
            }

            function e(h6, h7, h8) {
                var h9 = hW(h6, h7);
                var ia;
                if (h8 === hR) {
                    return h9
                } else {
                    if (h7 === 4 || h7 === 5) {
                        ia = [h9[0] - h6[0], h9[1] - h6[1]]
                    } else {
                        ia = [h9[0] + h6[0], h9[1] + h6[1]]
                    } if (h8 === hO) {
                        vec2.normalize(ia, ia)
                    }
                    return ia
                }
            }

            function h2(h7, h6) {
                return Math.sqrt(Math.pow(h7[0] - h6[0], 2) + Math.pow(h7[1] - h6[1], 2))
            }

            function hN(ia, h9, h8, h6) {
                var h7 = vec2.dot(ia, h9);
                if (h8 === hY || h8 === h0) {
                    if ((h6 === 0 || h6 === 1) && h7 > 0) {
                        return true
                    } else {
                        if ((h6 === 2 || h6 === 3) && h7 < 0) {
                            return true
                        }
                    }
                }
                if ((h6 === 0 || h6 === 1) && h7 < 0) {
                    return true
                } else {
                    if ((h6 === 2 || h6 === 3) && h7 > 0) {
                        return true
                    }
                }
                return false
            }

            function hU(h7, ic, ie) {
                var id = hW(h7, ic);
                var h9;
                var ib = h7;
                var ia = ie;
                var ih = [];
                vec2.normalize(ih, [ib[0] + ia[0], ib[1] + ia[1]]);
                var ig = vec2.dot(id, [-ih[1], ih[0]]);
                if (Math.abs(ig) < 0.1) {
                    ig = 1
                }
                var h8 = 1 / ig;
                h9 = [-ih[1] * h8, ih[0] * h8];
                var h6 = vec2.dot(h7, h9);
                if (h6 < 0) {
                    vec2.negate(h9, h9)
                }
                return {
                    cos2: h6,
                    offset: h9
                }
            }

            function h5(h7, ic, ie, h6) {
                var id = hW(h7, ic);
                var ib;
                var ia;
                var h9;
                if (ic === 0 || ic === 1) {
                    ib = ie;
                    ia = h7
                } else {
                    ib = h7;
                    ia = ie
                } if (!ib || !ia) {
                    return id
                }
                var ih = [ib[0] + ia[0], ib[1] + ia[1]];
                if (ih[0] === 0 && ih[1] === 0) {
                    vec2.normalize(ih, ia)
                } else {
                    vec2.normalize(ih, ih)
                }
                var ii = hN(ih, id, h6, ic);
                if (ii) {
                    return id
                }
                var ig = vec2.dot(id, [-ih[1], ih[0]]);
                if (Math.abs(ig) < 0.1) {
                    ig = 1
                }
                var h8 = 1 / ig;
                h9 = [-ih[1] * h8, ih[0] * h8];
                return h9
            }

            function h4(ii, ij, ib, ia, ik, ih, h9, ic, h8, ig) {
                var ie;
                var h7 = 0;
                var h6 = false;
                ie = ih.length / hP - 1;
                hQ(ij[0], ii[0], ib[0], ik, ia, 4, ic, h8, undefined, ih, ig);
                ie++;
                h7++;
                hQ(ij[0], ii[0], ib[0], ik, ia, 5, ic, h8, undefined, ih, ig);
                ie++;
                h7++;
                for (var id = 0; id < ii.length; id++) {
                    hQ(ij[id], ii[id], ib[id], ik, ia, 0, ic, h8, ii[id - 1], ih, ig);
                    h1(h9, ++ie, ++h7, h6);
                    hQ(ij[id], ii[id], ib[id], ik, ia, 1, ic, h8, ii[id - 1], ih, ig);
                    h1(h9, ++ie, ++h7, h6);
                    hQ(ij[id + 1], ii[id], ib[id + 1], ik, ia, 2, ic, h8, ii[id + 1], ih, ig);
                    h1(h9, ++ie, ++h7, h6);
                    hQ(ij[id + 1], ii[id], ib[id + 1], ik, ia, 3, ic, h8, ii[id + 1], ih, ig);
                    h1(h9, ++ie, ++h7, h6);
                    if (ia === h0 && id !== ii.length - 1) {
                        hQ(ij[id + 1], ii[id], ib[id + 1], ik, ia, 8, ic, h8, ii[id + 1], ih, ig);
                        h1(h9, ++ie, ++h7, h6);
                        h6 = h6 ? false : true
                    }
                }
                hQ(ij[ij.length - 1], ii[ii.length - 1], ib[ij.length - 1], ik, ia, 6, ic, h8, undefined, ih, ig);
                h1(h9, ++ie, ++h7, h6);
                hQ(ij[ij.length - 1], ii[ii.length - 1], ib[ij.length - 1], ik, ia, 7, ic, h8, undefined, ih, ig);
                h1(h9, ++ie, ++h7, h6)
            }

            function hQ(ik, h9, id, il, h8, ie, ib, h7, ii, ih, ig) {
                var ij = ie % 2 === 0 ? 1 : -1;
                var ic;
                if (ie === 4 || ie === 5 || ie === 6 || ie === 7) {
                    ic = e(h9, ie, il)
                } else {
                    if (ie === 0 || ie === 1 || ie === 2 || ie === 3) {
                        ic = h5(h9, ie, ii, h8)
                    } else {
                        if (ie === 8) {
                            var ia = hU(h9, ie, ii);
                            ic = ia.offset;
                            vec2.normalize(ic, ic);
                            var h6 = ia.cos2;
                            if (h6 < 0) {
                                ij = -ij
                            }
                        }
                    }
                }
                ih[ih.length] = ik[0] * 10;
                ih[ih.length] = ik[1] * 10;
                ih[ih.length] = ic[0] * h7 * 10;
                ih[ih.length] = ic[1] * h7 * 10;
                ih[ih.length] = ib;
                ih[ih.length] = ij;
                ih[ih.length] = 0;
                ih[ih.length] = ig || 0;
                ih[ih.length] = id
            }

            function h1(ia, h8, h6, h9) {
                var h7;
                if (h6 % 2 === 0) {
                    if (h9) {
                        ia[ia.length] = h8 - 2;
                        ia[ia.length] = h8 - 1;
                        ia[ia.length] = h8
                    } else {
                        ia[ia.length] = h8 - 1;
                        ia[ia.length] = h8 - 2;
                        ia[ia.length] = h8
                    }
                } else {
                    if (h9) {
                        ia[ia.length] = h8 - 1;
                        ia[ia.length] = h8 - 2;
                        ia[ia.length] = h8
                    } else {
                        ia[ia.length] = h8 - 2;
                        ia[ia.length] = h8 - 1;
                        ia[ia.length] = h8
                    }
                }
            }
            return {
                getVertexCount: function (h7, h6) {
                    if (h6 === h0) {
                        return h7 * 5 - 2
                    } else {
                        return h7 * 4
                    }
                },
                buildData: function (ii, h8, ij, ie, h6, ib, h7, ig) {
                    var ih = [];
                    var id = 0;
                    var ia = [0];
                    for (var ic = 0; ic < ii.length; ic++) {
                        if (ic > 0) {
                            id += h2(ii[ic], ii[ic - 1]);
                            ia.push(id * 10)
                        }
                        if (ic !== ii.length - 1) {
                            var h9 = [ii[ic + 1][0] - ii[ic][0], ii[ic + 1][1] - ii[ic][1]];
                            var ik = [];
                            if (h9[0] === 0 && h9[1] === 0) {
                                ik = [0, 0]
                            } else {
                                vec2.normalize(ik, h9)
                            }
                            ih[ih.length] = [ik[0], ik[1]]
                        }
                    }
                    return h4(ih, ii, ia, h8, ij, ie, h6, hT(ib), h7, ig)
                },
                toTileSolidLineVertices: function (ia, h7) {
                    var h8 = new Float32Array(ia.length / hP * 5);
                    var h6 = new Int16Array(h8.buffer);
                    var ic = 0;
                    var h9 = 0;
                    for (var ib = 0; ib < ia.length; ib += hP) {
                        h6[ic] = ~~ia[ib];
                        h6[ic + 1] = ~~ia[ib + 1];
                        h6[ic + 2] = ~~ia[ib + 2];
                        h6[ic + 3] = ~~ia[ib + 3];
                        h8[h9 + 2] = ia[ib + 4];
                        h6[ic + 6] = ia[ib + 5];
                        h6[ic + 7] = h7 ? h7 : 0;
                        h6[ic + 8] = ia[ib + 7];
                        h6[ic + 9] = 0;
                        ic += 10;
                        h9 += 5
                    }
                    return h8
                }
            }
        })();
        var eE = 1;
        var gp = 2;
        var fP = {
            drawIndex: 0,
            devicePixelRatio: a3(),
            zoomState: 1,
            curViewTilesInfo: null,
            iconSetImg: null,
            LAST_CALC_ZOOM: -1,
            LAST_LOAD_VECTOR_ZOOM_CHANGE: false,
            lastCollisionTestTime: 0,
            remove: function () {
                this.tileCache.clear()
            },
            initDrawData: function () {
                this.drawIndex = this.zIndex;
                this.map._featureMgr.createLayer(this.drawIndex, {
                    dataType: this.dataType,
                    png8: this.png8,
                    clipTile: this.clipTile
                })
            },
            destroyDrawData: function () {
                this.map._featureMgr.removeLayer(this.drawIndex)
            },
            setZIndex: function (e) {
                this.zIndex = e
            },
            getTileKey: function (e, hN) {
                hN = hN || {};
                var i = typeof hN.useZoom === "number" ? hN.useZoom : e.useZoom;
                var T = e.style || this.mapStyleId || "default";
                return this.mapType + "_" + T + "_" + e.col + "_" + e.row + "_" + e.zoom + "_" + i
            },
            getTileRenderDataKey: function (i) {
                var T = i.col;
                var hN = i.zoom;
                var e = i.baseTileSize;
                T = d0.calcLoopParam(T, hN, e).col;
                return this.mapType + "_" + T + "_" + i.row + "_" + hN + "_" + i.useZoom
            },
            getTileUnits: function (e) {
                var hN = this.map;
                var T = b3[hN.getMapType()];
                var i = T.baseUnits * Math.pow(2, T.zoomLevelBase - e);
                return i
            },
            getTilesUrl: function (hO, hX, hY) {
                var i = hO.x;
                var hZ = hO.y;
                var hU = aB("ditu", "normal");
                var hQ = hU.ver;
                var hR = hU.udt;
                i = d0.calcLoopParam(i, hX, hY).col;
                var hW = b3.B_NORMAL_MAP.vectorTileUrls;
                var hP = Math.abs(i + hZ) % hW.length;
                var hV = hW[hP];
                if (window.offLineIPAddress) {
                    hW = [window.offLineIPAddress + "pvd/"];
                    hV = hW[0]
                }
                var T = "x=" + i + "&y=" + hZ + "&z=" + Math.floor(hX);
                var hT = this.devicePixelRatio > 1 ? "&scaler=2" : "";
                var hS = "&textimg=1";
                if (this.map.config.textRenderType === "canvas") {
                    hS = "&textimg=0"
                }
                var hN = this.map.config.style;
                if (typeof hN === "string" && hN !== "default") {
                    T += "&styleId=" + e0.mapStyleNameIdPair[hN]
                }
                T += "&styles=pl" + hS + hT + "&v=" + hQ + "&udt=" + hR + "&json=0";
                var e = hV + "?qt=vtile&param=" + window.encodeURIComponent(gh(T));
                return e
            },
            getRasterTilesUrl: function (T, hP, hN) {
                var hO = b3[this.map.mapType];
                var i = this.map.config.style;
                var e = hO.tileUrls[Math.abs(hP + T) % hO.tileUrls.length] + "?qt=tile&x=" + T + "&y=" + hP + "&z=" + hN + ((i === "default" || typeof i !== "string") ? "" : ("&styleId=" + e0.mapStyleNameIdPair[i])) + "&styles=pl&udt=" + this.normalUdt + "&scaler=" + this.scaler + "&p=1";
                e = e.replace(/-(\d+)/gi, "M$1");
                return e
            },
            getZoomState: function () {
                var T = this.map;
                var i = T.getZoom();
                var e = i - this.lastZoom;
                if (e > 0) {
                    this.zoomState = 1
                } else {
                    if (e < 0) {
                        this.zoomState = -1
                    }
                }
                this.lastZoom = i;
                return this.zoomState
            },
            releaseOutViewTileData: function (e) {
                var hO = this.map._workerMgr.releasePendingData(e);
                for (var hN = 0, T = hO.length; hN < T; hN++) {
                    var hP = this.getTileKey(hO[hN]);
                    this.tileCache.removeData(hP)
                }
            },
            loadLayerData: function (e, hN, i) {
                this.hasZoomChange = i;
                this.curViewTilesInfo = e;
                this.mapStyleId = this.map.getMapStyleId();
                this.releaseOutViewTileData(e);
                var T = this.getZoomState();
                if (this.dataType === gp) {
                    if (hN) {
                        this.getVectorLayerDataFromCache(e, T)
                    } else {
                        this.loadVectorLayerData(e)
                    }
                } else {
                    this.loadRasterLayerData(e, hN)
                }
            },
            getVectorLayerDataFromCache: function (hS, h2) {
                this.map.temp.isPermitSpotOver = false;
                this.tileLabels = [];
                if (this.baseLayer === true) {
                    var hW = this.map._customLabelMgr.virtualTile;
                    if (hW && hW.label) {
                        this.tileLabels.push(hW.label)
                    }
                }
                this.thumbCache = {};
                var h3 = -1;
                for (var hZ = 0, hX = hS.length; hZ < hX; hZ++) {
                    var h0 = hS[hZ];
                    var hO = h0.col;
                    var hP = h0.row;
                    var T = h0.zoom;
                    var hY = this._getTileTexImgKey(h0);
                    var hN = h0.useZoom;
                    h3 = T;
                    var hQ = this.getTileKey(h0);
                    var h5 = this.tileCache.getData(hQ);
                    if (h5 && h5.status === "ready") {
                        var h6 = h5;
                        this.map._featureMgr.setData(h5, this.drawIndex, 2);
                        if (h5.label) {
                            if (h5.label.status === "ready") {
                                h5.label.tileInfo = h5.tileInfo;
                                this.tileLabels.push(h5.label);
                                if (h5.label.textureSources && h5.label.textureSources[hN] && this.map._webglMapScene) {
                                    var h4 = this.map._webglMapScene._painter;
                                    if (!h4._labelTextureAtlasOffset[hY]) {
                                        h4._addToAsyncJob(h5.label.textureSources[hN])
                                    }
                                }
                            } else {
                                if (h5.label.status !== "processing") {
                                    this.processLabelData(h5)
                                }
                            }
                        }
                    } else {
                        var h1 = {
                            tileInfo: h0,
                            dataType: gp,
                            key: hQ
                        };
                        this.map._featureMgr.setData(h1, this.drawIndex, 2);
                        if (this.useThumbData) {
                            this.setThumbData(hO, hP, T, hN, h2)
                        }
                    }
                }
                this.tileLabels.labelZoom = h3;
                this.updateLabels(h2);
                var hT = this.map.getZoom();
                var hR = Math.floor(hT);
                var hV = hT - hR;
                var hU = Math.floor(this.LAST_CALC_ZOOM);
                var e = this.LAST_CALC_ZOOM - hU;
                var h7 = false;
                if (this.hasZoomChange) {
                    if (Math.abs(hT - this.LAST_CALC_ZOOM) >= 0.5) {
                        h7 = true
                    } else {
                        if (hV < 0.5 && e >= 0.5) {
                            h7 = true
                        } else {
                            if (hV >= 0.5 && e < 0.5) {
                                h7 = true
                            }
                        }
                    } if (h7) {
                        this.cacheDataCollideLabels(0)
                    }
                    this.LAST_CALC_ZOOM = hT
                } else {
                    if (this.tileLabels.length > 0) {
                        this.cacheDataCollideLabels(C.Browser.ie ? 50 : 30)
                    }
                }
            },
            loadVectorLayerData: function (hT) {
                this.map.temp.isPermitSpotOver = false;
                var hS = this;

                function hR(i, hU) {
                    var hW = hS.tileCache.getData(hU);
                    if (!hW) {
                        return
                    }
                    if (!i || i.error) {
                        var hV = new a8("ontileloaderror");
                        i = i || {};
                        hV.error = i.error || "";
                        hV.message = i.message || "";
                        hS.map.fire(hV);
                        hW.status = "init";
                        hW.reloadTimer = setTimeout(function () {
                            if (hW.retry < 3) {
                                hW.retry++;
                                hW.status = "loading";
                                hS.loadVectorTileData(i.tileInfo, hR)
                            } else {
                                hS.tileCache.removeData(hU)
                            }
                        }, 4000);
                        hS.map._featureMgr.clearData(hS.drawIndex);
                        hS._checkTilesLoaded();
                        hS.getVectorLayerDataFromCache(hS.curViewTilesInfo, hS.getZoomState());
                        return
                    }
                    if (hW.reloadTimer) {
                        clearTimeout(hW.reloadTimer);
                        hW.reloadTimer = null
                    }
                    hS.callbackDataQueue.push([i, hU]);
                    if (hS.processDataTimer) {
                        return
                    }
                    hS.processDataTimer = setTimeout(function () {
                        while (hS.callbackDataQueue.length > 0) {
                            var hX = hS.callbackDataQueue.shift();
                            hS.vectorTileDataCbk(hX[0], hX[1]);
                            hS._checkTilesLoaded()
                        }
                        hS.map._featureMgr.clearData(hS.drawIndex);
                        hS.getVectorLayerDataFromCache(hS.curViewTilesInfo, hS.getZoomState());
                        hS.processDataTimer = null
                    }, 200)
                }
                for (var hQ = 0, hO = hT.length; hQ < hO; hQ++) {
                    var T = hT[hQ];
                    var hP = this.getTileKey(T);
                    var e = this.tileCache.getData(hP);
                    if (!e) {
                        e = {
                            status: "init",
                            tileInfo: T,
                            dataType: gp,
                            key: hP,
                            retry: 0
                        }
                    }
                    if (e.status !== "ready" && e.status !== "loading") {
                        this.numLoading++;
                        e.status = "loading";
                        this.tileCache.setData(hP, e);
                        var hN = this.getProcessedLabelZoom(T);
                        if (hN) {
                            T.processedLabelZooms = hN
                        }
                        this.loadVectorTileData(T, hR)
                    }
                }
            },
            setThumbData: function (i, hO, hN, e, T) {
                if (T === 1) {
                    if (this._findParentZoomTile(i, hO, hN, e, 8) === false) {
                        this._findChildZoomTile(i, hO, hN, e, 3)
                    }
                } else {
                    if (T === -1) {
                        if (this._findChildZoomTile(i, hO, hN, e, 3) === false) {
                            this._findParentZoomTile(i, hO, hN, e, 8)
                        }
                    }
                }
                this.map._featureMgr.sortThumbData(this.drawIndex)
            },
            _findParentZoomTile: function (hQ, hZ, hY, hO, hT) {
                var hP = b3[this.getMapType()];
                var T = hP.minDataZoom;
                var e = hQ;
                var hW = hZ;
                var hU = hY;
                var hV = hO;
                for (var hS = 1; hS <= hT; hS++) {
                    var hN = this.tileType.getParentTile(e, hW, hU, hV, T);
                    if (hN === null) {
                        continue
                    }
                    var hX = this.getTileKey(hN);
                    var hR = this.tileCache.getData(hX);
                    if (hR && hR.status === "ready") {
                        if (this.thumbCache[hX]) {
                            continue
                        }
                        this.map._featureMgr.setData(hR, this.drawIndex, 0);
                        this.thumbCache[hX] = true;
                        return true
                    }
                    e = hN.col;
                    hW = hN.row;
                    hU = hN.zoom;
                    hV = hN.useZoom
                }
                return false
            },
            _findChildZoomTile: function (hR, hT, e, hO, h2) {
                var h0 = b3[this.getMapType()];
                var hW = h0.maxDataZoom;
                var hQ = hR;
                var hS = hT;
                var hU = e;
                var hN = hO;
                var hP = true;
                for (var hZ = 1; hZ <= h2; hZ++) {
                    var hX = false;
                    var T = this.tileType.getChildTiles(hQ, hS, hU, hN, hW, hZ);
                    if (!T) {
                        continue
                    }
                    for (var hY = 0; hY < T.length; hY++) {
                        var hV = this.getTileKey(T[hY]);
                        var h1 = this.tileCache.getData(hV);
                        if (h1 && h1.status === "ready") {
                            if (!this.thumbCache[hV]) {
                                this.map._featureMgr.setData(h1, this.drawIndex, 1);
                                this.thumbCache[hV] = true
                            }
                            hX = true
                        } else {
                            hP = false
                        }
                    }
                    if (hX) {
                        break
                    }
                }
                return hP
            },
            loadVectorTileData: function (i, hO) {
                var T = i.col;
                var hS = i.row;
                var hQ = i.zoom;
                var hR = i.baseTileSize;
                var e = this.getTilesUrl(new eg(T, hS), hQ, hR);
                if (!e) {
                    return
                }
                var hP = this.getTileKey(i);
                bv(this.map);
                if (!this.processData) {
                    this.map._workerMgr.loadTileData(e, i, hP, hO);
                    return
                }
                var hO = "cbk" + hP.replace(/-/g, "_");
                var hN = this;
                bl[hO] = function (hT) {
                    var hU = (function (hV) {
                        return function () {
                            hV.tileInfo = i;
                            var h1 = hN.processData(hV);
                            if (!h1.road) {
                                return
                            }
                            var hY = {
                                tileInfo: i,
                                renderData: {
                                    base: []
                                },
                                status: "ready",
                                key: hP,
                                mapType: hN.mapType
                            };
                            var h4 = [];
                            var h7 = [];
                            for (var h0 = 0; h0 < h1.road.length; h0++) {
                                var h3 = h1.road[h0];
                                var h2 = -1;
                                for (var hZ = 0; hZ < h3.length; hZ++) {
                                    var h5 = h3[hZ];
                                    var h6 = [];
                                    if (h4.length / 7 + h5[0].length / 2 > 65536) {
                                        hY.renderData.base.push({
                                            type: "line",
                                            data: [fe.toTileSolidLineVertices(h4, 4000), new Uint16Array(h7)]
                                        });
                                        h4 = [];
                                        h7 = []
                                    }
                                    for (var hX = 0; hX < h5[0].length; hX += 2) {
                                        h6[h6.length] = [h5[0][hX], h5[0][hX + 1]]
                                    }
                                    var hW = h5[3];
                                    fe.buildData(h6, h5[1], h5[2], h4, h7, hW, h5[4], h0 + 20, false)
                                }
                                hY.renderData.base.push({
                                    type: "line",
                                    data: [fe.toTileSolidLineVertices(h4, 4000), new Uint16Array(h7)]
                                })
                            }
                            hN.tileCache.setData(hP, hY);
                            hN.map._featureMgr.clearData(hN.drawIndex);
                            hN.getVectorLayerDataFromCache(hN.curViewTilesInfo, hN.getZoomState());
                            hN.map.dispatchEvent(new a8("onrefresh"))
                        }
                    })(hT);
                    hN.map.jobScheduler.addJob(hU);
                    delete bl[hO]
                };
                e += "&fn=" + encodeURIComponent(ex + "." + hO);
                hi.load(e)
            },
            vectorTileDataCbk: function (hN, hO) {
                var hS = new a8("ontileloaded");
                hS.perfStat = hN.perfStat || [];
                var e = this.map;
                e.fire(hS);
                var i = hN.tileInfo;
                var T = i.col;
                var hX = i.row;
                var hW = i.zoom;
                var hV = i.baseTileSize;
                var hQ = this.tileCache.getData(hO);
                if (!hQ) {
                    return
                }
                if (!this.showLabel) {
                    hN.label = null
                }
                hQ.renderData = hN;
                hQ.tileInfo = i;
                var hP = d0.calcLoopParam(T, hW, hV);
                var hT = hP.geoOffsetX;
                hQ.tileInfo.loopOffsetX = hT;
                hQ.status = "ready";
                hQ.mapType = this.mapType;
                this.tileCache.setData(hO, hQ);
                hQ.label = hN.label;
                hN.label = null;
                if (hN.indoorData && e._indoorMgr) {
                    e._indoorMgr.setData(hN.indoorData)
                }
                var hR = "id_" + T + "_" + hX + "_" + hW;
                if (!this.curViewTilesInfo[hR]) {
                    e.fire(new a8("ontilenotinview"));
                    return
                }
                this.processLabelData(hQ);
                if (hN.indoorData && e._indoorMgr && e._indoorMgr.currentUid) {
                    this._refreshIndoorData(e._indoorMgr.currentUid, e._indoorMgr.currentFloor)
                }
                var hU = new a8("onrefresh");
                hU.source = "webgllayer";
                this.map.dispatchEvent(hU)
            },
            _refreshIndoorData: function (hV, hU) {
                var hX = this.map._indoorMgr.getIndoorData(hV);
                var h0 = hX.tileKeys;
                var hY = Math.floor(this.map.getZoom());
                for (var hS = 0; hS < h0.length; hS++) {
                    var hP = h0[hS];
                    var hR = this.tileCache.getData(hP);
                    if (!hR) {
                        continue
                    }
                    var hZ = hR.renderData;
                    hZ.indoorBase = [];
                    hZ.indoorBaseContour = [];
                    hZ.indoorBorder3D = [];
                    hZ.indoorArea3D = [];
                    hR.label.indoorLabel = [];
                    this.labelProcessor.clearCollisionCache(hR.label);
                    for (var hT in hZ.indoorData) {
                        if (hT === "tileInfo") {
                            continue
                        }
                        var e = hZ.indoorData[hT];
                        var hO = e.defaultFloor;
                        if (hT === hV) {
                            hO = hU;
                            e.currentFloor = hU
                        }
                        if (e.floors[hO]) {
                            if (e.floors[hO].base) {
                                for (var hQ = 0; hQ < e.floors[hO].base.length; hQ++) {
                                    hZ.indoorBase.push(e.floors[hO].base[hQ])
                                }
                            }
                            if (e.floors[hO].contour) {
                                for (var hQ = 0; hQ < e.floors[hO].contour.length; hQ++) {
                                    hZ.indoorBaseContour.push(e.floors[hO].contour[hQ])
                                }
                            }
                            if (e.floors[hO].indoorBorder3D) {
                                hZ.indoorBorder3D.push(e.floors[hO].indoorBorder3D)
                            }
                            if (e.floors[hO].area3D) {
                                hZ.indoorArea3D.push(e.floors[hO].area3D)
                            }
                            if (e.floors[hO].pois) {
                                hR.label.indoorLabel = hR.label.indoorLabel.concat(e.floors[hO].pois)
                            }
                        }
                    }
                    this.updateAllIconsTextureCoords(hR);
                    var hW = this;
                    this.labelProcessor.loadIconImages(hR, function (i) {
                        hW.updateAllIconsTextureCoords(i)
                    });
                    var hN = hP.split("_");
                    var T = parseInt(hN[hN.length - 1], 10);
                    if (T !== hY) {
                        continue
                    }
                    hW.map._featureMgr.setData(hR, this.drawIndex, 2)
                }
                this.dataBackCollideLabels();
                this.map.dispatchEvent(new a8("onrefresh"))
            },
            _removeIndoorData: function (i) {
                if (!i.indoorData) {
                    return
                }
                for (var e in i.indoorData) {
                    if (e === "tileInfo") {
                        continue
                    }
                    this.map._indoorMgr.removeData(e, i.key)
                }
            },
            getProcessedLabelZoom: function (hN) {
                var hO = df.baseZoomInfo[hN.zoom];
                if (!hO) {
                    return false
                }
                var T = [];
                for (var hP = 0; hP < hO.length; hP++) {
                    var hQ = this.getTileKey(hN, {
                        useZoom: hO[hP]
                    });
                    var e = this.tileCache.getData(hQ);
                    if (e && e.status === "ready" && e.label && e.label.status === "ready") {
                        T.push(hO[hP])
                    }
                }
                if (T.length) {
                    return T
                } else {
                    return false
                }
            },
            getSameZoomDataFromCache: function (T) {
                var hN = df.baseZoomInfo[T.zoom];
                for (var hO = 0; hO < hN.length; hO++) {
                    var hP = this.getTileKey(T, {
                        useZoom: hN[hO]
                    });
                    if (T.useZoom === hN[hO]) {
                        continue
                    }
                    var e = this.tileCache.getData(hP);
                    if (e && e.status === "ready" && e.label && e.label.status === "ready") {
                        return e
                    }
                }
                return false
            },
            hasSameLabelData: function (hN, T) {
                for (var e = 0; e < T.length; e++) {
                    if (T[e].key === hN) {
                        return true
                    }
                }
                return false
            },
            getDataByFloorName: function (T, hN) {
                for (var e = 0; e < T.length; e++) {
                    if (T[e].floorName === hN) {
                        return T[e]
                    }
                }
                return null
            },
            mergeIndoorLabelData: function (hS, e) {
                for (var hQ in hS) {
                    if (hQ === "tileInfo") {
                        continue
                    }
                    if (e[hQ]) {
                        var T = hS[hQ].floors;
                        var hT = e[hQ].floors;
                        for (var hO = 0; hO < T.length; hO++) {
                            var hN = T[hO];
                            var hR = hN.floorName;
                            var hP = this.getDataByFloorName(hT, hR);
                            if (hP) {
                                if (hP.pois) {
                                    hP.pois = hP.pois.concat(hN.pois);
                                    hN.pois = hP.pois
                                } else {
                                    hP.pois = hN.pois
                                }
                            }
                        }
                    }
                }
            },
            mergeSameZoomLabelData: function (hQ) {
                var hO = hQ.label;
                if (!hO) {
                    return
                }
                var e = hQ.tileInfo;
                var hP = this.getSameZoomDataFromCache(e);
                if (!hP) {
                    return
                }
                var hN = hP.label;
                if (!hN) {
                    return
                }
                for (var T = 0; T < hO.fixedLabel.length; T++) {
                    if (!this.hasSameLabelData(hO.fixedLabel[T].key, hN.fixedLabel)) {
                        hN.hasNewData = true;
                        hN.fixedLabel.push(hO.fixedLabel[T])
                    }
                }
                for (var T = 0; T < hO.lineLabel.length; T++) {
                    if (!this.hasSameLabelData(hO.lineLabel[T].key, hN.lineLabel)) {
                        hN.hasNewData = true;
                        hN.lineLabel.push(hO.lineLabel[T])
                    }
                }
                for (var T = 0; T < hO.indoorLabel.length; T++) {
                    if (!this.hasSameLabelData(hO.indoorLabel[T].key, hN.indoorLabel)) {
                        hN.hasNewData = true;
                        hN.indoorLabel.push(hO.indoorLabel[T])
                    }
                }
                hQ.label = hN;
                if (hP.renderData.indoorData && hQ.renderData.indoorData) {
                    this.mergeIndoorLabelData(hQ.renderData.indoorData, hP.renderData.indoorData)
                }
            },
            processLabelData: function (hP) {
                if (!hP.label) {
                    return
                }
                if (hP.label.status === "processing") {
                    return
                }
                hP.label.status = "processing";
                var hN = this;
                hN.updateAllIconsTextureCoords(hP);
                this.labelProcessor.loadIconImages(hP, function (hQ) {
                    hN.updateAllIconsTextureCoords(hQ)
                });
                if (this.map.config.textRenderType === "canvas") {
                    var e = this.labelProcessor.drawLabelsOnCanvas(hP, function (hS, hT) {
                        var hR = hP.tileInfo;
                        if (!bl.customStyleInfo) {
                            hN.mergeSameZoomLabelData(hP)
                        }
                        if (hS) {
                            if (!hP.label.textureHeights) {
                                hP.label.textureHeights = []
                            }
                            hP.label.textureHeights[hR.useZoom] = hS.height
                        }
                        if (hT) {
                            if (!hP.label.indoorTextureHeights) {
                                hP.label.indoorTextureHeights = []
                            }
                            hP.label.indoorTextureHeights[hR.useZoom] = hT.height
                        }
                        var hQ = hN._getTileTexImgKey(hR);
                        hN._doWorkAfterLabelImageLoad(hP, hS, hT, hQ)
                    });
                    return
                }
                var T = hP.label.textImageBitmap || hP.label.textImgStr;
                var hO = hP.label.indoorTextImageBitmap || hP.label.indoorTextImgStr;
                this.labelProcessor.loadImgByStr(T, hO, function i(hV, hT) {
                    var hS = hP.label.textureHeight;
                    var hW = hP.label.indoorTextureHeight;
                    hP.label.textureHeight = undefined;
                    hP.label.indoorTextureHeight = undefined;
                    var hR = hP.tileInfo;
                    hN.mergeSameZoomLabelData(hP);
                    var hU = hP.label;
                    hU.textImgStr = "";
                    hU.indoorTextImgStr && (hU.indoorTextImgStr = "");
                    if (!hU.textureHeights) {
                        hU.textureHeights = []
                    }
                    hU.textureHeights[hR.useZoom] = hS;
                    if (!hU.indoorTextureHeights) {
                        hU.indoorTextureHeights = []
                    }
                    hU.indoorTextureHeights[hR.useZoom] = hW;
                    var hQ = hN._getTileTexImgKey(hR);
                    hN._doWorkAfterLabelImageLoad(hP, hV, hT, hQ)
                })
            },
            _getTileTexImgKey: function (i) {
                var T = i.style || this.mapStyleId || "default";
                var e = T + "_" + i.col + "_" + i.row + "_" + i.zoom;
                if (this.map.config.textRenderType === "canvas") {
                    e += "_" + i.useZoom
                }
                return e
            },
            _doWorkAfterLabelImageLoad: function (hR, hP, hN, i) {
                var hQ = this;
                var hO = hR.label;
                hO.tileInfo = hR.tileInfo;
                hO.status = "ready";
                if (hP || hN) {
                    var e = hO.tileInfo;
                    if (hP) {
                        hP.id = i;
                        if (!hO.textureSources) {
                            hO.textureSources = []
                        }
                        hO.textureSources[e.useZoom] = hP
                    }
                    if (hN) {
                        hN.id = i + "_indoor";
                        if (!hO.indoorTextureSources) {
                            hO.indoorTextureSources = []
                        }
                        hO.indoorTextureSources[e.useZoom] = hN
                    }
                    if (hQ.map._webglMapScene) {
                        var T = hQ.map._webglMapScene._painter;
                        if (hP) {
                            T._addToAsyncJob(hO.textureSources[e.useZoom])
                        }
                    }
                }
                if (hR.custom !== true) {
                    hQ.tileLabels.push(hO)
                }
                if (hQ.collisionTimer) {
                    return
                }
                hQ.collisionTimer = setTimeout(function () {
                    hQ.dataBackCollideLabels();
                    hQ.collisionTimer = null
                }, 300)
            },
            _updateIconTextureCoords: function (hR, T) {
                if (!hR) {
                    return
                }
                var hQ = this.map;
                for (var hN = 0; hN < hR.length; hN++) {
                    var hP = hR[hN];
                    if (!hP.iconPos) {
                        continue
                    }
                    if (hQ._webglMapScene) {
                        var e = hQ._webglMapScene._painter;
                        var hO = T + "_" + hP.iconPos.iconType;
                        hP.iconPos.texcoord = e._iconTextureAtlasCoords[hO] || null
                    }
                }
            },
            updateAllIconsTextureCoords: function (hO) {
                if (this.map.viewAnimationTime) {
                    return
                }
                if (hO) {
                    if (hO.label) {
                        var i = hO.tileInfo.style;
                        this._updateIconTextureCoords(hO.label.fixedLabel, i);
                        this._updateIconTextureCoords(hO.label.indoorLabel, i)
                    }
                } else {
                    var hN = this.tileCache.getAllData();
                    for (var T in hN) {
                        var e = hN[T].data;
                        if (e.status === "ready" && e.label) {
                            var i = e.tileInfo.style;
                            this._updateIconTextureCoords(e.label.fixedLabel, i);
                            this._updateIconTextureCoords(e.label.indoorLabel, i)
                        }
                    }
                }
                this.updateLabels();
                this.map.dispatchEvent(new a8("onrefresh"))
            },
            cacheDataCollideLabels: function (T) {
                var hO = this;
                var i = this.map._featureMgr;

                function hN() {
                    hO.cacheLabelTimer = null;
                    var hP;
                    var hQ = hO.map.getTilt();
                    var hR = hO.map.getHeading() % 360;
                    if (hO.tileLabels.length === 0 || (hO.tileLabels.length === 1 && hO.tileLabels[0].tileInfo.zoom === 0)) {
                        hP = i.getLabelData();
                        if (hP.length > 0) {
                            hP = hO.labelProcessor.collisionTest(hP, -1)
                        }
                    } else {
                        if (hQ || hR) {
                            if (this._collisionTimer) {
                                if (!hQ) {
                                    clearTimeout(this._collisionTimer)
                                } else {
                                    if (Date.now() - hO.lastCollisionTestTime > 500) {
                                        hO.lastCollisionTestTime = Date.now()
                                    } else {
                                        clearTimeout(this._collisionTimer)
                                    }
                                }
                            }
                            this._collisionTimer = setTimeout(function () {
                                hP = hO.labelProcessor.collisionTest(hO.tileLabels);
                                if (hP) {
                                    i.setLabelData(hP)
                                }
                                hO.updateLabels();
                                hO.map.dispatchEvent(new a8("onrefresh"));
                                hO._collisionTimer = null
                            }, 60);
                            return
                        } else {
                            hP = hO.labelProcessor.getCachedLabels(hO.tileLabels)
                        }
                    } if (hP) {
                        i.setLabelData(hP)
                    }
                    hO.updateLabels();
                    hO.map.dispatchEvent(new a8("onrefresh"))
                }
                if (!T) {
                    clearTimeout(hO.cacheLabelTimer);
                    hN()
                } else {
                    if (hO.cacheLabelTimer) {
                        return
                    }
                    hO.cacheLabelTimer = setTimeout(function e() {
                        hN()
                    }, T)
                }
            },
            dataBackCollideLabels: function () {
                var i = this;
                if ((i.tileLabels && i.tileLabels.length === 0)) {
                    return
                }
                var e;
                i.labelProcessor.calcLabelsCollision(i.tileLabels);
                e = i.labelProcessor.getCachedLabels(i.tileLabels);
                if (e) {
                    i.map._featureMgr.setLabelData(e)
                }
                i.updateLabels();
                i.map.dispatchEvent(new a8("onrefresh"));
                if (f1()) {
                    this.labelProcessor._refreshSpotData()
                }
            },
            updateLabels: function (hO) {
                var hP = this.map;
                var i = hP._featureMgr;
                var T = i.getLabelData();
                if (T.length > 0) {
                    var hN = hP.getZoom();
                    if (T.labelZoom - hN < 3) {
                        this.labelProcessor.updateLabels(T);
                        var e = this.labelProcessor.fixDataFormat(T);
                        i.setOverlayData(e[0], 2);
                        i.setOverlayData(e[1], 3);
                        i.setOverlayData(e[2], 4)
                    } else {
                        i.clearLabelOverlayData()
                    }
                    hP.temp.isPermitSpotOver = false;
                    this.labelProcessor.curSpotAdded = false
                }
            },
            loadRasterLayerData: function (hN, hR) {
                if (hR) {
                    for (var hP = 0, hO = hN.length; hP < hO; hP++) {
                        var T = hN[hP];
                        var hS = this.getTileKey(T);
                        var e = this.tileCache.getData(hS);
                        if (e && e.status === "ready") {
                            this.map._featureMgr.setData(e, this.drawIndex, 2)
                        }
                    }
                    return
                }
                for (var hP = 0, hO = hN.length; hP < hO; hP++) {
                    var T = hN[hP];
                    var hS = this.getTileKey(T);
                    var e = this.tileCache.getData(hS);
                    if (!e) {
                        this.tileCache.setData(hS, {});
                        var hQ = this;
                        this.loadRasterTileData(T, function (i, hT) {
                            hQ.rasterTileDataCbk(i, hT)
                        })
                    }
                }
            },
            loadRasterTileData: function (i, e) {
                var hO = i.col;
                var hR = i.row;
                var hP = i.zoom;
                var hN = this.getTilesUrl(new eg(hO, hR), hP);
                if (!hN) {
                    return
                }
                var hQ = this.getTileKey(i);
                var T = this.loadTileImage(hN, hQ, e);
                T.tileInfo = i
            },
            loadTileImage: function (hN, T, e) {
                var i = new Image();
                i.crossOrigin = "anonymous";
                i.onload = function () {
                    e && e(this, T)
                };
                i.onerror = function () {
                    e && e(null, T)
                };
                i.src = hN;
                return i
            },
            rasterTileDataCbk: function (hP, hN) {
                if (!hP) {
                    this.tileCache.removeData(hN);
                    return
                }
                var i = hP.tileInfo;
                var T = i.col;
                var hV = i.row;
                var hU = i.zoom;
                var e = this.tileCache.getData(hN);
                if (!e) {
                    return
                }
                var hO = d0.calcLoopParam(T, hU);
                var hS = hO.geoOffsetX;
                hP.tileInfo.loopOffsetX = hS;
                e.textureSource = hP;
                e.dataType = eE;
                e.tileInfo = i;
                e.renderData = {
                    vertexAll: [0, 0, 0, 0, 0, 256, 0, 0, 1, 0, 256, 256, 0, 1, 1, 0, 0, 0, 0, 0, 256, 256, 0, 1, 1, 0, 256, 0, 0, 1]
                };
                e.status = "ready";
                this.tileCache.setData(hN, e);
                var hQ = "id_" + T + "_" + hV + "_" + hU;
                var hR = false;
                if (this.curViewTilesInfo[hQ]) {
                    e.dataType = eE;
                    e.png8 = this.png8 || false;
                    this.map._featureMgr.setData(e, this.drawIndex, 2);
                    hR = true
                }
                if (hR) {
                    var hT = new a8("onrefresh");
                    hT.source = "webgllayer";
                    this.map.dispatchEvent(hT)
                }
            },
            _checkTilesLoaded: function () {
                this.numLoading--;
                if (this.map.firstTileLoad === false) {
                    this.map.dispatchEvent(new a8("onfirsttilesloaded"));
                    this.map.firstTileLoad = true
                }
                var e = this;
                if (this.numLoading === 0) {
                    if (this._checkLoadedTimer) {
                        clearTimeout(this._checkLoadedTimer);
                        this._checkLoadedTimer = null
                    }
                    this._checkLoadedTimer = setTimeout(function () {
                        if (e.numLoading === 0) {
                            e.map.dispatchEvent(new a8("ontilesloaded"))
                        }
                        e._checkLoadedTimer = null
                    }, 60)
                }
            },
            isClickableLabel: function (e) {
                if (e.isDel) {
                    return false
                }
                if (e.zoom > 9 && !e.guid) {
                    return false
                }
                if (e.zoom <= 9 && !e.name && !e.guid) {
                    return false
                }
                return true
            }
        };
        var b6 = 5;
        var dU = 4;
        var hm = 3;
        var fc = 2;
        var hG = 1;
        var dX = 0;

        function v(e) {
            this._ratio = a3();
            this._iconCache = {};
            this._map = e;
            this._drawingCanvasPool = [];
            this._drawingCanvasHeight = 4096
        }
        C.extend(v.prototype, {
            _loadIcons: function (i, hR) {
                var hP = 0;
                var hO = this;
                var T = this._map.config.style;
                for (var hQ in i) {
                    hP++;
                    var e = new Image();
                    e.id = hQ;
                    e.crossOrigin = "anonymous";
                    e.onload = function () {
                        hO._iconCache[this.id].loaded = true;
                        hP--;
                        if (hP === 0) {
                            hR()
                        }
                        this.onload = null
                    };
                    e.onerror = function () {
                        hO._iconCache[this.id] = null;
                        hP--;
                        if (hP === 0) {
                            hR()
                        }
                        this.onerror = null
                    };
                    var hN = e0.getIconSetPath(T) + hQ + ".png";
                    e.src = hN;
                    this._iconCache[hQ] = {
                        loaded: false,
                        image: e
                    }
                }
            },
            _getEmptyDrawingCanvas: function () {
                for (var T = 0; T < this._drawingCanvasPool.length; T++) {
                    if (this._drawingCanvasPool[T]._free === true) {
                        this._drawingCanvasPool[T]._free = false;
                        return this._drawingCanvasPool[T]
                    }
                }
                var e = this._createNewDrawingCanvas();
                this._drawingCanvasPool.push(e);
                e._free = false;
                return e
            },
            _createNewDrawingCanvas: function () {
                var e = S("canvas");
                e.width = 512;
                e.height = this._drawingCanvasHeight;
                e._free = true;
                e._id = bl.getGUID();
                var i = e.getContext("2d");
                i.textBaseline = "bottom";
                i.lineJoin = "round";
                return e
            },
            drawLabelsOnCanvas: function (h5, hN) {
                var hV = h5.label.fixedLabel.slice(0);
                var h1 = h5.label.lineLabel.slice(0);
                var T = h5.label.indoorLabel.slice(0);
                if (hV.length === 0 && h1.length === 0 && T.length === 0) {
                    hN();
                    return
                }
                var hQ = function (ia, i) {
                    return ia.styleId - i.styleId
                };
                hV.sort(hQ);
                h1.sort(hQ);
                T.sort(hQ);
                var h4 = {};
                var e = this._getEmptyDrawingCanvas();
                var h0 = e.getContext("2d");
                h0.clearRect(0, 0, e.width, e.height);
                var h8 = 0;
                var hW = null;
                var hP = 0;
                if (hV.length > 0) {
                    while (hP < hV.length && !hV[hP].styleText[0]) {
                        hP++
                    }
                    if (hV[hP] && hV[hP].styleText[0]) {
                        hW = hV[hP].styleText[0].fontSize + hV[hP].styleText[0].haloSize * 2
                    }
                }
                if (hW === null && T.length > 0) {
                    hP = 0;
                    while (hP < T.length && !T[hP].styleText[0]) {
                        hP++
                    }
                    if (T[hP] && T[hP].styleText[0]) {
                        hW = T[hP].styleText[0].fontSize + T[hP].styleText[0].haloSize * 2
                    }
                }
                if (hW === null && h1.length > 0) {
                    hP = 0;
                    while (hP < h1.length && !h1[hP].styleText[0]) {
                        hP++
                    }
                    if (h1[hP] && h1[hP].styleText[0]) {
                        hW = h1[hP].styleText[0].fontSize + h1[hP].styleText[0].haloSize * 2
                    }
                }
                if (hW === null || isNaN(hW)) {
                    hN();
                    return
                }
                var hS = 0;
                var hR = hW;
                var hY = {};
                var h9 = 0;
                var hZ = [];
                for (var h3 = 0; h3 < hV.length; h3++) {
                    var hU = hV[h3];
                    var hX = hU.name;
                    var h2 = hU.styleText;
                    if (!hX || h2.length === 0) {
                        continue
                    }
                    var hO = hU.icon;
                    if (hU.textOnIcon && (!this._iconCache[hO] || this._iconCache[hO].loaded === false)) {
                        hZ.push(hU);
                        h9++;
                        if (!hY[hO]) {
                            hY[hO] = true
                        }
                        continue
                    }
                    var h6 = this._drawEachText(h0, hU, h8, hS, hR, hW, h4);
                    if (!h6) {
                        continue
                    }
                    hS = h6.curX;
                    hR = h6.curY;
                    hW = h6.curLineHeight;
                    h8 = h6.styleId
                }
                var h6 = this._drawEachTypeOfLabels(h0, T, h8, hS, hR, hW, h4);
                h8 = h6.curStyleId;
                hS = h6.curX;
                hR = h6.curY;
                hW = h6.curLineHeight;
                var h6 = this._drawEachTypeOfLabels(h0, h1, h8, hS, hR, hW, h4);
                h8 = h6.curStyleId;
                hS = h6.curX;
                hR = h6.curY;
                hW = h6.curLineHeight;
                if (h9 > 0) {
                    var h7 = this;
                    this._loadIcons(hY, function () {
                        h6 = h7._drawEachTypeOfLabels(h0, hZ, h8, hS, hR, hW, h4);
                        h8 = h6.curStyleId;
                        hS = h6.curX;
                        hR = h6.curY;
                        hW = h6.curLineHeight;
                        var i = h7._generateEachLabelCanvas(e, hR, hV, h1, T, h5);
                        hN(i[0], i[1])
                    });
                    return
                }
                var hT = this._generateEachLabelCanvas(e, hR, hV, h1, T, h5);
                hN(hT[0], hT[1])
            },
            drawCustomLabelsOnCanvas: function (hQ, hW) {
                if (hQ.length === 0) {
                    hW();
                    return
                }
                var T = 0;
                var e = (hQ[0].style.fontSize + (hQ[0].style.haloSize || 0) * 2) || 0;
                var hN = e;
                var hS = this._getEmptyDrawingCanvas();
                var hX = hS.getContext("2d");
                hX.clearRect(0, 0, hS.width, hS.height);
                var hT = {};
                var hV = -1;
                for (var hO = 0; hO < hQ.length; hO++) {
                    if (!hQ[hO].name) {
                        continue
                    }
                    var hU = this._drawEachText(hX, hQ[hO], hV, T, e, hN, hT);
                    if (!hU) {
                        continue
                    }
                    T = hU.curX;
                    e = hU.curY;
                    hN = hU.curLineHeight;
                    hV = hU.styleId
                }
                var hP = e;
                var hR = this._copyToNewCanvas(hS, hP);
                for (var hO = 0; hO < hQ.length; hO++) {
                    if (!hQ[hO].name && hQ[hO].style.iconSize) {
                        this._addFixedLabelBounds(hQ[hO]);
                        continue
                    }
                    if (!hQ[hO].textSize) {
                        continue
                    }
                    this._updateFixedLabelCoords(hQ[hO], hP);
                    this._addFixedLabelBounds(hQ[hO])
                }
                hW(hR)
            },
            _drawEachTypeOfLabels: function (hW, hQ, hU, hN, T, hO, hS) {
                for (var hP = 0; hP < hQ.length; hP++) {
                    var hR = hQ[hP];
                    var hV = hR.name;
                    var e = hR.styleText;
                    if (!hV || e.length === 0) {
                        continue
                    }
                    var hT = this._drawEachText(hW, hR, hU, hN, T, hO, hS);
                    if (!hT) {
                        continue
                    }
                    hN = hT.curX;
                    T = hT.curY;
                    hO = hT.curLineHeight;
                    hU = hT.styleId;
                    if (hT.curY > this._drawingCanvasHeight) {
                        return {
                            curX: hN,
                            curY: T,
                            curLineHeight: hO,
                            curStyleId: hU
                        }
                    }
                }
                return {
                    curX: hN,
                    curY: T,
                    curLineHeight: hO,
                    curStyleId: hU
                }
            },
            _drawIndoorTextLabelOnCanvas: function (hO) {
                var e = this._getEmptyDrawingCanvas();
                var hV = e.getContext("2d");
                hV.clearRect(0, 0, e.width, e.height);
                var h3 = 0;
                var hU = null;
                var hT = 0;
                var hR;
                var h0 = {};
                var hZ = [];
                for (var hP in hO) {
                    if (hP === "tileInfo") {
                        continue
                    }
                    var hN = hO[hP];
                    var hY = hN.defaultFloor;
                    var hS = hN.floors;
                    for (var hX = 0; hX < hS.length; hX++) {
                        if (hX === hY) {
                            continue
                        }
                        var h1 = hS[hX];
                        if (!h1.pois) {
                            continue
                        }
                        var hQ = h1.pois;
                        for (var hW = 0; hW < hQ.length; hW++) {
                            if (hU === null && hQ[hW].styleText[0]) {
                                hU = hQ[hW].styleText[0].fontSize + hQ[hW].styleText[0].haloSize * 2;
                                hR = hU
                            }
                            hZ.push(hQ[hW])
                        }
                    }
                }
                if (hU === null) {
                    return null
                }
                hZ.sort(function (h4, i) {
                    return i.rank - h4.rank || h4.styleId - i.styleId
                });
                var h2 = this._drawEachTypeOfLabels(hV, hZ, h3, hT, hR, hU, h0);
                h3 = h2.curStyleId;
                hT = h2.curX;
                hR = h2.curY;
                hU = h2.curLineHeight;
                var T = this._copyToNewCanvas(e, hR);
                return T
            },
            _updateIndoorLabelsCoords: function (hU, hV) {
                for (var hT in hU) {
                    if (hT === "tileInfo") {
                        continue
                    }
                    var e = hU[hT];
                    var hP = e.defaultFloor;
                    var hQ = e.floors;
                    for (var hR = 0; hR < hQ.length; hR++) {
                        if (hR === hP) {
                            continue
                        }
                        var T = hQ[hR];
                        if (!T.pois) {
                            continue
                        }
                        var hO = T.pois;
                        for (var hN = 0; hN < hO.length; hN++) {
                            var hS = hO[hN];
                            if (hS.name && (!hS.textSize || hS.textSize.length === 0)) {
                                hO.splice(hN, 1);
                                hN--;
                                continue
                            }
                            this._updateFixedLabelCoords(hS, hV);
                            this._addFixedLabelBounds(hS)
                        }
                    }
                }
            },
            _generateEachLabelCanvas: function (hQ, hP, hR, e, hT, T) {
                hP = Math.min(hP, this._drawingCanvasHeight);
                var hS = this._copyToNewCanvas(hQ, hP);
                var hN = null;
                if (T.renderData.indoorData) {
                    hN = this._drawIndoorTextLabelOnCanvas(T.renderData.indoorData);
                    if (hN) {
                        this._updateIndoorLabelsCoords(T.renderData.indoorData, hN.height)
                    }
                }
                for (var hO = 0; hO < hR.length; hO++) {
                    if (!hR[hO].textSize) {
                        continue
                    }
                    this._updateFixedLabelCoords(hR[hO], hP);
                    this._addFixedLabelBounds(hR[hO])
                }
                for (var hO = 0; hO < hT.length; hO++) {
                    if (!hT[hO].textSize) {
                        continue
                    }
                    this._updateFixedLabelCoords(hT[hO], hP);
                    this._addFixedLabelBounds(hT[hO])
                }
                for (var hO = 0; hO < e.length; hO++) {
                    this._updateLineLabelCoords(e[hO], hP)
                }
                return [hS, hN]
            },
            _copyToNewCanvas: function (T, i) {
                if (i === 0) {
                    return null
                }
                var hN = S("canvas");
                hN.width = T.width;
                hN.height = i;
                var e = hN.getContext("2d");
                e.drawImage(T, 0, 0, 512, i, 0, 0, 512, i);
                hN._id = T._id;
                T._free = true;
                return hN
            },
            _drawEachText: function (h5, hR, T, h7, h6, ie, hO) {
                var id = hR.name;
                var hW = hR.styleText ? hR.styleText[0] : hR.style;
                if (!hW) {
                    return null
                }
                var hZ = hW.fontSize;
                var ij = hW.fontWeight;
                var iy = hW.haloSize || 0;
                if (!h0) { }
                if (hW.fontRgba) {
                    var iE = hW.fontRgba[3] / 255;
                    var hV = [];
                    hV[3] = iE;
                    for (var iD = 0; iD < 3; iD++) {
                        hV[iD] = hW.fontRgba[iD]
                    }
                }
                if (hW.haloRgba) {
                    var iE = hW.haloRgba[3] / 255;
                    var h2 = [];
                    h2[3] = iE;
                    for (var iD = 0; iD < 3; iD++) {
                        h2[iD] = hW.haloRgba[iD]
                    }
                }
                var ir = hV ? "rgba(" + hV.join(",") + ")" : hW.color;
                var hQ = h2 ? "rgba(" + h2.join(",") + ")" : hW.strokeColor;
                var iA = hR.styleId || 0;
                if (iy > 4) {
                    iy = 4
                }
                var ig = [];
                var h4 = [];
                var ib = 0;
                if (hO && !hO[iA]) {
                    hO[iA] = {}
                }
                var hY = hZ + iy * 2;
                var ih = hY;
                if (hR.containDescendings) {
                    ih += 4
                }
                if (iy === 0) {
                    ih += 2
                }
                if (hR.textOnIcon) {
                    ih = Math.max(ih, hR.iconSize[1])
                }
                if (iA !== T || ih > ie) {
                    T = iA;
                    if (ij >= 10 && ij % 10 === 0) {
                        h5.font = ij * 10 + " " + hZ + "px sans-serif"
                    } else {
                        h5.font = hZ + "px sans-serif"
                    } if (ih > ie) {
                        var ic = ih - ie;
                        ie += ic;
                        h6 += ic
                    }
                    if (iy > 0) {
                        h5.lineWidth = iy * 2;
                        h5.strokeStyle = hQ
                    }
                    h5.fillStyle = ir
                }
                if (hR.type === "line") {
                    var hT = id.split("");
                    for (var iB = 0; iB < hT.length; iB++) {
                        var iu = hT[iB];
                        var h8;
                        var ik;
                        if (hO[iA][iu]) {
                            var h0 = hO[iA][iu];
                            h8 = h0.displaySize;
                            ik = h0.curWordPosition
                        } else {
                            var hN = Math.ceil(h5.measureText(iu).width);
                            if (h7 + hN > 512) {
                                h7 = 0;
                                h6 += ih;
                                ie = ih
                            }
                            if (h6 > this._drawingCanvasHeight) {
                                return {
                                    curX: h7,
                                    curY: h6,
                                    curLineHeight: ie,
                                    styleId: iA
                                }
                            }
                            var iv = h7;
                            if (iy > 0) {
                                hN += iy;
                                iv -= Math.round(iy / 2);
                                h5.strokeText(iu, h7, h6)
                            }
                            h5.fillText(iu, h7, h6);
                            var iq = [hN, ih];
                            h8 = [Math.round(iq[0] / 2), Math.round(iq[1] / 2)];
                            ik = [iv, h6 - ih];
                            hO[iA][iu] = {
                                displaySize: h8,
                                curWordPosition: ik,
                                totalHeight: ib
                            };
                            h7 += hN + 2
                        }
                        ig.push(h8);
                        h4.push(ik)
                    }
                    ib = Math.round(ig[0][1])
                } else {
                    if (hO[iA][id]) {
                        var h0 = hO[iA][id];
                        ig = h0.textSize;
                        h4 = h0.labelImagePosition;
                        ib = h0.totalHeight
                    } else {
                        var h1 = id.split("\\");
                        if (h1.length > 1 && hR.textOnIcon) {
                            var iC = 0;
                            var iz = 0;
                            var iF = [];
                            var h9 = 8;
                            for (var iB = 0; iB < h1.length; iB++) {
                                var id = h1[iB];
                                var hX = Math.ceil(h5.measureText(id).width);
                                if (hX > iC) {
                                    iC = hX
                                }
                                iF.push(Math.round(hX / 2));
                                iz += ih
                            }
                            var hU = iC + 2 * h9;
                            var ix = iz + 2 * h9;
                            if (h7 + hU > 512) {
                                h7 = 0;
                                h6 += ie
                            }
                            h6 += iz - ih + 2 * h9;
                            var ip = h7;
                            var ia = h6 - ix;
                            var e = Math.round(hU / 2);
                            var h3 = this._iconCache[hR.icon].image;
                            this.drawStretchedIcon(h5, h3, [ip, ia], h9, iC, iz);
                            for (var iB = 0; iB < h1.length; iB++) {
                                var id = h1[iB];
                                var iw = ip + (e - iF[iB]);
                                var it = ia + 4 + (iB + 1) * ih;
                                h5.fillText(id, iw, it)
                            }
                            ig.push([Math.round(hU / 2), Math.round(ix / 2)]);
                            h4.push([ip, ia]);
                            h7 += hU;
                            ie = ix;
                            ib = Math.round(ix / 2)
                        } else {
                            for (var iB = 0; iB < h1.length; iB++) {
                                var id = h1[iB];
                                var hX = Math.ceil(h5.measureText(id).width);
                                var hU = hX;
                                var hP = 0;
                                if (hR.textOnIcon) {
                                    hP = 10;
                                    hU += hP * 2;
                                    if (hR.styleId === 519) {
                                        hU = hR.iconSize[0];
                                        hP = Math.round((hU - hX) / 2)
                                    }
                                }
                                if (h7 + hU > 512) {
                                    h7 = 0;
                                    h6 += ih;
                                    ie = ih
                                }
                                if (h6 > this._drawingCanvasHeight) {
                                    return {
                                        curX: h7,
                                        curY: h6,
                                        curLineHeight: ie,
                                        styleId: iA
                                    }
                                }
                                var ip = h7;
                                var ia = h6 - ih;
                                var io = h7;
                                var im = h6;
                                if (hR.containDescendings) {
                                    im -= 4
                                }
                                if (hR.textOnIcon) {
                                    var ii = false;
                                    var h3 = this._iconCache[hR.icon].image;
                                    var il = hR.iconSize.concat([]);
                                    if (hY > il[1]) {
                                        il[1] = hY;
                                        ii = true
                                    }
                                    if (hX > il[0]) {
                                        il[0] = hX;
                                        ii = true
                                    }
                                    if (hR.styleId === 519) {
                                        h5.drawImage(h3, 0, 0, il[0], il[1], ip, ia, il[0], il[1])
                                    } else {
                                        if (ii) {
                                            this.drawStretchedIcon(h5, h3, [ip, ia], hP, hX, il[1])
                                        } else {
                                            this.draw3StretchedIcon(h5, h3, [ip, ia], hP, hX, il[1])
                                        }
                                    }
                                    io += hP;
                                    if (hR.iconSize[1] > hY) {
                                        im -= (hR.iconSize[1] - hY) / 2 - 1
                                    }
                                    hU += 1
                                }
                                if (iy > 0) {
                                    hU += iy;
                                    ip -= Math.round(iy / 2);
                                    ia += Math.round(iy / 2);
                                    if (iA === 71028) {
                                        ih -= 2
                                    }
                                    if (iA === 32) {
                                        ih -= 2
                                    }
                                    h5.strokeText(id, io, im)
                                }
                                h5.fillText(id, io, im);
                                var hS = [hU, ih];
                                var h8 = [Math.round(hS[0] / 2), Math.round(hS[1] / 2)];
                                ig.push(h8);
                                h4.push([ip, ia]);
                                ib += Math.round(h8[1]);
                                h7 += hU
                            }
                        }
                        hO[iA][id] = {
                            textSize: ig,
                            labelImagePosition: h4,
                            totalHeight: ib
                        }
                    }
                }
                hR.textSize = ig;
                hR.labelImagePosition = h4;
                hR.totalHeight = ib;
                return {
                    curX: h7,
                    curY: h6,
                    curLineHeight: ie,
                    styleId: iA
                }
            },
            drawStretchedIcon: function (e, T, hN, hQ, hR, i) {
                var hP = hN[0];
                var hO = hN[1];
                e.drawImage(T, 0, 0, hQ, hQ, hP, hO, hQ, hQ);
                e.drawImage(T, hQ, 0, 1, hQ, hP + hQ, hO, hR, hQ);
                e.drawImage(T, T.width - hQ, 0, hQ, hQ, hP + hR + hQ, hO, hQ, hQ);
                e.drawImage(T, 0, hQ, hQ, 1, hP, hO + hQ, hQ, i);
                e.drawImage(T, hQ, hQ, 1, 1, hP + hQ, hO + hQ, hR, i);
                e.drawImage(T, T.width - hQ, hQ, hQ, 1, hP + hR + hQ, hO + hQ, hQ, i);
                e.drawImage(T, 0, T.height - hQ, hQ, hQ, hP, hO + i + hQ, hQ, hQ);
                e.drawImage(T, hQ, T.height - hQ, 1, hQ, hP + hQ, hO + i + hQ, hR, hQ);
                e.drawImage(T, T.width - hQ, T.height - hQ, hQ, hQ, hP + hR + hQ, hO + i + hQ, hQ, hQ)
            },
            draw3StretchedIcon: function (e, i, T, hP, hR, hQ) {
                var hO = T[0];
                var hN = T[1];
                e.drawImage(i, 0, 0, hP, i.height, hO, hN, hP, i.height);
                e.drawImage(i, hP, 0, 1, i.height, hO + hP, hN, hR, i.height);
                e.drawImage(i, i.width - hP, 0, hP, i.height, hO + hP + hR, hN, hP, i.height)
            },
            _updateFixedLabelCoords: function (hO, h3) {
                if (h3 === 0) {
                    return
                }
                var hY = [];
                var ia = [];
                var ib = 0;
                var h1 = hO.totalHeight;
                var ik = hO.textSize.length;
                var hP = hO.direction;
                if (typeof hP !== "number") {
                    hP = 0
                }
                for (var ic = 0; ic < ik; ic++) {
                    var h4 = hO.labelImagePosition[ic];
                    var h2 = hO.textSize[ic];
                    var h0 = h4[0];
                    var hN = h4[1];
                    var hQ = h2[0];
                    var hV = h2[1];
                    var hX = 0;
                    var h9 = 0;
                    if (typeof hO.textMargin === "number") {
                        h9 = hO.textMargin
                    }
                    var hW;
                    var e;
                    var hS = 0;
                    var hZ = 0;
                    if (!hO.iconPos) {
                        if (!hO.custom) {
                            hP = dU
                        }
                    } else {
                        hS = hO.iconPos.width;
                        hZ = hO.iconPos.height
                    }
                    switch (hP) {
                        case hm:
                            var T = h1 / 2 - hV + hX * (ik - 1) / 2;
                            hW = Math.round(-hS / 2 - hQ - h9);
                            e = Math.round(T - ib - hX * ic);
                            break;
                        case hG:
                            var T = h1 / 2 - hV + hX * (ik - 1) / 2;
                            hW = Math.round(hS / 2 + h9);
                            e = Math.round(T - ib - hX * ic);
                            break;
                        case fc:
                            var T = hZ / 2 + h1 - hV + hX * ik;
                            hW = Math.round(-hQ / 2);
                            e = Math.round(T - ib - hX * ic);
                            break;
                        case dX:
                            var T = -hZ / 2 - hX - hV;
                            hW = Math.round(-hQ / 2);
                            e = Math.round(T - ib - hX * ic);
                            break;
                        case dU:
                            var T = -h1 / 2 - hX * (ik - 1) / 2;
                            hW = Math.round(-hQ / 2);
                            e = Math.round(T - ib - hX * ic);
                            break
                    }
                    ib += hV;
                    var hU = hW + hQ;
                    var il = e;
                    var hT = hU;
                    var ij = il + hV;
                    var hR = hW;
                    var ii = ij;
                    hY.push(hW, e, hU, il, hT, ij, hW, e, hT, ij, hR, ii);
                    var ih = h0 / 512;
                    var h8 = (h3 - hN - hV * 2) / h3;
                    var ig = (h0 + hQ * 2) / 512;
                    var h7 = h8;
                    var ie = ig;
                    var h6 = (h3 - hN) / h3;
                    var id = ih;
                    var h5 = h6;
                    ia.push(ih, h8, ig, h7, ie, h6, ih, h8, ie, h6, id, h5)
                }
                if (!hO.textPos) {
                    hO.textPos = {}
                }
                hO.textPos.vertex = hY;
                hO.textPos.texcoord = ia
            },
            _addFixedLabelBounds: function (hT) {
                var hP = 1000;
                var hN = 1000;
                var T = -1000;
                var e = -1000;
                if (hT.iconPos) {
                    var hR = hT.iconPos["vertex"];
                    for (var hS = 0, hO = hR.length; hS < hO; hS += 2) {
                        var hX = hR[hS];
                        var hV = hR[hS + 1];
                        if (hX < hP) {
                            hP = hX
                        }
                        if (hX > T) {
                            T = hX
                        }
                        if (hV < hN) {
                            hN = hV
                        }
                        if (hV > e) {
                            e = hV
                        }
                    }
                }
                if (hT.custom && hT.style.iconSize && !hT.name) {
                    var hU = hT.style.iconSize;
                    var hW = hT.direction;
                    switch (hW) {
                        case dU:
                            hP = -Math.round(hU[0] / 2);
                            hN = -Math.round(hU[1] / 2);
                            T = Math.round(hU[0] / 2);
                            e = Math.round(hU[1] / 2);
                            break;
                        case fc:
                            hP = -Math.round(hU[0] / 2);
                            hN = 0;
                            T = Math.round(hU[0] / 2);
                            e = hU[1];
                            break
                    }
                }
                if (hT.textPos) {
                    var hQ = hT.textPos["vertex"];
                    for (var hS = 0, hO = hQ.length; hS < hO; hS += 2) {
                        var hX = hQ[hS];
                        var hV = hQ[hS + 1];
                        if (hX < hP) {
                            hP = hX
                        }
                        if (hX > T) {
                            T = hX
                        }
                        if (hV < hN) {
                            hN = hV
                        }
                        if (hV > e) {
                            e = hV
                        }
                    }
                }
                hT.bds = [hP, hN, T, e]
            },
            _updateLineLabelCoords: function (h4, hU) {
                if (hU === 0) {
                    return
                }
                var hN = h4.wordsInfo;
                var h1 = h4.wordCount;
                if (!h4.labelImagePosition) {
                    return
                }
                var hW = h4.labelImagePosition.slice(0);
                if (h4.reverse) {
                    hW.reverse()
                }
                var id = 1000;
                var ia = 1000;
                var ib = -1000;
                var h9 = -1000;
                for (var h5 = 0; h5 < h1; h5++) {
                    var ie = hW[h5];
                    var ic = ie[0];
                    var h2 = ie[1];
                    var h0 = h4.textSize[h5];
                    var hT = h0[0];
                    var e = h0[1];
                    var hS = ic / 512;
                    var hZ = (hU - h2 - e * 2) / hU;
                    var hQ = (ic + hT * 2) / 512;
                    var hY = hZ;
                    var hO = hQ;
                    var hX = (hU - h2) / hU;
                    var T = hS;
                    var hV = hX;
                    hN[h5].size = [hT, e];
                    hN[h5].texcoord = [hS, hZ, hQ, hY, hO, hX, hS, hZ, hO, hX, T, hV];
                    var h8 = hN[h5].offset[0];
                    var h7 = hN[h5].offset[1];
                    var h6 = h8 - hT / 2;
                    var hR = h7 + e / 2;
                    var hP = h7 - e / 2;
                    var h3 = h8 + hT / 2;
                    if (h6 < id) {
                        id = h6
                    }
                    if (h3 > ib) {
                        ib = h3
                    }
                    if (hP < ia) {
                        ia = hP
                    }
                    if (hR > h9) {
                        h9 = hR
                    }
                }
                h4.bds = [id, ia, ib, h9]
            }
        });
        var cQ = {
            0: "00000000",
            16: "00010000",
            32: "00100000",
            48: "00110000",
            64: "01000000",
            96: "01100000"
        };

        function cn(T, hN, hO) {
            var e = T.bds;
            if (!e) {
                return false
            }
            var i = T.tracer;
            var hR;
            if (i) {
                if (!cQ[i]) {
                    hR = i.toString(2);
                    if (hR.length < 8) {
                        hR = new Array(8 - hR.length + 1).join("0") + hR
                    }
                    cQ[i] = hR
                }
                hR = cQ[i];
                var hQ = df.mapZoomStartZoomMapping[hN];
                return hR[hN - hQ] === "1"
            }
            var hP = T.displayRange;
            if (hO >= hP[0] && hO <= hP[1]) {
                return true
            }
            return false
        }

        function dg(i, e) {
            this.map = i.map;
            this.layer = i;
            e = e || [];
            this.allLabels = [];
            this._spotData = [];
            this._strategyInfo = null;
            this.RANK1 = 1000000;
            this.RANK2 = 2000000;
            this.RANK3 = 3000000;
            this.RANK4 = 4000000;
            this.RANK5 = 5000000;
            this._useRound = false;
            this._mapIsMoving = false;
            this._onMapIdleCallback = e.onMapIdleCallback;
            this.map.temp.isPermitSpotOver = true;
            this.currentSelectedLabel = null;
            this.map._labelProcessor = this;
            this.iconCache = {};
            this.fixedLabelData = [];
            this.lineLabelData = [];
            this.highlightLabelData = [];
            this._iconLoadTimer = null;
            this._labelTextCanvas = null;
            if (this.map.config.textRenderType === "canvas") {
                this._labelTextCanvas = this.map.tileMgr.getLabelTextCanvas()
            }
            this.bind()
        }
        C.extend(dg.prototype, {
            bind: function () {
                var T = this.map;
                var i = this;
                T.addEventListener("mapstatusbusy_inner", function (hN) {
                    i._useRound = false;
                    i._mapIsMoving = true
                });
                T.addEventListener("mapstatusidle_inner", function (hN) {
                    if (!f1()) {
                        i._useRound = true
                    }
                    i._mapIsMoving = false
                });
                T.addEventListener("onspotmouseover", function (hP) {
                    if (!this.temp.isPermitSpotOver) {
                        return
                    }
                    if (hP.spots.length > 0) {
                        var hO = hP.spots[0].userdata.uid;
                        var hQ = hP.spots[0].userdata.tilePosStr;
                        var hN = i.getLabelByUid(hO, hQ);
                        hN && hN.formatedData && i._toHighlightColor(hN.formatedData)
                    }
                });
                T.addEventListener("onspotmouseout", function (hP) {
                    if (!this.temp.isPermitSpotOver) {
                        return
                    }
                    if (hP.spots.length > 0) {
                        var hO = hP.spots[0].userdata.uid;
                        var hQ = hP.spots[0].userdata.tilePosStr;
                        var hN = i.getLabelByUid(hO, hQ);
                        hN && hN.formatedData && i._toDefaultColor(hN.formatedData)
                    }
                });
                T.addEventListener("spotclick", function (hP) {
                    if (hP.spots && hP.spots.length > 0) {
                        if (hP.spots[0].userdata.zoom < 10) {
                            return
                        }
                        var hO = hP.spots[0].userdata.uid;
                        var hQ = hP.spots[0].userdata.tilePosStr;
                        if (i.currentSelectedLabel && (i.currentSelectedLabel.uid !== hO || i.currentSelectedLabel.tilePosStr !== hQ)) {
                            i._recoverNormalState()
                        }
                        var hN = i.getLabelByUid(hO, hQ);
                        hN && i._changeBaseMapState(hN)
                    } else {
                        i._recoverNormalState()
                    }
                });
                T.on("spot_status_reset", function () {
                    i._recoverNormalState()
                });
                T.on("spot_highlight", function (hO) {
                    var hN = i.getLabelByUid(hO.uid, hO.tilePosStr);
                    hN && hN.formatedData && i._toHighlightColor(hN.formatedData)
                });
                T.addEventListener("mousemove", function (hN) {
                    if (i.curSpotAdded) {
                        return
                    }
                    if (this.currentOperation !== dR.idle || i._mapIsMoving === true) {
                        return
                    }
                    i._refreshSpotData();
                    this.temp.isPermitSpotOver = true;
                    i.curSpotAdded = true
                });
                if (f1()) {
                    function e() {
                        i._refreshSpotData()
                    }
                    T.addEventListener("mapstatusidle_inner", e)
                }
                T.on("style_loaded", function () {
                    if (i.map.config.textRenderType === "canvas" && !i._labelTextCanvas) {
                        i._labelTextCanvas = i.map.tileMgr.getLabelTextCanvas()
                    }
                })
            },
            getLabelByUid: function (hQ, hR) {
                var e = this.map._featureMgr.getResult().tileLabels;
                for (var hP = 0; hP < e.length; hP++) {
                    var T = e[hP].fixedLabel;
                    for (var hO = 0; hO < T.length; hO++) {
                        if (e[hP].fixedLabel[hO].guid === hQ && e[hP].fixedLabel[hO].tilePosStr === hR) {
                            return e[hP].fixedLabel[hO]
                        }
                    }
                    var hN = e[hP].indoorLabel;
                    for (var hO = 0; hO < hN.length; hO++) {
                        if (e[hP].indoorLabel[hO].guid === hQ && e[hP].indoorLabel[hO].tilePosStr === hR) {
                            return e[hP].indoorLabel[hO]
                        }
                    }
                }
                return null
            },
            getTileByLabelUid: function (hQ) {
                var e = this.map._featureMgr.getResult().tileLabels;
                for (var hP = 0; hP < e.length; hP++) {
                    var T = e[hP].fixedLabel;
                    for (var hO = 0; hO < T.length; hO++) {
                        if (e[hP].fixedLabel[hO].guid === hQ) {
                            return e[hP]
                        }
                    }
                    var hN = e[hP].indoorLabel;
                    for (var hO = 0; hO < hN.length; hO++) {
                        if (e[hP].indoorLabel[hO].guid === hQ) {
                            return e[hP]
                        }
                    }
                }
                return null
            },
            _toHighlightColor: function (T) {
                if (T.tempRank && T.tempRank === this.RANK5) {
                    return
                }
                var e = this.map._featureMgr.getResult().eleData[4] || [];
                var hO = false;
                for (var hN = 0; hN < e.length; hN++) {
                    if (e[hN] === T || (e[hN].guid === T.guid && e[hN].tilePosStr === T.tilePosStr && e[hN].zoom === T.zoom)) {
                        hO = true;
                        break
                    }
                }
                if (hO) {
                    return
                }
                e.push(T);
                this.map._featureMgr.setOverlayData(e, 4);
                this.map.dispatchEvent(new a8("onrefresh"))
            },
            _toDefaultColor: function (T) {
                if (T.tempRank && T.tempRank === this.RANK5) {
                    return
                }
                var e = this.map._featureMgr.getResult().eleData[4] || [];
                for (var hN = 0; hN < e.length; hN++) {
                    if (T === e[hN] || (T.guid === e[hN].guid && T.tilePosStr === e[hN].tilePosStr && T.zoom === e[hN].zoom)) {
                        e.splice(hN, 1);
                        break
                    }
                }
                this.map._featureMgr.setOverlayData(e, 4);
                this.map.dispatchEvent(new a8("onrefresh"))
            },
            _changeBaseMapState: function (i) {
                var hO = i.guid;
                var hS = i.formatedData.guidExt;
                var hU = {
                    guid: hO,
                    tilePosStr: i.tilePosStr,
                    guidExt: hS
                };
                this._strategyInfo = hU;
                this.currentSelectedLabel = i;
                var hN = this.map._featureMgr;
                var e = hN.getLabelData();
                e = this.collisionTest(e);
                this.updateLabels(e);
                var hV = this.fixDataFormat(e);
                hN.setOverlayData(hV[0], 2);
                hN.setOverlayData(hV[1], 3);
                hN.setOverlayData(hV[2], 4);
                var T = this.getTileByLabelUid(hO);
                this.currentSelectedLabel.tileInfo = T.tileInfo;
                var hT = T.tileInfo.zoom;
                var hR = this.layer.tileCache.getAllData();
                for (var hQ in hR) {
                    var hP = hR[hQ].data;
                    if (!hP.label) {
                        continue
                    }
                    this.clearCollisionCache(hP.label)
                }
                this.map.dispatchEvent(new a8("onrefresh"))
            },
            _recoverNormalState: function () {
                this._strategyInfo = null;
                var hR = false;
                var hP = this.map._featureMgr.getLabelData();
                if (this.currentSelectedLabel) {
                    var T = this.currentSelectedLabel.guid;
                    this.clearCollisionCache(this.getTileByLabelUid(T));
                    var hO = this.layer.tileCache.getAllData();
                    for (var hN in hO) {
                        var hQ = hO[hN].data;
                        if (!hQ.label) {
                            continue
                        }
                        this.clearCollisionCache(hQ.label)
                    }
                    this.currentSelectedLabel.tempRank = null;
                    this.currentSelectedLabel = null;
                    hR = true
                }
                hP = this.collisionTest(hP);
                this.updateLabels(hP);
                var e = this.fixDataFormat(hP);
                var i = this.map._featureMgr;
                i.setOverlayData(e[0], 2);
                i.setOverlayData(e[1], 3);
                i.setOverlayData([], 4);
                this.map.dispatchEvent(new a8("onrefresh"));
                if (hR) {
                    this.curSpotAdded = false;
                    this._refreshSpotData()
                }
            },
            loadIconImages: function (hO, hZ) {
                var hR = hO.label;
                var hP = hO.tileInfo.style;
                var T = hR.fixedLabel;
                var hW = hR.indoorLabel;
                var h0 = T.length + hW.length;
                var hT = this;
                var hN = 0;
                var hY = 200;
                for (var hQ = 0; hQ < h0; hQ++) {
                    var hS;
                    if (hQ < T.length) {
                        hS = T[hQ]
                    } else {
                        hS = hW[hQ - T.length]
                    } if (!hS.iconPos) {
                        continue
                    }
                    var hV = hS.iconPos.iconType;
                    var hX = hP + "_" + hV;
                    hN++;
                    if (this.iconCache[hX]) {
                        if (this.iconCache[hX].loaded) {
                            hZ(hO)
                        }
                        continue
                    }
                    var hU = new Image();
                    hU.id = hX;
                    hU.crossOrigin = "anonymous";
                    hU.onload = function () {
                        hT.iconCache[this.id].loaded = true;
                        hT._addToIconTexture(this);
                        if (hT._iconLoadTimer === null) {
                            hT._iconLoadTimer = setTimeout(function () {
                                hZ();
                                hT._iconLoadTimer = null
                            }, hY)
                        }
                        this.onload = null
                    };
                    hU.onerror = function () {
                        if (!hT._iconLoadTimer) {
                            hT._iconLoadTimer = setTimeout(function () {
                                hZ();
                                hT._iconLoadTimer = null
                            }, hY)
                        }
                        hT.iconCache[this.id] = null;
                        this.onerror = null
                    };
                    var e = e0.getIconSetPath(this.map.config.style) + hV + ".png";
                    hU.src = e;
                    this.iconCache[hX] = {
                        loaded: false,
                        image: hU
                    }
                }
                return hN
            },
            _addToIconTexture: function (hP) {
                if (!this.map._webglMapScene) {
                    return
                }
                var hR = this.map._webglMapScene._painter;
                var e = hR._iconTextureAtlas.addTexture(hP);
                hR._iconTextureAtlasOffset[hP.id] = e;
                var hU = 0 * hP.width / 1024 + e.width;
                var hO = 0 * hP.height / 1024 + e.height;
                var hT = hP.width / 1024 + e.width;
                var hN = hO;
                var hS = hT;
                var T = hP.height / 1024 + e.height;
                var hQ = hU;
                var i = T;
                hR._iconTextureAtlasCoords[hP.id] = [hU, hO, hT, hN, hS, T, hU, hO, hS, T, hQ, i]
            },
            loadImgByStr: function (hN, hO, hP) {
                if (!hN && !hO) {
                    hP && hP(null, null);
                    return
                }
                if (typeof hN === "object" && typeof hO === "object") {
                    hP(hN, hO);
                    return
                }
                var i = 0;
                var T = null;
                var e = null;
                if (hN) {
                    i++;
                    T = new Image();
                    T.onload = function () {
                        i--;
                        if (i === 0) {
                            hP && hP(this, e)
                        }
                        this.onload = null
                    };
                    T.src = hN
                }
                if (hO) {
                    i++;
                    e = new Image();
                    e.onload = function () {
                        i--;
                        if (i === 0) {
                            hP && hP(T, this)
                        }
                        this.onload = null
                    };
                    e.src = hO
                }
            },
            collisionTest: function (hU, iA, ic) {
                if (this.map.viewAnimationTime) {
                    return []
                }
                if (!hU) {
                    return []
                }
                var h4 = this.map;
                var ik = h4.getHeading();
                ik = this.calcLoopHeading(ik);
                var iv = h4.height;
                var iq = this.allLabels;
                iq.length = 0;
                hU.sort(function (iC, i) {
                    var iE = iC.tileInfo;
                    var iD = i.tileInfo;
                    if (iE.col * iE.row < iD.col * iD.row) {
                        return -1
                    } else {
                        return 1
                    }
                });
                var hV = hU.labelZoom;
                var h5 = h4.getTilt();
                var hX = h4.getZoom();
                var ip;
                if (ic) {
                    ip = ic
                } else {
                    ip = this.getZoomStep()
                }
                for (var iy = 0, iw = hU.length; iy < iw; iy++) {
                    var h8 = hU[iy];
                    var hS = h8.tileInfo;
                    var hP = hS.zoom;
                    var io = hS.loopOffsetX / Math.pow(2, 18 - hP);
                    if (!ik && !h5) {
                        if (h8.unnecessaryCollisionTest && h8.unnecessaryCollisionTest[ic]) {
                            continue
                        }
                    }
                    var ig = h8.fixedLabel || [];
                    for (var ix = 0, ia = ig.length; ix < ia; ix++) {
                        var hQ = ig[ix];
                        hQ.zoom = hP;
                        if (iA === -1 && hQ.isDel) {
                            continue
                        }
                        if (!cn(hQ, hS.useZoom, hX)) {
                            hQ.isDel = true;
                            continue
                        }
                        this.calcCollisionBounds(hQ, ip, io, iv);
                        iq.push(hQ)
                    }
                    var ie = h8.indoorLabel || [];
                    for (var ix = 0, ia = ie.length; ix < ia; ix++) {
                        var hQ = ie[ix];
                        hQ.zoom = hP;
                        if (iA === -1 && hQ.isDel) {
                            continue
                        }
                        if (!cn(hQ, hS.useZoom)) {
                            hQ.isDel = true;
                            continue
                        }
                        this.calcCollisionBounds(hQ, ip, io, iv);
                        iq.push(hQ)
                    }
                    var hR = h8.lineLabel || [];
                    for (var ix = 0, ia = hR.length; ix < ia; ix++) {
                        var hQ = hR[ix];
                        if (iA === -1 && hQ.isDel) {
                            continue
                        }
                        if (!cn(hQ, hS.useZoom)) {
                            hQ.isDel = true;
                            continue
                        }
                        var iB = hQ.pt;
                        var ib = h4.pointToPixelIn(iB, {
                            zoom: ip,
                            useRound: this._useRound
                        });
                        var h9 = ib.x + io;
                        var h7 = iv - ib.y;
                        var id = hQ.bds;
                        var iu = id[0];
                        var ir = id[1];
                        var h2 = id[2];
                        var h1 = id[3];
                        var il = iu;
                        var ij = ir;
                        var h0 = h2;
                        var hZ = h1;
                        if ((ik >= 0 && ik < 45) || (ik >= 315 && ik < 360)) {
                            il = iu;
                            ij = ir;
                            h0 = h2;
                            hZ = h1
                        } else {
                            if (ik >= 45 && ik < 135) {
                                il = ir;
                                ij = -h2;
                                h0 = h1;
                                hZ = -iu
                            } else {
                                if (ik >= 135 && ik < 225) {
                                    il = -h2;
                                    ij = -h1;
                                    h0 = -iu;
                                    hZ = -ir
                                } else {
                                    if (ik >= 225 && ik < 315) {
                                        il = -h1;
                                        ij = iu;
                                        h0 = -ir;
                                        hZ = h2
                                    }
                                }
                            }
                        }
                        hQ._tempBds = [h9 + il, h7 + ij, h9 + h0, h7 + hZ];
                        var hT = h4.pixelToPointIn(new eg(hQ._tempBds[0], ib.y + ij), {
                            zoom: ip
                        });
                        var hN = h4.pixelToPointIn(new eg(hQ._tempBds[2], ib.y + hZ), {
                            zoom: ip
                        });
                        hQ._mcBds = [hT, hN];
                        iq.push(hQ)
                    }
                }
                var im = this._strategyInfo;
                if (im) {
                    var hY = im.guid;
                    var h6 = im.guidExt;
                    var T = false;
                    for (var iy = 0, iw = iq.length; iy < iw; iy++) {
                        var it = iq[iy];
                        delete it.tempRank;
                        if (!this.layer.isClickableLabel(it) || (h6 === 1 && !it.guidExt)) {
                            continue
                        }
                        if (hY === it.guid && im.tilePosStr === it.tilePosStr) {
                            it.tempRank = this.RANK5;
                            T = true
                        }
                    }
                    if (!T && this.currentSelectedLabel) {
                        this.currentSelectedLabel.tempRank = this.RANK5;
                        var hS = this.currentSelectedLabel.tileInfo;
                        var hP = hS.zoom;
                        var io = hS.loopOffsetX / Math.pow(2, 18 - hP);
                        this.calcCollisionBounds(this.currentSelectedLabel, ip, io, iv);
                        iq.push(this.currentSelectedLabel)
                    }
                } else {
                    for (var iy = 0, iw = iq.length; iy < iw; iy++) {
                        var it = iq[iy];
                        if (it.type === "line" || !it.iconPos) {
                            continue
                        }
                        delete it.tempRank
                    }
                }
                iq.sort(function (iD, iC) {
                    var iE = iD.tempRank ? iD.tempRank : iD.rank;
                    var i = iC.tempRank ? iC.tempRank : iC.rank;
                    return i - iE || iD.startZoom - iC.startZoom || iC.pt.lng - iD.pt.lng || iC.pt.lat - iD.pt.lat
                });
                var hO = 0;
                if (h5 > 0) {
                    hO = 6
                }
                var hX = h4.getZoom();
                if (hX >= 8 && hX < 9) {
                    hX < 8.5 ? (hO = 6) : (hO = 3)
                }
                if (h4._displayOptions.labelMargin) {
                    hO = h4._displayOptions.labelMargin
                }
                var e = 2;
                if (hX < 6 && hX >= 5) {
                    e = -1
                }
                for (var iy = 0, iw = iq.length; iy < iw; iy++) {
                    var ii = iq[iy];
                    var hW = ii._tempBds;
                    ii.isDel = false;
                    ii._intersectIdx = [];
                    for (ix = iy + 1; ix < iw; ix++) {
                        var h3 = iq[ix];
                        var iz = h3._tempBds;
                        if (!(hW[2] + hO + e < iz[0] - hO || hW[0] - hO > iz[2] + hO + e || hW[3] + hO + e < iz[1] - hO || hW[1] - hO > iz[3] + hO + e)) {
                            ii._intersectIdx.push(ix)
                        }
                    }
                }
                for (var iy = 0, iw = iq.length; iy < iw; iy++) {
                    var it = iq[iy];
                    if (it.isDel === false) {
                        var ih = it._intersectIdx;
                        for (var ix = 0, ia = ih.length; ix < ia; ix++) {
                            iq[ih[ix]].isDel = true
                        }
                    }
                }
                return hU
            },
            calcCollisionBounds: function (hT, hR, i, hS) {
                var hP = hT.pt;
                var hN = this.map;
                var hO = hN.pointToPixelIn(hP, {
                    zoom: hR,
                    useRound: this._useRound
                });
                var T = hO.x + i;
                var hV = hS - hO.y;
                var e = hT.bds;
                hT._tempBds = [T + e[0], hV + e[1], T + e[2], hV + e[3]];
                var hQ = hN.pixelToPointIn(new eg(hT._tempBds[0], hO.y + e[1]), {
                    zoom: hR
                });
                var hU = hN.pixelToPointIn(new eg(hT._tempBds[2], hO.y + e[3]), {
                    zoom: hR
                });
                hT._mcBds = [hQ, hU]
            },
            getZoomStep: function () {
                var T = this.map.getZoom();
                var e = Math.floor(T);
                var i = T - e >= 0.5 ? e + 0.5 : e;
                return i
            },
            clearCollisionCache: function (e) {
                if (!e) {
                    return
                }
                e.cacheState = null;
                e.unnecessaryCollisionTest = null
            },
            getCachedLabels: function (e) {
                e = e || [];
                var T = this.getZoomStep();
                var hO = [];
                var hQ = false;
                for (var hN = 0; hN < e.length; hN++) {
                    var hP = e[hN];
                    if (!hP.cacheState || !hP.cacheState[T]) {
                        hQ = true;
                        break
                    }
                    if (hP.hasNewData) {
                        hQ = true;
                        break
                    }
                }
                if (hQ) {
                    this.calcLabelsCollision(e)
                }
                return e
            },
            calcLabelsCollision: function (T) {
                var hO = this.getZoomStep();
                var hP = {};
                var hS;
                var hN;
                T = this.collisionTest(T, undefined, hO);
                bG.addLabelIntoAreaSpots(T);
                for (var hR = 0; hR < T.length; hR++) {
                    hS = T[hR];
                    hN = hS.tileInfo;
                    var hW = hN.col + "," + hN.row;
                    hP[hW] = 1
                }
                var e = {};
                for (var hR = 0; hR < T.length; hR++) {
                    hS = T[hR];
                    if (!hS.cacheState) {
                        hS.cacheState = {}
                    }
                    hN = hS.tileInfo;
                    var hV = hN.col;
                    var hT = hN.row;
                    hW = hV + "," + hT;
                    if (hS.cacheState[hO] === "stable") {
                        e[hW] = 1;
                        if (!hS.hasNewData) {
                            continue
                        }
                    }
                    for (var hQ = 0; hQ < hS.fixedLabel.length; hQ++) {
                        var hU = hS.fixedLabel[hQ];
                        if (!hU.cachedIsDel) {
                            hU.cachedIsDel = {}
                        }
                        hU.cachedIsDel[hO] = hU.isDel
                    }
                    for (var hQ = 0; hQ < hS.indoorLabel.length; hQ++) {
                        var hU = hS.indoorLabel[hQ];
                        if (!hU.cachedIsDel) {
                            hU.cachedIsDel = {}
                        }
                        hU.cachedIsDel[hO] = hU.isDel
                    }
                    for (var hQ = 0; hQ < hS.lineLabel.length; hQ++) {
                        var hU = hS.lineLabel[hQ];
                        if (!hU.cachedIsDel) {
                            hU.cachedIsDel = {}
                        }
                        hU.cachedIsDel[hO] = hU.isDel
                    }
                    if (hP[(hV - 1) + "," + (hT - 1)] && hP[(hV - 1) + "," + hT] && hP[(hV - 1) + "," + (hT + 1)] && hP[hV + "," + (hT - 1)] && hP[hV + "," + (hT + 1)] && hP[(hV + 1) + "," + (hT - 1)] && hP[(hV + 1) + "," + hT] && hP[(hV + 1) + "," + (hT + 1)]) {
                        hS.cacheState[hO] = "stable";
                        e[hW] = 1
                    } else {
                        if (!hS.cacheState[hO]) {
                            hS.cacheState[hO] = "unstable"
                        }
                    }
                }
                for (var hR = 0; hR < T.length; hR++) {
                    var hS = T[hR];
                    hN = hS.tileInfo;
                    var hW = hN.col + "," + hN.row;
                    var hV = +hN.col;
                    var hT = +hN.row;
                    if (e[(hV - 1) + "," + (hT - 1)] && e[(hV - 1) + "," + hT] && e[(hV - 1) + "," + (hT + 1)] && e[hV + "," + (hT - 1)] && e[hV + "," + (hT + 1)] && e[(hV + 1) + "," + (hT - 1)] && e[(hV + 1) + "," + hT] && e[(hV + 1) + "," + (hT + 1)]) {
                        if (!hS.unnecessaryCollisionTest) {
                            hS.unnecessaryCollisionTest = {}
                        }
                        hS.unnecessaryCollisionTest[hO] = 1
                    }
                }
                T.hasNewData = false
            },
            updateLabels: function (hN) {
                var e = this.map;
                var hT = e.getZoom();
                var hV = e.getHeading();
                hV = this.calcLoopHeading(hV);
                var hU = e.getTilt();
                var hO = this.getZoomStep();
                for (var hS = 0, hP = hN.length; hS < hP; hS++) {
                    var hR = hN[hS];
                    var T = hR.tileInfo;
                    var hQ = T.loopOffsetX || 0;
                    this.updateFixedLabel(hR.fixedLabel, hU, hV, hR, hO, hT, hQ);
                    this.updateFixedLabel(hR.indoorLabel, hU, hV, hR, hO, hT, 0);
                    this.updateLineLabel(hR.lineLabel, hU, hV, hR, hO)
                }
            },
            updateFixedLabel: function (hS, hU, i, hW, hO, e, hN) {
                if (hS.length === 1) { }
                for (var hX = 0, hP = hS.length; hX < hP; hX++) {
                    var hT = hS[hX];
                    if (!hT.cachedIsDel) {
                        continue
                    }
                    if (!hU && !i && hW.cacheState && hW.cacheState[hO]) {
                        hT.isDel = hT.cachedIsDel[hO];
                        if (typeof hT.isDel === "undefined") {
                            hT.isDel = hT.cachedIsDel[hO] = true
                        }
                    }
                    if (hT.startScale > e) {
                        hT.isDel = true
                    }
                    if (hT.isDel) {
                        continue
                    }
                    var hZ = hT.pt;
                    var T = hT.iconPos;
                    if (T && T.texcoord) {
                        if (!T.rtVertex) {
                            T.rtVertex = [];
                            var h1 = T.vertex;
                            var hQ = aD(hZ.lng);
                            var hY = aD(hZ.lat);
                            T.rtVertex = [hQ[0], hY[0], hQ[1], hY[1], 0, h1[0], h1[1], 0, 0, T.texcoord[0], T.texcoord[1], hQ[0], hY[0], hQ[1], hY[1], 0, h1[2], h1[3], 0, 0, T.texcoord[2], T.texcoord[3], hQ[0], hY[0], hQ[1], hY[1], 0, h1[4], h1[5], 0, 0, T.texcoord[4], T.texcoord[5], hQ[0], hY[0], hQ[1], hY[1], 0, h1[6], h1[7], 0, 0, T.texcoord[6], T.texcoord[7], hQ[0], hY[0], hQ[1], hY[1], 0, h1[8], h1[9], 0, 0, T.texcoord[8], T.texcoord[9], hQ[0], hY[0], hQ[1], hY[1], 0, h1[10], h1[11], 0, 0, T.texcoord[10], T.texcoord[11]]
                        }
                    }
                    var h0 = hT.textPos;
                    if (h0) {
                        if (!h0.rtVertex) {
                            h0.rtVertex = [];
                            var h1 = h0.vertex;
                            var hR = h0.rtVertex;
                            var hQ = aD(hZ.lng);
                            var hY = aD(hZ.lat);
                            var h3 = aD(hN);
                            for (var hV = 0, h2 = h1.length; hV < h2; hV += 12) {
                                hR.push(hQ[0], hY[0], hQ[1], hY[1], 0, h1[hV], h1[hV + 1], h3[0], h3[1], h0.texcoord[0], h0.texcoord[1]);
                                hR.push(hQ[0], hY[0], hQ[1], hY[1], 0, h1[hV + 2], h1[hV + 3], h3[0], h3[1], h0.texcoord[2], h0.texcoord[3]);
                                hR.push(hQ[0], hY[0], hQ[1], hY[1], 0, h1[hV + 4], h1[hV + 5], h3[0], h3[1], h0.texcoord[4], h0.texcoord[5]);
                                hR.push(hQ[0], hY[0], hQ[1], hY[1], 0, h1[hV + 6], h1[hV + 7], h3[0], h3[1], h0.texcoord[6], h0.texcoord[7]);
                                hR.push(hQ[0], hY[0], hQ[1], hY[1], 0, h1[hV + 8], h1[hV + 9], h3[0], h3[1], h0.texcoord[8], h0.texcoord[9]);
                                hR.push(hQ[0], hY[0], hQ[1], hY[1], 0, h1[hV + 10], h1[hV + 11], h3[0], h3[1], h0.texcoord[10], h0.texcoord[11])
                            }
                        }
                    }
                }
            },
            updateLineLabel: function (hS, io, ic, h7, h8) {
                hS = hS || [];
                var h2 = this.map;
                var hV = h2.getZoomUnits();
                for (var im = 0, ik = hS.length; im < ik; im++) {
                    var hR = hS[im];
                    if (!hR.cachedIsDel) {
                        continue
                    }
                    if (!io && !ic && h7.cacheState && h7.cacheState[h8]) {
                        hR.isDel = hR.cachedIsDel[h8];
                        if (typeof hR.isDel === "undefined") {
                            hR.isDel = hR.cachedIsDel[h8] = true
                        }
                    }
                    if (hR.isDel) {
                        continue
                    }
                    if (!hR.styleText || hR.styleText.length === 0) {
                        continue
                    }
                    var hT = hR.mcInTile;
                    var ig = hT.x;
                    var id = hT.y;
                    var h6 = hR.wordsInfo;
                    var h4 = hR.labelAngle;
                    var h0 = false;
                    var ie = 0;
                    if (ic !== 0) {
                        var h1 = h6[0].angle;
                        var ij = this.calcLoopHeading(h1 - ic);
                        var hY = this.calcLoopHeading(h4 - ic);
                        if (ij > 45 && ij < 315) {
                            if (ij > 45 && ij <= 135) {
                                ie = 270
                            } else {
                                if (ij > 135 && ij <= 225) {
                                    ie = 180
                                } else {
                                    if (ij > 225 && ij < 315) {
                                        ie = 90
                                    }
                                }
                            } if (h4 > 225 && h4 <= 315 && ie <= 180) {
                                h0 = true
                            } else {
                                if ((h4 >= 0 && h4 <= 45 || h4 >= 315 && h4 < 360) && ie >= 180) {
                                    h0 = true
                                }
                            }
                        }
                    }
                    for (var il = 0, hW = h6.length; il < hW; il++) {
                        var ii = h6[il];
                        var hZ = ii.calcInfo;
                        var ib = ii.offset[0];
                        var h9 = ii.offset[1];
                        if (!ii.size) {
                            continue
                        }
                        var e = ii.size[0];
                        var T = ii.size[1];
                        var hX = ii.angle;
                        if (!hZ) {
                            hZ = {}
                        }
                        if (ic !== hZ.mapHeading || hV !== hZ.zoomUnits) {
                            hZ.mapHeading = ic;
                            hZ.zoomUnits = hV;
                            if (h0) {
                                var h3 = h6[hW - 1 - il];
                                ib = h3.offset[0];
                                h9 = h3.offset[1];
                                hX = h3.angle
                            }
                            var hO = ig + ib * hV;
                            var hN = id + h9 * hV;
                            hZ.rotationCenter = {
                                lng: hO,
                                lat: hN
                            };
                            hZ.calcHeading = ie;
                            hZ.angle = hX;
                            hZ.offsetX = ib;
                            hZ.offsetY = h9;
                            ii.calcInfo = hZ
                        }
                        if (!ii.rtVertex) {
                            ii.rtVertex = []
                        }
                        ii.rtVertex.length = 0;
                        var h5 = hZ.calcHeading + hZ.angle;
                        var hP = hZ.rotationCenter;
                        ib = hZ.offsetX;
                        h9 = hZ.offsetY;
                        var hQ = Math.round(ib - e / 2);
                        var ih = Math.round(ib + e / 2);
                        var ia = Math.round(h9 + T / 2);
                        var hU = Math.round(h9 - T / 2);
                        ii.rtVertex.push(ig, id, ii.z, hQ, hU, hP.lng, hP.lat, h5, ii.texcoord[0], ii.texcoord[1], ig, id, ii.z, ih, hU, hP.lng, hP.lat, h5, ii.texcoord[2], ii.texcoord[3], ig, id, ii.z, ih, ia, hP.lng, hP.lat, h5, ii.texcoord[4], ii.texcoord[5], ig, id, ii.z, hQ, hU, hP.lng, hP.lat, h5, ii.texcoord[6], ii.texcoord[7], ig, id, ii.z, ih, ia, hP.lng, hP.lat, h5, ii.texcoord[8], ii.texcoord[9], ig, id, ii.z, hQ, ia, hP.lng, hP.lat, h5, ii.texcoord[10], ii.texcoord[11])
                    }
                }
            },
            calcLoopHeading: function (e) {
                while (e >= 360) {
                    e -= 360
                }
                while (e < 0) {
                    e += 360
                }
                return e
            },
            fixDataFormat: function (hV) {
                var hN = this.fixedLabelData;
                var e = this.lineLabelData;
                var T = this.highlightLabelData;
                var h2 = 0;
                var hR = 0;
                var h0 = 0;
                var h1;
                if (this.currentSelectedLabel) {
                    var hQ = this.getLabelByUid(this.currentSelectedLabel.guid, this.currentSelectedLabel.tilePosStr);
                    if (!hQ || hQ.isDel) {
                        hN[h2] = this.currentSelectedLabel.formatedData;
                        h2++;
                        T[h0] = this.currentSelectedLabel.formatedData;
                        h0++
                    }
                }
                for (var hZ = 0; hZ < hV.length; hZ++) {
                    var hT = hV[hZ];
                    var hS = hT.fixedLabel;
                    var hO = hT.indoorLabel;
                    var hY = hT.lineLabel;
                    h1 = this.fixFixedLabelDataFormat(hS, hT, hN, h2, T, h0);
                    h2 = h1[0];
                    h0 = h1[1];
                    h1 = this.fixFixedLabelDataFormat(hO, hT, hN, h2, T, h0, true);
                    h2 = h1[0];
                    h0 = h1[1];
                    e[hR] = {
                        tileInfo: hT.tileInfo,
                        lineLabels: []
                    };
                    for (var hX = 0; hX < hY.length; hX++) {
                        if (hY[hX].isDel) {
                            continue
                        }
                        var hU = hY[hX].wordsInfo;
                        if (hU) {
                            for (var hW = 0; hW < hU.length; hW++) {
                                if (!hU[hW].rtVertex) {
                                    continue
                                }
                                var hP = hU[hW].formatedData;
                                if (!hP) {
                                    hP = {
                                        textureSource: hT.textureSources[hY[hX].processedInZoom],
                                        textureHeight: hT.textureHeights[hY[hX].processedInZoom],
                                        renderData: {
                                            vertex: hU[hW].rtVertex,
                                            textureCoord: hU[hW].texcoord
                                        }
                                    };
                                    hU[hW].formatedData = hP
                                }
                                e[hR].lineLabels.push(hP)
                            }
                        }
                    }
                    hR++
                }
                hN.length = h2;
                e.length = hR;
                T.length = h0;
                return [e, hN, T]
            },
            fixFixedLabelDataFormat: function (hQ, hT, hU, hR, hO, e, hS) {
                for (var i = 0; i < hQ.length; i++) {
                    if (hQ[i].isDel) {
                        continue
                    }
                    var hP = hQ[i].textPos;
                    var hN = hQ[i].iconPos;
                    var T = null;
                    if (hP && hP.rtVertex) {
                        if (!hQ[i].formatedData) {
                            T = {
                                guid: hQ[i].guid,
                                guidExt: hQ[i].guidExt,
                                tilePosStr: hQ[i].tilePosStr,
                                zoom: hQ[i].zoom,
                                tempRank: hQ[i].tempRank,
                                textureSource: hT.textureSources[hQ[i].processedInZoom],
                                textureHeight: hT.textureHeights[hQ[i].processedInZoom],
                                renderData: {
                                    vertex: hP.rtVertex,
                                    textureCoord: hP.texcoord
                                }
                            };
                            if (hS && hQ[i].onDefaultFloor === false) {
                                T.textureSource = hT.indoorTextureSources[hQ[i].processedInZoom];
                                T.textureHeight = hT.indoorTextureHeights[hQ[i].processedInZoom]
                            }
                            hQ[i].formatedData = T
                        } else {
                            T = hQ[i].formatedData;
                            T.tempRank = hQ[i].tempRank
                        } if (this.currentSelectedLabel && T.guid === this.currentSelectedLabel.guid && T.tilePosStr === this.currentSelectedLabel.tilePosStr) {
                            hO[e] = T;
                            e++
                        }
                    }
                    if (hN && hN.rtVertex) {
                        if (T) {
                            if (!T.iconRenderData) {
                                T.iconRenderData = {
                                    vertex: hN.rtVertex,
                                    textureCoord: hN.texcoord
                                }
                            }
                        } else {
                            T = {
                                guid: hQ[i].guid,
                                guidExt: hQ[i].guidExt,
                                zoom: hQ[i].zoom,
                                tempRank: hQ[i].tempRank,
                                iconRenderData: {
                                    vertex: hN.rtVertex,
                                    textureCoord: hN.texcoord
                                }
                            };
                            hQ[i].formatedData = T
                        }
                    }
                    hU[hR] = T;
                    hR++
                }
                return [hR, e]
            },
            _refreshSpotData: function () {
                this._spotData.length = 0;
                var hS = this.map;
                var hQ = Math.floor(hS.getZoom());
                var T = this.map._featureMgr.getLabelData();
                if (T) {
                    for (var hO = 0, hN = T.length; hO < hN; hO++) {
                        this._addFixedSpotData(T[hO].fixedLabel, hQ);
                        this._addFixedSpotData(T[hO].indoorLabel, hQ)
                    }
                }
                var hT = this.currentSelectedLabel;
                if (hT && !this.getTileByLabelUid(hT.guid, hT.tilePosStr)) {
                    var hP = this._getSpotDataFromLabel(this.currentSelectedLabel);
                    if (hP) {
                        this._spotData.push(hP)
                    }
                }
                var hR = new a8("onspotsdataready");
                hR.spots = this._spotData;
                hS._spotDataOnCanvas = this._spotData;
                hS.dispatchEvent(hR)
            },
            _addFixedSpotData: function (hO, hN) {
                for (var e = 0; e < hO.length; e++) {
                    var T = hO[e];
                    if (!this.layer.isClickableLabel(T) || (T.guidExt === 1 && T.startScale > hN)) {
                        continue
                    }
                    var i = hO[e].spot || this._getSpotDataFromLabel(hO[e]);
                    if (i) {
                        this._spotData.push(i)
                    }
                }
            },
            _getSpotDataFromLabel: function (T) {
                var hP = this.map;
                if (!T.bds) {
                    return null
                }
                var e = T.bds.slice(0);
                var hN = null;
                if (T.iconPos) {
                    hN = new ho(T.pt.lng, T.pt.lat)
                }
                var i = T.name ? T.name.replace("\\\\", "<br>") : "";
                if (T.iconPos && T.iconPos.iconType.indexOf("ditie") > -1 && hP.getZoom() > 14) {
                    i = ""
                }
                var hO = {
                    n: i,
                    pt: new ho(T.pt.lng, T.pt.lat),
                    userdata: {
                        iconPoint: hN,
                        uid: T.guid,
                        name: i,
                        mapPoi: true,
                        type: T.iconPos ? T.iconPos.iconType : "",
                        rank: T.rank,
                        zoom: T.zoom,
                        tilePosStr: T.tilePosStr
                    },
                    bd: e,
                    tag: "MAP_SPOT_INFO"
                };
                T.spot = hO;
                return hO
            },
            drawLabelsOnCanvas: function (i, e) {
                if (this._labelTextCanvas) {
                    this._labelTextCanvas.drawLabelsOnCanvas(i, e)
                }
            }
        });

        function fQ(e) {
            this._map = e;
            this.virtualTile = {
                custom: true,
                label: {
                    fixedLabel: [],
                    indoorLabel: [],
                    lineLabel: [],
                    textureHeights: [],
                    status: "ready"
                },
                tileInfo: {
                    col: 0,
                    row: 0,
                    zoom: 0,
                    useZoom: 0,
                    loopOffsetX: 0
                },
                status: "ready"
            };
            this.virtualTile.label.tileInfo = this.virtualTile.tileInfo;
            this.init()
        }
        fQ.prototype.init = function () {
            var T = this._map;
            var i = this;

            function e() {
                i.updateLabels()
            }
            T.addEventListener("add_tile_labels", e);
            T.addEventListener("onremove_tile_labels", e);
            T.addEventListener("onclear_labels", e)
        };
        fQ.prototype.updateLabels = function () {
            var i = this._map.tileMgr.getLabelTextCanvas();
            var T = this._map;
            var e = this;
            i.drawCustomLabelsOnCanvas(T._customTileLabels, function (hO) {
                var hN = e.virtualTile;
                if (hO) {
                    hN.label.textureHeights[0] = [hO.height]
                }
                hN.label.fixedLabel = T._customTileLabels;
                var hP = new a8("oncustom_labels_ready");
                hP.virtualTile = hN;
                hP.labelCanvas = hO;
                hP.imgKey = bl.getGUID("custom_labels_");
                T.dispatchEvent(hP)
            })
        };
        bl.register(function (e) {
            e._customLabelMgr = new fQ(e)
        });

        function eJ(i) {
            var hN = null;
            try {
                if (dt.inMapHost) {
                    hN = new Worker(i);
                    hN.onerror = function (e) {
                        e.preventDefault();
                        hN = t(i)
                    }
                } else {
                    hN = t(i)
                }
            } catch (T) {
                hN = t(i)
            }
            return hN
        }

        function t(hP) {
            var hS = null;
            try {
                var T;
                try {
                    T = new Blob(['importScripts("' + hP + '");'], {
                        type: "application/javascript"
                    })
                } catch (hQ) {
                    var hO = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder)();
                    hO.append('importScripts("' + hP + '");');
                    T = hO.getBlob("application/javascript")
                }
                var hN = window.URL || window.webkitURL;
                var i = hN.createObjectURL(T);
                hS = new Worker(i)
            } catch (hR) { }
            return hS
        }

        function f5(e) {
            this.init(e)
        }
        var bc = {
            init: function (T) {
                var i = this;
                this.map = T;
                this.arrPendingData = [];
                var e = navigator.hardwareConcurrency || 4;
                if ((f1() || C.Browser.ie) && e > 2) {
                    e = 2
                }
                this.arrWorker = [];
                this.ratio = a3();
                this.wordSpaceRatio = this.ratio;
                if (this.ratio > 1) {
                    this.textSizeRatio = 2
                } else {
                    this.textSizeRatio = 1
                }
                cX.canUseWebAssembly(function (hN) {
                    var hQ;
                    if (hN) {
                        hQ = "https://api.map.baidu.com/res/webgl/10/worker_wasm_kcp3uy.js"
                    } else {
                        hQ = "https://api.map.baidu.com/res/webgl/10/worker_asm_maed2p.js"
                    }
                    for (var hP = 0; hP < e; hP++) {
                        var hS = eJ(hQ);
                        hS.onmessage = function hO(hU) {
                            if (hU.data) {
                                this._cbk && this._cbk(hU.data, this._parsingTileKey)
                            } else {
                                this._cbk && this._cbk(null, this._parsingTileKey)
                            }
                            this._isBusy = false;
                            this._cbk = null;
                            this._parsingTileInfo = null;
                            this._parsingTileKey = null;
                            if (i.arrPendingData.length > 0) {
                                var hW = i.arrPendingData.shift();
                                var hT = hW.cbk;
                                i.loadTileData(hW.url, hW.tileInfo, hW.tileKey, hT)
                            }
                            var hV = new a8("onrefresh");
                            hV.source = "workermgr";
                            T.fire(hV)
                        };
                        i.arrWorker.push(hS)
                    }
                    if (i.arrPendingData.length > 0) {
                        for (var hP = 0; hP < Math.min(i.arrPendingData.length, e); hP++) {
                            var hR = i.arrPendingData.shift();
                            i.loadTileData(hR.url, hR.tileInfo, hR.tileKey, hR.cbk)
                        }
                    }
                });
                T.on("onstyle_loaded", function () {
                    for (var hO = 0, hN = i.arrWorker.length; hO < hN; hO++) {
                        i.arrWorker[hO].isSendFS = false
                    }
                    if (typeof this.config.style !== "string") {
                        f5.stringifiedCustomStyleInfo = null;
                        f5.stringifiedCustomStyleInfoZoom = []
                    }
                });
                T.on("onstylezoomupdate", function () {
                    for (var hO = 0, hN = i.arrWorker.length; hO < hN; hO++) {
                        i.arrWorker[hO].isSendFS = false
                    }
                    if (typeof this.config.style !== "string") {
                        f5.stringifiedCustomStyleInfo = null;
                        f5.stringifiedCustomStyleInfoZoom = []
                    }
                });
                T.on("destroy", function () {
                    for (var hN = 0; hN < i.arrWorker.length; hN++) {
                        if (i.arrWorker[hN]) {
                            i.arrWorker[hN].terminate()
                        }
                    }
                    i.arrWorker.length = 0
                })
            },
            getIdleWorker: function () {
                for (var T = 0, e = this.arrWorker.length; T < e; T++) {
                    var hN = this.arrWorker[T];
                    if (!hN._isBusy) {
                        hN._isBusy = true;
                        return hN
                    }
                }
                return null
            },
            releasePendingData: function (T) {
                var hN = [];
                var hQ = this.arrPendingData;
                for (var hP = hQ.length - 1; hP >= 0; hP--) {
                    var hR = hQ[hP];
                    var e = hR.tileInfo;
                    if (T.tileTypeName !== e.tileTypeName) {
                        continue
                    }
                    var hO = "id_" + e.col + "_" + e.row + "_" + e.zoom;
                    if (!T[hO]) {
                        hQ.splice(hP, 1);
                        hN.push(e)
                    }
                }
                return hN
            },
            loadTileData: function (e, T, hT, hS) {
                var hN = this.getIdleWorker();
                if (hN) {
                    hN._cbk = hS;
                    hN._parsingTileInfo = T;
                    hN._parsingTileKey = hT;
                    var i = {
                        action: "loadTileData",
                        url: e,
                        tileInfo: T,
                        tileKey: hT
                    };
                    var hR = this.map.getMapStyleId();
                    var hQ = !!(hR.indexOf("custom") === 0);
                    var hP = hR;
                    if (hQ) {
                        hP = "Custom"
                    }
                    if (!hN.isSendFS) {
                        if (!f5["stringifiedFeatureStyle" + hR] && bl["FeatureStyle" + hR]) {
                            f5["stringifiedFeatureStyle" + hR] = JSON.stringify(bl["FeatureStyle" + hR])
                        }
                        if (!f5["stringifiedIconSetInfo" + hP]) {
                            f5["stringifiedIconSetInfo" + hP] = JSON.stringify(bl["iconSetInfo" + hP])
                        }
                        if (!f5.stringifiedIndoorStyle) {
                            f5.stringifiedIndoorStyle = JSON.stringify(bl.indoorStyle)
                        }
                        if (hQ && bl.customStyleInfo) {
                            if (!f5.stringifiedCustomStyleInfo) {
                                f5.stringifiedCustomStyleInfo = JSON.stringify(bl.customStyleInfo)
                            }
                        }
                        if (f5["stringifiedFeatureStyle" + hR]) {
                            i.featureStyle = f5["stringifiedFeatureStyle" + hR]
                        }
                        i.iconSetInfo = f5["stringifiedIconSetInfo" + hP];
                        i.indoorStyle = f5.stringifiedIndoorStyle;
                        if (hQ && f5.stringifiedCustomStyleInfo) {
                            i.customMapStyle = f5.stringifiedCustomStyleInfo
                        }
                        i.iconInfo = {
                            wordSpaceRatio: this.wordSpaceRatio,
                            textSizeRatio: this.textSizeRatio
                        };
                        i.mapStyleId = hR;
                        hN.isSendFS = true
                    }
                    hN.postMessage(i)
                } else {
                    var hO = {
                        url: e,
                        tileInfo: T,
                        tileKey: hT,
                        cbk: hS
                    };
                    this.arrPendingData.push(hO)
                }
            }
        };
        C.extend(f5.prototype, bc);

        function dQ(i) {
            this.tileLayers = [];
            this.map = i;
            var e = this.config = b3[this.map.mapType];
            this.errorUrl = e.errorUrl;
            this.tileSize = e.tileSize;
            this.baseUnits = e.baseUnits;
            this.baseZoomLevel = e.zoomLevelBase;
            this.tileURLs = e.tileUrls;
            this.tilesInfoCache = {};
            this.loadDelay = 10;
            this._labelTextCanvas = null
        }
        bl.register(function (i) {
            if (i._renderType !== "webgl") {
                return
            }
            var e = i.tileMgr = new dQ(i);
            i.addEventListener("addtilelayer", function (hN) {
                e.addWebGLLayer(hN.target)
            });
            i.addEventListener("removetilelayer", function (hN) {
                e.removeWebGLLayer(hN.target)
            });
            i.on("update", function T(hN) {
                if (!bl["FeatureStyle" + this.config.style] && !bl.customStyleLoaded) {
                    return
                }
                e.loadLayersData({
                    zoomChanged: hN.changedStatus.onzoom_changed ? true : false
                })
            });
            i.on("style_changed", function () {
                e.loadLayersData()
            })
        });
        C.extend(dQ.prototype, {
            addWebGLLayer: function (hN) {
                this.tileLayers.push(hN);
                hN.initDrawData();
                if (this.tileLayers.length > 1) {
                    for (var T = 1; T < this.tileLayers.length; T++) {
                        if (this.tileLayers[T].isFlat) {
                            this.map.setDisplayOptions({
                                isFlat: true
                            });
                            break
                        }
                    }
                }
                var e = this.map.config.style;
                if (bl["FeatureStyle" + e]) {
                    this.loadLayersData()
                } else {
                    var hO = this;
                    this.map.loadMapStyleFiles(function () {
                        hO.loadLayersData()
                    })
                }
            },
            removeWebGLLayer: function (hP) {
                var hQ = false;
                for (var hO = 0, hN = this.tileLayers.length; hO < hN; hO++) {
                    if (hP === this.tileLayers[hO]) {
                        hQ = true;
                        this.tileLayers.splice(hO, 1);
                        break
                    }
                }
                if (hQ === false) {
                    return
                }
                hP.destroyDrawData();
                if (bl["FeatureStyle" + this.map.config.style]) {
                    this.loadLayersData()
                }
                if (this.tileLayers.length === 1) {
                    this.map.setDisplayOptions({
                        isFlat: false
                    })
                } else {
                    var e = false;
                    for (var hO = 1; hO < this.tileLayers.length; hO++) {
                        if (this.tileLayers[hO].isFlat) {
                            e = true;
                            break
                        }
                    }
                    this.map.setDisplayOptions({
                        isFlat: e
                    })
                }
                var T = new a8("onrefresh");
                T.source = "removewebgllayer";
                this.map.fire(T)
            },
            getLabelTextCanvas: function () {
                if (!this._labelTextCanvas) {
                    this._labelTextCanvas = new v(this.map)
                }
                return this._labelTextCanvas
            },
            loadLayersData: function (i) {
                if (this.map.suspendLoad) {
                    return
                }
                var hN = this;
                i = i || {};
                var T = !!i.zoomChanged;
                var e = (T === true || this.map.getTilt() > 50);
                if (!e) {
                    if (!this.syncLoadTimer) {
                        this.syncLoadTimer = setTimeout(function () {
                            hN._loadLayersFromCache(T);
                            hN.syncLoadTimer = null
                        }, 40)
                    }
                } else {
                    this._loadLayersFromCache(T)
                } if (!hN.map.viewAnimationTime) {
                    this.timer && window.clearTimeout(this.timer)
                }
                this.timer = window.setTimeout(function () {
                    if (hN.map.viewAnimationTime) {
                        if (new Date().getTime() - hN.map.viewAnimationTime < 1000) {
                            return
                        }
                        hN.map.viewAnimationTime = new Date().getTime()
                    }
                    var hP = hN.tileLayers.length;
                    hN.tilesInfoCache = {};
                    for (var hQ = 0; hQ < hP; hQ++) {
                        var hS = hN.tileLayers[hQ];
                        var hR = hS.tileType;
                        var hO = null;
                        if (hN.tilesInfoCache[hR.getName()]) {
                            hO = hN.tilesInfoCache[hR.getName()]
                        } else {
                            hO = hN.calcTilesInfo(hR);
                            hN.tilesInfoCache[hR.getName()] = hO
                        }
                        hS.loadLayerData(hO, false, T)
                    }
                    hN.timer = null
                }, this.loadDelay);
                if ((f1() || C.Browser.ie) && T) {
                    this.loadDelay = 200
                } else {
                    this.loadDelay = 80
                }
            },
            _loadLayersFromCache: function (hO) {
                this.map._featureMgr.clearData();
                var hR = this.tileLayers;
                hR.sort(function (hS, i) {
                    return hS.zIndex - i.zIndex > 0
                });
                var T = hR.length;
                this.tilesInfoCache = {};
                for (var hN = 0; hN < T; hN++) {
                    var hQ = hR[hN];
                    var hP = hQ.tileType;
                    var e = null;
                    if (this.tilesInfoCache[hP.getName()]) {
                        e = this.tilesInfoCache[hP.getName()]
                    } else {
                        e = this.calcTilesInfo(hP);
                        this.tilesInfoCache[hP.getName()] = e
                    }
                    hQ.loadLayerData(e, true, hO)
                }
            },
            calcTilesInfo: function (hZ) {
                var ib = this.map;
                var ij = ib.getMapType();
                var ic = b3[ij];
                var h6 = ib.getZoom();
                var e = Math.floor(h6);
                var hQ = hZ.getDataZoom(h6);
                var iv = hZ.getName();
                hQ = fC(hQ, ic.minDataZoom, ic.maxDataZoom);
                var im = e;
                if (hZ._name === "web") {
                    im = hQ
                } else {
                    if (im < 3) {
                        im = 3
                    }
                }
                var ia = hZ.getTileSize(h6);
                var hP = hZ.getBaseTileSize(h6);
                var h3 = hZ.getMercatorSize(h6, hQ);
                var h2;
                var ik;
                var h9;
                var ip;
                var ie = ib.getCenterIn();
                if (ij !== BMAP_SATELLITE_MAP) {
                    ie = d0.calcLoopCenterPoint(ie)
                }
                var h7 = Math.floor(ie.lng / h3);
                var hS = Math.floor(ie.lat / h3);
                var h8 = ib.getBoundsIn();
                var ih = 0;
                var hN = 0;
                h8 = d0.calcLoopMapBounds(h8, ib.getCenter());
                if (h8.ne.lng > d0._mc180X) {
                    var hX = d0.getSpaceDistanceInPixel(hQ);
                    ih = Math.ceil(hX / hP)
                }
                if (h8.sw.lng < d0._mcM180X) {
                    var hX = d0.getSpaceDistanceInPixel(hQ);
                    hN = Math.ceil(hX / hP)
                }
                if (h8.ne.lat > 19505879.362428114 || h8.sw.lat < -15949096.637571886) {
                    h8.ne.lat = 19505879.362428114;
                    h8.sw.lat = -15949096.637571886
                }
                var hU = [Math.floor(h8.sw.lng / h3) - hN, Math.floor(h8.sw.lat / h3)];
                var it = [Math.floor(h8.ne.lng / h3) + ih, Math.floor(h8.ne.lat / h3)];
                h2 = hU[0];
                ik = it[0] + 1;
                h9 = hU[1];
                ip = it[1] + 1;
                var hY = [];
                for (var hV = h2; hV < ik; hV++) {
                    if (d0.isTileBlank(hV, hQ, hP) === true) {
                        continue
                    }
                    for (var h0 = h9; h0 < ip; h0++) {
                        var hW = {
                            col: hV,
                            row: h0,
                            zoom: hQ,
                            useZoom: im,
                            tileTypeName: iv,
                            loopOffsetX: 0,
                            tileSize: ia,
                            baseTileSize: hP,
                            mercatorSize: h3
                        };
                        hY.push(hW);
                        var ii = "id_" + hV + "_" + h0 + "_" + hQ;
                        hY[ii] = true
                    }
                }
                if (ij !== BMAP_SATELLITE_MAP) {
                    hY = d0.calcLoopTiles(hY, hQ, hP, h3)
                }
                if (hQ === 3) {
                    for (var ir = 0, iq = hY.length; ir < iq; ir++) {
                        var hV = hY[ir].col;
                        var h0 = hY[ir].row;
                        var il = d0.calcLoopParam(hV, hQ);
                        var hR = il.T;
                        var h4 = hV >= 0 ? hV - hR : hV + hR;
                        var h5 = "id_" + h4 + "_" + h0 + "_" + hQ;
                        if (!hY[h5]) {
                            var hW = {
                                col: h4,
                                row: h0,
                                zoom: hQ,
                                useZoom: im,
                                loopOffsetX: 0,
                                tileSize: ia,
                                baseTileSize: hP,
                                mercatorSize: h3
                            };
                            hY.push(hW);
                            hY[h5] = true
                        }
                    }
                }
                if (this.map._tilt > 0) {
                    for (var ir = 0; ir < hY.length; ir++) {
                        var hT = hY[ir];
                        var io = hT.col;
                        var iu = hT.row;
                        var ig = [];
                        ig.minX = io * h3;
                        ig.maxX = (io + 1) * h3;
                        ig.minY = iu * h3;
                        ig.maxY = (iu + 1) * h3;
                        var hO = new ho(0, 0);
                        hO.lng = (ig.minX + ig.maxX) / 2;
                        hO.lat = (ig.minY + ig.maxY) / 2;
                        var h1 = ib.pointToPixelIn(hO);
                        if (h1.x > 0 && h1.x < this.map.width && h1.y > 0 && h1.y < this.map.height) {
                            continue
                        }
                        if (ig.minX < ie.lng && ig.maxX > ie.lng && ig.minY < ie.lat && ig.maxY > ie.lat) {
                            continue
                        }
                        if (!this.ifTileInMapBounds(ig, h8, io, iu)) {
                            hY.splice(ir, 1);
                            ir--
                        }
                    }
                }
                hY.sort((function (i) {
                    return function (T, id) {
                        return ((0.4 * Math.abs(T.col - i[0]) + 0.6 * Math.abs(T.row - i[1])) - (0.4 * Math.abs(id.col - i[0]) + 0.6 * Math.abs(id.row - i[1])))
                    }
                })([h7, hS]));
                hY.zoom = hQ;
                hY.tileTypeName = iv;
                return hY
            },
            getCurrentViewTilesInfo: function (i) {
                var e = this.tilesInfoCache[i.getName()];
                if (!e) {
                    return this.calcTilesInfo(i)
                }
                return e
            },
            ifTileInMapBounds: function (e, hP, T, hO) {
                var i = hP.normalizedBottomLeft;
                var h0 = hP.normalizedTopRight;
                var hS = hP.normalizedTopLeft;
                var hQ = hP.normalizedBottomRight;
                var hN = false;
                var hZ = new ho(e.minX, e.minY);
                var hW = new ho(e.maxX, e.maxY);
                var hR = new ho(hW.lng, hZ.lat);
                var hX = new ho(hZ.lng, hW.lat);
                var hU = [hX, hW, hR, hZ];
                for (var hY = 0, hT = hU.length; hY < hT; hY++) {
                    var hV = hY + 1;
                    if (hV === hT) {
                        hV = 0
                    }
                    var h1 = hY;
                    var h2 = gt(hU[hV], hU[h1], hS, i);
                    if (h2) {
                        hN = true;
                        break
                    }
                    h2 = gt(hU[hV], hU[h1], hQ, h0);
                    if (h2) {
                        hN = true;
                        break
                    }
                    h2 = gt(hU[hV], hU[h1], h0, hS);
                    if (h2) {
                        hN = true;
                        break
                    }
                    h2 = gt(hU[hV], hU[h1], i, hQ);
                    if (h2) {
                        hN = true;
                        break
                    }
                }
                return hN
            },
            getTileLayer: function (hO) {
                for (var hN = 0, e = this.tileLayers.length; hN < e; hN++) {
                    var T = this.tileLayers[hN];
                    if (T.mapType === hO) {
                        return T
                    }
                }
                return null
            }
        });

        function aP(e) {
            this._map = e;
            this._spotsId = null;
            this._init()
        }
        aP.prototype._init = function () {
            var e = this._map;
            e.addEventListener("onspotsdataready", function (T) {
                var i = T.spots;
                if (this._spotsId) {
                    e.removeSpots(this._spotsId)
                }
                this._spotsId = e.addSpots(i)
            })
        };
        bl.register(function (e) {
            if (!e.config.enableIconClick) {
                return
            }
            e._mapIcon = new aP(e)
        });

        function aS(e) {
            this._indoorData = {};
            this._map = e;
            this.currentUid = null;
            this.currentFloor = null;
            this._indoorControl = null;
            this.enterMethod = null;
            this.showMask = false;
            this._isMobile = f1();
            this._autoEnterZoom = 19;
            if (this._isMobile) {
                this._autoEnterZoom = 17
            }
            this._init(e);
            window._indoorMgr = this
        }
        aS.prototype._init = function (i) {
            var e = this;
            i.on("indoor_status_changed", function (hQ) {
                var T = hQ.uid;
                var hO = hQ.floor;
                if (T === null) {
                    T = e.currentUid;
                    if (e._indoorData[T]) {
                        hO = e._indoorData[T].defaultFloor
                    }
                    if (e._indoorControl) {
                        e._indoorControl.hide()
                    }
                    e.currentUid = null;
                    e.currentFloor = null;
                    e.enterMethod = null
                } else {
                    if (e._indoorData[T]) {
                        var hP = e._indoorData[T];
                        hO = (typeof hO === "number") ? hO : hP.defaultFloor;
                        if (!e._indoorControl) {
                            if (i.config.showControls && i._displayOptions.indoor) {
                                e._indoorControl = new gx(i, hP)
                            }
                        } else {
                            e._indoorControl.setInfo(hP);
                            e._indoorControl.show()
                        }
                        e.currentUid = T;
                        e.currentFloor = hO
                    }
                } if (!e._indoorData || !e._indoorData[T] || e._indoorData[T].currentFloor === hO) {
                    this.fire(new a8("onrefresh"));
                    return
                }
                var hN = new a8("onindoor_data_refresh");
                hN.uid = T;
                hN.floor = hO;
                hN.tileKey = e._indoorData[T].tileKey;
                e._indoorData[T].currentFloor = hO;
                e.currentFloor = hO;
                this.fire(hN)
            });
            i.on("spotclick", function (hN) {
                var T = null;
                if (hN.curAreaSpot && this.areaSpots[hN.curAreaSpot]) {
                    T = this.areaSpots[hN.curAreaSpot].userData.uid
                }
                if (T === e.currentUid) {
                    if (hN.curAreaSpot) {
                        e.enterMethod = "byClick"
                    }
                    return
                }
                if (T === null) {
                    if (e.currentUid && e.enterMethod === "byClick") {
                        i.showIndoor(null);
                        e.enterMethod = null
                    }
                } else {
                    e.enterMethod = "byClick";
                    if (e.currentUid) {
                        i.showIndoor(e.currentUid, e._indoorData[e.currentUid].defaultFloor)
                    }
                    i.showIndoor(T, e._indoorData[T].defaultFloor)
                }
            });
            i.on("moveend", function () {
                if (this.getZoom() >= e._autoEnterZoom) {
                    e._checkIndoorByMove()
                }
            });
            i.on("zoomend", function () {
                if (this.getZoom() >= e._autoEnterZoom) {
                    e._checkIndoorByMove()
                } else {
                    if (e.enterMethod !== "byClick" && e.currentUid !== null) {
                        this.showIndoor(null)
                    }
                }
            })
        };
        aS.prototype._checkIndoorByMove = function () {
            var T = this._map;
            var hT = T.getSize();
            var hY = {
                x: hT.width / 2,
                y: hT.height / 2
            };
            var hX = Math.max(hT.width, hT.height);
            var hZ = [];
            for (var hU in this._indoorData) {
                var e = this._indoorData[hU].center;
                var hN = T.pointToPixelIn(new bl.Point(e[0], e[1]));
                var hQ = gS(hY, hN);
                hZ.push({
                    uid: hU,
                    distance: hQ
                })
            }
            if (hZ.length === 0) {
                return
            }
            hZ.sort(function (h0, i) {
                return h0.distance - i.distance
            });
            var hP = hZ[0];
            var hV = T.getCenterIn();
            var hO = false;
            for (var hS = 0; hS < this._indoorData[hP.uid].contour.length; hS++) {
                if (dd([hV.lng, hV.lat], this._indoorData[hP.uid].contour[hS])) {
                    hO = true;
                    break
                }
            }
            if (hO === false && hP.uid === "e96b44200baa3b4082288acc") {
                var hR = this._indoorData[hP.uid].boundsMin;
                var hW = this._indoorData[hP.uid].boundsMax;
                if (hV.lng > hR[0] && hV.lat > hR[1] && hV.lng < hW[0] && hV.lat < hW[1]) {
                    hO = true
                }
            }
            if (hO) {
                if (this.enterMethod !== "byClick") {
                    if (this.currentUid !== null && this.currentUid !== hP.uid) {
                        this._map.showIndoor(this.currentUid, this._indoorData[this.currentUid].defaultFloor)
                    }
                    if (this.currentUid !== hP.uid) {
                        this._map.showIndoor(hP.uid, this._indoorData[hP.uid].defaultFloor)
                    }
                    this.enterMethod = "byMove"
                }
            } else {
                if (this.enterMethod !== "byClick") {
                    this._map.showIndoor(null)
                }
            }
        };
        aS.prototype.setData = function (hN) {
            if (hN === null) {
                return
            }
            for (var T in hN) {
                if (T === "tileInfo") {
                    continue
                }
                var hO = hN[T].tileKey;
                if (this._indoorData[T]) {
                    if (!this._indoorData[T][hO]) {
                        this._indoorData[T].tileKeys.push(hO);
                        this._indoorData[T][hO] = true
                    }
                } else {
                    this._indoorData[T] = hN[T];
                    this._indoorData[T].tileKeys = [hN[T].tileKey];
                    this._indoorData[T][hO] = true;
                    for (var e = 0; e < this._indoorData[T].contour.length; e++) {
                        this._map.addAreaSpot(this._indoorData[T].contour[e], {
                            id: T + e,
                            userData: {
                                uid: T
                            }
                        })
                    }
                }
            }
            if (this._map.getZoom() >= this._autoEnterZoom) {
                this._checkIndoorByMove()
            }
        };
        aS.prototype.removeData = function (T, hO) {
            if (!this._indoorData[T]) {
                return
            }
            var hN = this._indoorData[T];
            for (var e = 0; e < hN.tileKeys.length; e++) {
                if (hN.tileKeys[e] === hO) {
                    hN.tileKeys.splice(e, 1);
                    break
                }
            }
            delete hN[hO];
            if (hN.tileKeys.length === 0) {
                delete this._indoorData[T]
            }
        };
        aS.prototype.getIndoorData = function (e) {
            return this._indoorData[e] || null
        };
        aS.prototype.getData = function () {
            return this._indoorData
        };
        bl.register(function (e) {
            e._indoorMgr = new aS(e)
        });
        var ei = (function () {
            var hN = {};
            var hW = {};
            var hS = {};

            function hU(hY) {
                if (Object.prototype.toString.call(hY) === "[object Object]") {
                    for (var hX in hY) {
                        return false
                    }
                    return true
                } else {
                    return false
                }
            }

            function hT(h4, h5, h8, h1, h7) {
                var hX = hX || null;
                h1 = h1 || hX;
                var hZ;
                if (h1) {
                    hZ = hV(h4, h5, h8, h1)
                } else {
                    hZ = T(h4, h5, h8, h7)
                }
                var h3 = hZ.drawId;
                var hY = hZ.style;
                var h6 = hZ.styleUpdate;
                var h9 = [];
                if (!h3) {
                    return h9
                }
                for (var h0 = 0; h0 < h3.length; h0++) {
                    var h2 = h6[h3[h0]] || hY[h3[h0]];
                    if (h2) {
                        switch (h5) {
                            case "polygon":
                                h2 = hO(h2, h4);
                                break;
                            case "line":
                                h2 = hR(h2, h4);
                                break;
                            case "pointText":
                                h2 = hP(h2, h4);
                                break;
                            case "point":
                                h2 = e(h2, h4);
                                break;
                            case "polygon3d":
                                h2 = hQ(h2, h4);
                                break
                        }
                        if (h2) {
                            h2.did = h3[h0];
                            h9[h9.length] = h2
                        }
                    }
                }
                return h9
            }

            function hV(hY, h0, h1, hX) {
                var hZ = hX[2];
                switch (h0) {
                    case "point":
                        hZ = hZ[0];
                        break;
                    case "pointText":
                        hZ = hZ[1];
                        break;
                    case "line":
                        hZ = hZ[3];
                        break;
                    case "polygon":
                        hZ = hZ[4];
                        break;
                    case "polygon3d":
                        hZ = hZ[5];
                        break
                }
                var h3 = h1 - 1;
                if (h0 === "line" && h1 === 12) {
                    h3 = h1
                }
                var h4 = hX[1][h3][0];
                var h2 = h4[hY];
                if (!h2) {
                    if (h0 === "point" || h0 === "pointText") {
                        h4 = hX[1][h1][0];
                        h2 = h4[hY]
                    }
                }
                return {
                    drawId: h2,
                    style: hZ,
                    styleUpdate: []
                }
            }

            function T(h1, h2, h5, h4) {
                if (!h4) {
                    return {
                        drawId: null,
                        style: [],
                        styleUpdate: []
                    }
                }
                var h3;
                var hZ = h4.baseFs;
                h3 = h4.StyleBody || [];
                h3 = h4.zoomStyleBody[h5] || [];
                var hY = hZ[2];
                switch (h2) {
                    case "point":
                        hY = hY[0];
                        h3 = h3[0] || {};
                        break;
                    case "pointText":
                        hY = hY[1];
                        h3 = h3[1] || {};
                        break;
                    case "line":
                        hY = hY[3];
                        h3 = h3[3] || {};
                        break;
                    case "polygon":
                        hY = hY[4];
                        h3 = h3[4] || {};
                        break;
                    case "polygon3d":
                        hY = hY[5];
                        h3 = h3[5] || {};
                        break
                }
                var hX = hZ[1][h5 - 1][0];
                var h0 = hX[h1];
                return {
                    drawId: h0,
                    style: hY,
                    styleUpdate: h3
                }
            }

            function hP(hY, hX) {
                if (!hY || hY.length === 0) {
                    return null
                }
                return {
                    sid: hX,
                    fontRgba: i(hY[0]),
                    haloRgba: i(hY[1]),
                    backRgba: i(hY[2]),
                    fontSize: hY[3],
                    haloSize: hY[4],
                    fontWeight: hY[5],
                    fontStyle: hY[6],
                    density: hY[7]
                }
            }

            function e(hY, hX) {
                return {
                    sid: hX,
                    rank: hY[0],
                    ucflag: hY[1],
                    icon: hY[2],
                    iconType: hY[3],
                    nineGG: hY[4],
                    density: hY[5],
                    zoom: hY[6]
                }
            }

            function hR(hY, hX) {
                return {
                    sid: hX,
                    borderRgba: i(hY[0]),
                    fillRgba: i(hY[1]),
                    borderWidth: hY[2],
                    fillWidth: hY[3],
                    borderCap: hY[4],
                    fillCap: hY[5],
                    haveBorderLine: hY[6],
                    haveBorderTexture: hY[7],
                    haveFillTexture: hY[8],
                    isUseBorderRgba: hY[9],
                    isUseFillRgba: hY[10],
                    borderTexture: hY[11],
                    fillTexture: hY[12],
                    borderTextureType: hY[13],
                    fillTextureType: hY[14],
                    isRealWidth: hY[15],
                    haveArrow: hY[16],
                    needRound: hY[17],
                    realBorderWidth: hY[18]
                }
            }

            function hO(hY, hX) {
                if (hX === 2532) { }
                return {
                    sid: hX,
                    fillRgba: i(hY[0]),
                    borderRgba: i(hY[1]),
                    borderWidth: hY[2],
                    borderTexture: hY[3],
                    borderTextureType: hY[4],
                    waterStyle: hY[5],
                    haloStyle: hY[6],
                    textureStyle: hY[7],
                    thickRgba: i(hY[8])
                }
            }

            function hQ(hY, hX) {
                return {
                    sid: hX,
                    filter: hY[0],
                    ratio: hY[1],
                    haveBorder: hY[2],
                    borderWidth: hY[3],
                    borderRgba: i(hY[4]),
                    fillTop: i(hY[5]),
                    fillSide: i(hY[6]),
                    polyTexture: hY[7]
                }
            }

            function i(h2) {
                var h1 = h2;
                if (hS[h1]) {
                    return hS[h1]
                }
                h2 = h2 >>> 0;
                var h0 = (h2) & 255;
                var hZ = (h2 >> 8) & 255;
                var hX = (h2 >> 16) & 255;
                var hY = (h2 >> 24) & 255;
                hS[h1] = [h0, hZ, hX, hY];
                return hS[h1]
            }
            return {
                getStyleFromCache: function (h4, hZ, h2, h3, hY, h1, hX) {
                    h4 = h4 || "default";
                    var h0 = h4 + "-" + hZ + "-" + h2 + "-" + h3;
                    if (h1) {
                        h0 += "-indoor"
                    }
                    if (hY) {
                        if (!hW[h0]) {
                            hW[h0] = hT(hZ, h2, h3, hY)
                        }
                        return hW[h0]
                    }
                    if (!hN[h0]) {
                        hN[h0] = hT(hZ, h2, h3, hY, hX)
                    }
                    return hN[h0]
                }
            }
        })();
        bl.register(function (i) {
            var e = new dD(i)
        });

        function dD(e) {
            e.container.appendChild(this.render());
            this.bind(e)
        }
        dD.prototype.render = function () {
            var i = document.createElement("div");
            i.className = "click-ripple-container";
            var e = document.createElement("div");
            e.className = "click-ripple";
            i.appendChild(e);
            this._div = i;
            this._ripple = e;
            return i
        };
        dD.prototype.bind = function (i) {
            var e = this;
            i.addEventListener("spotclick", function (T) {
                if (!T.spots || T.spots.length === 0) {
                    return
                }
                e._div.style.left = T.pixel.x + "px";
                e._div.style.top = T.pixel.y + "px";
                C.ac(e._ripple, "ripple-playing")
            });
            C.on(e._ripple, "transitionend", function () {
                C.rc(e._ripple, "ripple-playing")
            })
        };

        function fY(e) {
            ea.call(this);
            if (!e) {
                return
            }
            this._opts = {};
            this._map = e;
            this._maxLat = 84.6;
            this._minLat = -80.6;
            this._maxLatMC = ek.convertLL2MC(new c0(this._maxLat, 0)).lat;
            this._minLatMC = ek.convertLL2MC(new c0(this._minLat, 0)).lat
        }
        fY.inherits(ea, "ToolbarItem");
        C.extend(fY.prototype, {
            open: function () {
                if (this._isOpen == true) {
                    return true
                }
                if (this._map._toolInUse) {
                    return false
                }
                this._map._toolInUse = true;
                this._isOpen = true;
                return true
            },
            close: function () {
                if (!this._isOpen) {
                    return
                }
                this._map._toolInUse = false;
                this._isOpen = false
            },
            _checkStr: function (e) {
                if (!e) {
                    return ""
                }
                return e.replace(/</g, "&lt;").replace(/>/g, "&gt;")
            }
        });

        function gH(T, i) {
            fY.call(this, T);
            i = i || {};
            this._opts = C.extend(C.extend(this._opts || {}, {
                autoClear: false,
                tips: "测距",
                followText: "单击确定起点，双击结束绘制",
                unit: "metric",
                showResult: true,
                lineColor: "blue",
                lineStroke: 2,
                opacity: 1,
                lineStyle: "solid",
                cursor: e0.distCursor,
                styleCodes: {
                    lnCode: 0,
                    spCode: 0,
                    slCode: 0,
                    tlCode: 0
                },
                enableMassClear: true
            }), i);
            if (this._opts.showResult === false) {
                if (typeof i.tips === "undefined") {
                    this._opts.tips = "绘制折线"
                }
                if (!i.cursor) {
                    this._opts.cursor = "crosshair"
                }
            }
            if (this._opts.lineStroke <= 0) {
                this._opts.lineStroke = 2
            }
            if (this._opts.opacity > 1) {
                this._opts.opacity = 1
            } else {
                if (this._opts.opacity < 0) {
                    this._opts.opacity = 0
                }
            } if (this._opts.lineStyle !== "solid" && this._opts.lineStyle !== "dashed") {
                this._opts.lineStyle = "solid"
            }
            this._checked = false;
            this._drawing = null;
            this.followTitle = null;
            this._totalDis = {};
            this._points = [];
            this._paths = [];
            this._dots = [];
            this._segDistance = [];
            this._overlays = [];
            this._units = {
                metric: {
                    name: "metric",
                    conv: 1,
                    incon: 1000,
                    u1: "米",
                    u2: "公里"
                },
                us: {
                    name: "us",
                    conv: 3.2808,
                    incon: 5279.856,
                    u1: "英尺",
                    u2: "英里"
                }
            };
            if (!this._units[this._opts.unit]) {
                this._opts.unit = "metric"
            }
            this._dLineColor = "#ff6319";
            this._dLineStroke = 3;
            this._dOpacity = 0.8;
            this._dLineStyle = "solid";
            this._dCursor = e0.distCursor;
            if (this._opts.showResult) {
                this._opts.followText = "单击确定起点"
            }
            this._followTextM = "单击确定地点，双击结束";
            this._sectionMarkerTip = "单击可删除此点，拖拽可调整位置";
            this._movingTimerId = null;
            if (this._opts.showResult) {
                this.text = "测距"
            } else {
                this.text = "绘线"
            }
            this._isOpen = false;
            var e = this;
            d7.load("tools", function () {
                e._draw()
            })
        }
        gH.inherits(fY, "PolylineTItem");
        C.extend(gH.prototype, {
            setLineColor: function (e) {
                this._opts.lineColor = e
            },
            setLineStroke: function (e) {
                if (Math.round(e) > 0) {
                    this._opts.lineStroke = Math.round(e)
                }
            },
            setOpacity: function (e) {
                if (e >= 0 && e <= 1) {
                    this._opts.opacity = e
                }
            },
            setLineStyle: function (e) {
                if (e === "solid" || e === "dashed") {
                    this._opts.lineStyle = e
                }
            },
            clear: function () {
                for (var T = 0, e = this._overlays.length; T < e; T++) {
                    if (this._overlays[T]) {
                        this._map.removeOverlay(this._overlays[T])
                    }
                }
                this._overlays.length = 0;
                for (var T = 0, e = this._dots.length; T < e; T++) {
                    if (this._dots[T] && this._dots[T].parentNode) {
                        this._dots[T].parentNode.removeChild(this._dots[T])
                    }
                }
                this._dots.length = 0
            },
            setCursor: function (e) {
                if (this._opts.showResult === true) {
                    return
                }
                this._opts.cursor = e
            },
            getCursor: function () {
                if (this._opts.showResult === true) {
                    return this._dCursor
                }
                var e = this._opts.cursor.match(/^url\((.+)\)(,.*)?/);
                if (e !== null) {
                    return e[1]
                } else {
                    return this._opts.cursor
                }
            },
            showResult: function (e) {
                this._opts.showResult = !!e
            }
        });

        function cr() {
            var hO = 3;
            var hV = 256;
            var hN = Math.pow(2, 18 - hO) * hV;
            var hW = 2;
            var hU = (hW + 1) * hN;
            var T = ek.convertLL2MC(new ho(180, 0));
            var hS = T.lng;
            var hQ = hU - hS;
            var hT = -3;
            var e = hT * hN;
            var hP = ek.convertLL2MC(new ho(-180, 0));
            var hR = hP.lng;
            var i = hR - e;
            this._validPixels = hS / Math.pow(2, 18 - hO);
            this._mc180X = hS;
            this._mcM180X = hR;
            this._loopOffset = hQ + i;
            this._mcTSpan = hS - hR;
            this._spaceDistance = hQ;
            this._mSpaceDistance = i
        }
        cr.prototype = {
            calcLoopParam: function (hN, i, hU) {
                hU = hU || 256;
                var hR = 0;
                var hO = 3;
                var hQ = 6;
                var hP = hQ * Math.pow(2, (i - hO)) * 256 / hU;
                var hT = hP / 2 - 1;
                var hS = -hP / 2;
                while (hN > hT) {
                    hN -= hP;
                    hR -= this._loopOffset
                }
                while (hN < hS) {
                    hN += hP;
                    hR += this._loopOffset
                }
                var e = hR;
                hR = Math.round(hR / Math.pow(2, 18 - i));
                return {
                    offsetX: hR,
                    geoOffsetX: e,
                    col: hN,
                    T: hP,
                    maxCol: hT,
                    minCol: hS
                }
            },
            calcLoopCenterPoint: function (i) {
                var e = i.lng;
                while (e > this._mc180X) {
                    e -= this._mcTSpan
                }
                while (e < this._mcM180X) {
                    e += this._mcTSpan
                }
                i.lng = e;
                return i
            },
            calcLoopMapBounds: function (T, hN) {
                var i = hN || T.getCenter();
                var e = T.sw.lng;
                var hO = T.ne.lng;
                while (i.lng > this._mc180X) {
                    i.lng -= this._mcTSpan;
                    e -= this._mcTSpan;
                    hO -= this._mcTSpan
                }
                while (i.lng < this._mcM180X) {
                    i.lng += this._mcTSpan;
                    e += this._mcTSpan;
                    hO += this._mcTSpan
                }
                T.sw.lng = e;
                T.ne.lng = hO;
                if (T.pointBottomLeft) {
                    T.pointBottomLeft = this.calcLoopCenterPoint(T.pointBottomLeft);
                    T.pointTopLeft = this.calcLoopCenterPoint(T.pointTopLeft);
                    T.pointTopRight = this.calcLoopCenterPoint(T.pointTopRight);
                    T.pointBottomRight = this.calcLoopCenterPoint(T.pointBottomRight)
                }
                return T
            },
            calcLoopTiles: function (hV, e, hZ, hS) {
                hZ = hZ || 256;
                var hO = hS || Math.pow(2, 18 - e) * hZ;
                var hU = Math.floor(this._mc180X / hO);
                var hQ = Math.floor(this._mcM180X / hO);
                var hW = Math.floor(this._loopOffset / hO);
                var hX = [];
                for (var hR = 0; hR < hV.length; hR++) {
                    var hY = hV[hR];
                    var hN = hY[0];
                    var h0 = hY[1];
                    if (hN >= hU) {
                        var hT = hN + hW;
                        if (this.isTileBlank(hT, e, hZ) === true) {
                            continue
                        }
                        var T = "id_" + hT + "_" + h0 + "_" + e;
                        if (!hV[T]) {
                            hV[T] = true;
                            hX.push([hT, h0, e, 0])
                        }
                    } else {
                        if (hN <= hQ) {
                            var hT = hN - hW;
                            if (this.isTileBlank(hT, e, hZ) === true) {
                                continue
                            }
                            var T = "id_" + hT + "_" + h0 + "_" + e;
                            if (!hV[T]) {
                                hV[T] = true;
                                hX.push([hT, h0, e, 0])
                            }
                        }
                    }
                }
                for (var hR = 0, hP = hX.length; hR < hP; hR++) {
                    hV.push(hX[hR])
                }
                for (var hR = hV.length - 1; hR >= 0; hR--) {
                    var hN = hV[hR][0];
                    if (this.isTileBlank(hN, e, hZ)) {
                        hV.splice(hR, 1)
                    }
                }
                return hV
            },
            isTileBlank: function (T, hO, e) {
                var hP = Math.pow(2, hO - 3);
                var i = Math.round(this._validPixels * hP);
                var hN = 6 * hP * 256 / e;
                while (T > hN / 2 - 1) {
                    T -= hN
                }
                while (T < -(hN / 2)) {
                    T += hN
                }
                if (T > 0 && T * e > i) {
                    return true
                }
                if (T < 0 && Math.abs((T + 1) * e) > i) {
                    return true
                }
                return false
            },
            isAddWidth: function (e, i) {
                return e < this._mcM180X || i > this._mc180X
            },
            getSpaceDistanceInPixel: function (i) {
                var e = Math.round((this._spaceDistance + this._mSpaceDistance) / Math.pow(2, 18 - i));
                return e
            }
        };
        var d0 = new cr();
        var cb = (function () {
            var e = true;
            var hN = 256;
            var hP = aB("ditu", "normalTraffic");
            var T = hP.udt;
            var hQ = "https://its.map.baidu.com/traffic/";
            var hO = [
                [2, "79,210,125,1", 3, 2, 0, [], 0, 0],
                [2, "79,210,125,1", 3, 2, 0, [], 0, 0],
                [2, "79,210,125,1", 4, 2, 0, [], 0, 0],
                [2, "79,210,125,1", 5, 2, 0, [], 0, 0],
                [2, "79,210,125,1", 6, 2, 0, [], 0, 0],
                [2, "255,208,69,1", 3, 2, 0, [], 0, 0],
                [2, "255,208,69,1", 3, 2, 0, [], 0, 0],
                [2, "255,208,69,1", 4, 2, 0, [], 0, 0],
                [2, "255,208,69,1", 5, 2, 0, [], 0, 0],
                [2, "255,208,69,1", 6, 2, 0, [], 0, 0],
                [2, "232,14,14,1", 3, 2, 0, [], 0, 0],
                [2, "232,14,14,1", 3, 2, 0, [], 0, 0],
                [2, "232,14,14,1", 4, 2, 0, [], 0, 0],
                [2, "232,14,14,1", 5, 2, 0, [], 0, 0],
                [2, "232,14,14,1", 6, 2, 0, [], 0, 0],
                [2, "181,0,0,1", 3, 2, 0, [], 0, 0],
                [2, "181,0,0,1", 3, 2, 0, [], 0, 0],
                [2, "181,0,0,1", 4, 2, 0, [], 0, 0],
                [2, "181,0,0,1", 5, 2, 0, [], 0, 0],
                [2, "181,0,0,1", 6, 2, 0, [], 0, 0],
                [2, "255,255,255,1", 4, 0, 0, [], 0, 0],
                [2, "255,255,255,1", 5.5, 0, 0, [], 0, 0],
                [2, "255,255,255,1", 7, 0, 0, [], 0, 0],
                [2, "255,255,255,1", 8.5, 0, 0, [], 0, 0],
                [2, "255,255,255,1", 10, 0, 0, [], 0, 0]
            ];
            var i = new cO({
                transparentPng: true,
                dataType: 2,
                cacheSize: 256,
                clipTile: true
            });
            i.zIndex = 2;
            i.getTilesUrl = function (hT, hU) {
                if (!hT || hU < 7) {
                    return null
                }
                var hS = hT.x;
                var hV = hT.y;
                var hR = hQ + "?qt=vtraffic&z=" + hU + "&x=" + hS + "&y=" + hV + "&udt=" + T;
                return hR
            };
            i.setColors = function (hR) {
                for (var hU = 0; hU < hO.length; hU++) {
                    var hT = Math.floor(hU / 5);
                    var hS = hR[hT];
                    if (hS) {
                        if (Object.prototype.toString.call(hS) === "[object String]") {
                            hS = gW.parseCSSColor(hS)
                        }
                        hO[hU][1] = [hS[0], hS[1], hS[2], hS[3] / 255].join(",")
                    }
                }
            };
            i.processData = function (hU) {
                var hY = hU.content;
                var hW = 10;
                if (typeof hU.precision === "number") {
                    hW = hU.precision * 10
                }
                var h5 = {
                    road: [
                        [],
                        []
                    ]
                };
                if (!hY) {
                    return h5
                }
                var h3 = hY.tf;
                if (!h3) {
                    return h5
                }
                for (var hV = 0; hV < h3.length; hV++) {
                    var h4 = h3[hV][1];
                    var h2 = [];
                    var h0 = 0;
                    var hZ = 0;
                    var h1 = hO[h3[hV][3]];
                    for (var hT = 0, hR = h4.length; hT < hR / 2; hT++) {
                        h0 += h4[hT * 2] / hW;
                        hZ += h4[hT * 2 + 1] / hW;
                        h2.push(h0, 256 - hZ)
                    }
                    var hS = h1[1].split(",");
                    hS[3] = hS[3] * 255;
                    var hX = h1[2] / 2;
                    h5.road[0].push([h2, 1, 2, [255, 255, 255, 255], hX + 2]);
                    h5.road[1].push([h2, 1, 2, hS, hX])
                }
                return h5
            };
            return i
        })();
        bl.register(function (i) {
            if (i.config && i.config.isOverviewMap) {
                return
            }
            if (i.isLoaded()) {
                fz(i)
            } else {
                i.addEventListener("load", function () {
                    fz(this)
                })
            }
            i.cityName = "中国";
            i.cCode = "1";
            var e = {};
            e.enableRequest = true;
            e.request = function () {
                if (e.enableRequest) {
                    e.enableRequest = false;
                    setTimeout(function () {
                        e._request()
                    }, 500)
                }
            };
            e._request = function () {
                var hN = i.getBoundsIn();
                var hP = i.getZoom();
                var T = hN.getSouthWest();
                var hO = hN.getNorthEast();
                cy.request(function (hT) {
                    if (hT.current_city["code"] >= 9000 && hT.current_city["code"] <= 9378) {
                        hT.current_city["name"] = "台湾省"
                    }
                    if (hT.current_city["code"] >= 20000 && hT.current_city["code"] <= 20499) {
                        hT.current_city["name"] = "新加坡"
                    }
                    if (hT.current_city["code"] >= 20500 && hT.current_city["code"] <= 25999) {
                        hT.current_city["name"] = "泰国"
                    }
                    if (hT.current_city["code"] >= 26000 && hT.current_city["code"] <= 29999) {
                        hT.current_city["name"] = "日本"
                    }
                    if (hT.current_city["code"] >= 30000 && hT.current_city["code"] <= 30999) {
                        hT.current_city["name"] = "韩国"
                    }
                    if (hT.current_city["code"] >= 31000 && hT.current_city["code"] <= 37000) {
                        hT.current_city["name"] = "亚太"
                    }
                    if (hT.current_city["code"] >= 46609 && hT.current_city["code"] <= 52505) {
                        hT.current_city["name"] = "欧洲"
                    }
                    if (hT.current_city["code"] >= 39509 && hT.current_city["code"] <= 53500) {
                        hT.current_city["name"] = "南美洲"
                    }
                    if (hT.current_city["code"] >= 54000 && hT.current_city["code"] <= 70000) {
                        hT.current_city["name"] = "北美洲"
                    }
                    if (hT.current_city["code"] === 54003 && hT.current_city["code"] >= 60731 && hT.current_city["code"] <= 61123) {
                        hT.current_city["name"] = "美国"
                    }
                    if (hT.current_city["code"] === 54015 || hT.current_city["code"] >= 57970 && hT.current_city["code"] <= 60223) {
                        hT.current_city["name"] = "加拿大"
                    }
                    if (hT.current_city["code"] === 54025 || hT.current_city["code"] >= 54338 && hT.current_city["code"] <= 57374) {
                        hT.current_city["name"] = "墨西哥"
                    }
                    e.enableRequest = true;
                    if (hT && hT.current_city) {
                        var hS = hT.current_city["name"];
                        var hR = hT.current_city["code"];
                        if (hR !== i.cCode) {
                            var hQ = new a8("oncitychange");
                            hQ.name = hS;
                            hQ.code = hR;
                            i.dispatchEvent(hQ)
                        }
                        i.cityName = hS;
                        i.cCode = hR;
                        if (!f1()) {
                            es(i)
                        }
                    }
                }, {
                    qt: "cen",
                    b: T.lng + "," + T.lat + ";" + hO.lng + "," + hO.lat,
                    l: hP
                }, "", "", true)
            };
            i.addEventListener("load", function (T) {
                e.request()
            });
            i.addEventListener("moveend", function (T) {
                e.request()
            });
            i.addEventListener("zoomend", function (T) {
                e.request()
            });
            e.request()
        });

        function fz(i) {
            if (i.temp.copyadded) {
                return
            }
            i.temp.copyadded = true;
            if (!i.cpyCtrl) {
                var hN = new d6(2, 2);
                i.config.cpyCtrlOffset = hN;
                if (f1()) {
                    hN.width = 72;
                    hN.height = 0
                }
                var T = new dE({
                    offset: hN,
                    printable: true
                });
                i.cpyCtrl = T
            }
            if (!f1()) {
                es(i);
                i.addEventListener("maptypechange", function () {
                    es(i)
                })
            }
            i.addControl(T);
            var e = new af();
            e._opts = {
                printable: true
            };
            i.logoCtrl = e;
            i.addControl(e);
            i.addEventListener("resize", function () {
                if (this.getSize().width >= 300 && i.getSize().height >= 100) {
                    e.show();
                    T.setOffset(i.config.cpyCtrlOffset)
                } else {
                    e.hide();
                    T.setOffset(new d6(4, 2))
                }
            });
            if (i.getSize().width >= 300 && i.getSize().height >= 100) {
                e.show()
            } else {
                e.hide();
                T.setOffset(new d6(4, 2))
            }
            i.addEventListener("oncopyrightoffsetchange", function (hO) {
                i.logoCtrl.setOffset(hO.target.logo);
                i.cpyCtrl.setOffset(hO.target.cpy)
            });
            i.dispatchEvent(new a8("oncopyrightaddend"))
        }

        function es(h2) {
            if (!h2.cpyCtrl) {
                var ia = new d6(2, 2);
                if (f1()) {
                    ia.width = 72;
                    ia.height = 0
                }
                var h5 = new dE({
                    offset: ia,
                    printable: true
                });
                h2.cpyCtrl = h5
            }
            var ik = h2.cityName || "中国";
            var h3 = h2.getMapType();
            var h4 = ["常州市", "南昌市", "乌鲁木齐市", "无锡市", "福州市", "泉州市", "珠海市", "贵阳市"];
            var hW = ["北京市", "上海市", "广州市", "深圳市", "宁波市", "石家庄市", "沈阳市", "长春市", "青岛市", "温州市", "台州市", "金华市", "佛山市", "中山市", "昆明市", "南宁市", "苏州市", "西安市", "济南市", "郑州市", "合肥市", "呼和浩特市", "杭州市", "成都市", "武汉市", "长沙市", "天津市", "南京市", "重庆市", "大连市", "东莞市", "厦门市"];
            var hY = ["香港特别行政区"];
            var hS = ["台湾省"];
            var ib = ["日本"];
            var ii = ["韩国"];
            var h6 = ["泰国"];
            var h9 = ["亚太"];
            var hT = ["新加坡"];
            var ij = ["欧洲"];
            var hN = ["南美洲"];
            var ie = ["北美洲"];
            var T = ["美国"];
            var h8 = ["墨西哥"];
            var hQ = ["加拿大"];
            for (var ig in h4) {
                if (h4[ig] === ik) {
                    var hZ = true;
                    break
                }
            }
            for (var ig in hW) {
                if (hW[ig] === ik) {
                    var hO = true;
                    break
                }
            }
            for (var ig in hY) {
                if (hY[ig] === ik) {
                    var im = true;
                    break
                }
            }
            if (hS[0] === ik) {
                var id = true
            }
            if (hT[0] === ik) {
                var i = true
            }
            if (ib[0] === ik) {
                var hV = true
            }
            if (ii[0] === ik) {
                var h1 = true
            }
            if (h6[0] === ik) {
                var h0 = true
            }
            if (h9[0] === ik) {
                var hR = true
            }
            if (ij[0] === ik) {
                var hX = true
            }
            if (hN[0] === ik) {
                var hU = true
            }
            if (ie[0] === ik) {
                var e = true
            }
            if (T[0] === ik) {
                var ih = true
            }
            if (hQ[0] === ik) {
                var ic = true
            }
            if (h8[0] === ik) {
                var hP = true
            }
            var il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "];
            var h7 = "rgba(255, 255, 255, 0.701961)";
            if (h2.getZoom() <= 9) {
                il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
            } else {
                if (id) {
                    il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
                } else {
                    if (hV || h1) {
                        il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
                    } else {
                        if (i || h0) {
                            il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
                        } else {
                            if (hR) {
                                il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
                            } else {
                                if (hX) {
                                    il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
                                } else {
                                    if (hU) {
                                        il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
                                    } else {
                                        if (e) {
                                            il = ["&copy;&nbsp;2021 Baidu - GS(2019)5218号 - 甲测资字1100930 - 京ICP证030173号 - Data &copy; "]
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } if (h2.getZoom() <= 9) {
                il.push("长地万方");
                il.push(' &amp; <a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>');
                il.push(' &amp; <a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>');
                if (h3 === BMAP_SATELLITE_MAP || h3 === BMAP_HYBRID_MAP) {
                    il.push(' &amp; <a target="_blank" href="http://www.eso.org/public/">ESO</a>');
                    h7 = "rgba(0,0,0,.7)"
                }
            } else {
                if (hV || h1) {
                    il.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>')
                } else {
                    if (i || h0) {
                        il.push('<a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>')
                    } else {
                        if (hR) {
                            il.push('<a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>');
                            il.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>')
                        } else {
                            if (hX) {
                                il.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>');
                                il.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>')
                            } else {
                                if (hU) {
                                    il.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>');
                                    il.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>')
                                } else {
                                    if (ih || hP || ic) {
                                        il.push('<a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>');
                                        il.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>')
                                    } else {
                                        if (e) {
                                            il.push('<a target="_blank" href="http://www.openstreetmap.org/">OpenStreetMap</a>');
                                            il.push(' &amp; <a target="_blank" href="https://www.mapbox.com/">Mapbox</a>')
                                        } else {
                                            il.push("长地万方");
                                            if (hZ) {
                                                il.push(' &amp; <a target="_blank" href="http://www.palmcity.cn/palmcity/">PalmCity</a>')
                                            }
                                            if (im) {
                                                il.push(' &amp; <a target="_blank" href="http://www.mapking.com/HongKong/eng/home/MapKing_Webmap.html">MapKing</a>')
                                            }
                                            if (id) {
                                                il.push(' &amp; <a target="_blank" href="http://corporate.navteq.com/supplier_terms.html">HERE</a>');
                                                il.push(' &amp; <a target="_blank" href="http://www.localking.com.tw/about/localking.aspx">房LocalKing</a>')
                                            }
                                            if (h3 === BMAP_SATELLITE_MAP || h3 === BMAP_HYBRID_MAP) {
                                                h7 = "rgba(0,0,0,.7)"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            il.unshift('<span style="background: ' + h7 + ';padding: 0px 1px;line-height: 16px;display: inline;height: 16px;">');
            il.push("</span>");
            il = il.join("");
            h2.cpyCtrl.addCopyright({
                id: 1,
                content: il
            })
        }
        window.BMAP_STATUS_SUCCESS = 0;
        window.BMAP_STATUS_CITY_LIST = 1;
        window.BMAP_STATUS_UNKNOWN_LOCATION = 2;
        window.BMAP_STATUS_UNKNOWN_ROUTE = 3;
        window.BMAP_STATUS_INVALID_KEY = 4;
        window.BMAP_STATUS_INVALID_REQUEST = 5;
        window.BMAP_STATUS_PERMISSION_DENIED = 6;
        window.BMAP_STATUS_SERVICE_UNAVAILABLE = 7;
        window.BMAP_STATUS_TIMEOUT = 8;
        window.BMAP_ROUTE_TYPE_WALKING = 2;
        window.BMAP_ROUTE_TYPE_DRIVING = 3;
        window.BMAP_ROUTE_TYPE_RIDING = 6;
        window.BMAP_ROUTE_STATUS_NORMAL = 0;
        window.BMAP_ROUTE_STATUS_EMPTY = 1;
        window.BMAP_ROUTE_STATUS_ADDRESS = 2;
        var eC = "cur";
        var bZ = "cen";
        var ej = "s";
        var P = "con";
        var dJ = "bd";
        var f9 = "nb";
        var hE = "bt";
        var cM = "nav";
        var eh = "walk";
        var hA = "gc";
        var fI = "rgc";
        var eu = "dec";
        var e8 = "bse";
        var fj = "nse";
        var g = "bl";
        var a9 = "bsl";
        var bm = "bda";
        var X = "sa";
        var ay = "nba";
        var bW = "drag";
        var H = "ext";
        var aM = "hip";
        var R = "ride";
        var fN = "drct";
        var gl = 2;
        var fK = 4;
        var g3 = 7;
        var g1 = 11;
        var fu = 12;
        var hy = 14;
        var bN = 15;
        var dG = 18;
        var fb = 20;
        var cF = 21;
        var cl = 19;
        var e5 = 23;
        var cf = 26;
        var ao = 28;
        var ef = 31;
        var cC = 35;
        var gd = 44;
        var hL = 45;
        var eF = 46;
        var cA = 47;
        var gu = -1;
        var gT = 0;
        var g8 = 1;
        var cj = 2;
        var b5 = 3;
        window.BMAP_POI_TYPE_NORMAL = 0;
        var Q = 1;
        var b9 = 2;
        BMapGL.I = C.I;
        var O = {};
        O.removeHtml = function (e) {
            e = e.replace(/<\/?[^>]*>/g, "");
            e = e.replace(/[ | ]* /g, " ");
            return e
        };
        O.parseGeoExtReg1 = function (e) {
            return e.replace(/([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0|[1-9]\d*),([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0|[1-9]\d*)(,)/g, "$1,$2;")
        };
        O.parseGeoExtReg2 = function (i, e) {
            var T = new RegExp("(((-?\\d+)(\\.\\d+)?),((-?\\d+)(\\.\\d+)?);)(((-?\\d+)(\\.\\d+)?),((-?\\d+)(\\.\\d+)?);){" + e + "}", "ig");
            return i.replace(T, "$1")
        };
        var fs = 0;
        var cE = 1;
        var g4 = 2;
        O.unique = function (T) {
            var hP = false;
            var hO = [];
            var hQ = {};
            for (var hN = 0, e = T.length; hN < e; hN++) {
                if (!hQ[T[hN]]) {
                    hQ[T[hN]] = true;
                    hO.push(T[hN])
                }
            }
            return hO
        };
        O.getBestLevel = function (T, i) {
            if (i) {
                var e = Math.min(i.width / 1100, i.height / 660);
                T = Math.round(T + (Math.log(e) / Math.log(2)))
            }
            if (T < 1) {
                T = 1
            }
            if (T > 21) {
                T = 21
            }
            return T
        };
        O.parseGeo = function (hQ, hT) {
            if (typeof hQ != "string" || !hQ) {
                return
            }
            var hV = hQ.split("|");
            var e;
            var hO;
            var T;
            if (hV.length == 1) {
                e = f6(hQ)
            } else {
                e = f6(hV[2]);
                hO = f6(hV[0]);
                T = f6(hV[1]);
                if (!hT) {
                    return e
                }
            }
            var hR = {
                type: e.geoType
            };
            if (hT) {
                switch (hR.type) {
                    case g4:
                        var hS = new ho(e.geo[0][0], e.geo[0][1]);
                        var hU = ek.convertMC2LL(hS);
                        hR.point = hU;
                        hR.points = [hU];
                        break;
                    case cE:
                        hR.points = [];
                        var hW = e.geo[0];
                        for (var hP = 0, hN = hW.length - 1; hP < hN; hP += 2) {
                            var hX = new ho(hW[hP], hW[hP + 1]);
                            hX = ek.convertMC2LL(hX);
                            hR.points.push(hX)
                        }
                        hO = new ho(hO.geo[0][0], hO.geo[0][1]);
                        T = new ho(T.geo[0][0], T.geo[0][1]);
                        hO = ek.convertMC2LL(hO);
                        T = ek.convertMC2LL(T);
                        hR.bounds = new dP(hO, T);
                        break;
                    default:
                        break
                }
            }
            return hR
        };
        O.parseGeoExt = function (h6, hX) {
            if (!hX) {
                hX = 0
            } else {
                if (hX < 0.25) {
                    hX = 0
                } else {
                    if (hX > 0.25 && hX < 1) {
                        hX = 1
                    } else {
                        if (hX > 32) {
                            hX = 32
                        }
                    }
                }
            }
            var hS = h6.split("|");
            if (hS.length == 1) {
                var hN = f6(hS[0]);
                return {
                    type: hN.type,
                    bound: "",
                    points: hN.geo.join(",")
                }
            } else {
                if (hS.length > 1) {
                    var hY = h6.split(";.=");
                    var hU = [];
                    var hO = [];
                    var hZ = 0;
                    var h3 = hY.length;
                    for (var h0 = 0; h0 < h3; h0++) {
                        var h5 = hY[h0];
                        if (h3 > 1) {
                            if (h0 == 0) {
                                h5 = h5 + ";"
                            }
                            if (h0 > 0 && h0 < h3 - 1) {
                                h5 = ".=" + h5 + ";"
                            }
                            if (h0 == h3 - 1) {
                                h5 = ".=" + h5
                            }
                        }
                        var hP = h5.split("|");
                        var h2 = f6(hP[0]);
                        var h1 = f6(hP[1]);
                        hU.push(h2.geo.join(","));
                        hU.push(h1.geo.join(","));
                        var hN = f6(hP[2]);
                        hZ = hN.type;
                        var h4 = hN.geo.join(",");
                        h4 = O.parseGeoExtReg1(h4);
                        if (hX > 0) {
                            h4 = O.parseGeoExtReg2(h4, hX)
                        }
                        hO.push(h4)
                    }
                    if (h3 <= 1) {
                        hO = hO.join(";")
                    }
                    if (h3 == 2) {
                        var T = hO[0] + ";" + hO[1];
                        var hQ = T.split(";");
                        var e = [];
                        for (var h0 = 0; h0 < hQ.length; h0++) {
                            var hT = hQ[h0].split(",")[0];
                            var hR = hQ[h0].split(",")[1];
                            var hV = new ho(hT, hR);
                            var hW = ek.convertMC2LL(hV);
                            e.push(hW)
                        }
                        hO = e
                    }
                    return {
                        type: hZ,
                        bound: hU.join(";"),
                        points: hO
                    }
                }
            }
        };
        O.getPoiPoint = function (e) {
            var T = [];
            var i = null;
            if (e.toString() == "Point") {
                i = e
            } else {
                if (typeof e == "string") {
                    T = C.trim(e).split(",");
                    if (T.length < 2) {
                        return
                    }
                    T[0] = parseFloat(C.trim(T[0]));
                    T[1] = parseFloat(C.trim(T[1]))
                } else {
                    T = e.slice(0);
                    if (T.length < 2) {
                        return
                    }
                }
                i = new BMap.Point(T[0], T[1])
            }
            return i
        };
        O.parseGeoStr = function (T) {
            var i = T.split(",");
            var e = new ho(i[0], i[1]);
            return ek.convertMC2LL(e)
        };
        O.level = {
            country: 4,
            province: 11,
            city: 12,
            area: 13
        };
        var hF = ["=", ".", "-", "*"];
        var f0 = 1 << 23;

        function f6(hT) {
            var hS = a6(hT.charAt(0));
            var T = hT.substr(1);
            var hV = 0;
            var e = T.length;
            var hW = [];
            var hQ = [];
            var hR = [];
            while (hV < e) {
                if (T.charAt(hV) == hF[0]) {
                    if ((e - hV) < 13) {
                        return 0
                    }
                    hR = aJ(T.substr(hV, 13), hW);
                    if (hR < 0) {
                        return 0
                    }
                    hV += 13
                } else {
                    if (T.charAt(hV) == ";") {
                        hQ.push(hW.slice(0));
                        hW.length = 0;
                        ++hV
                    } else {
                        if ((e - hV) < 8) {
                            return 0
                        }
                        hR = c3(T.substr(hV, 8), hW);
                        if (hR < 0) {
                            return 0
                        }
                        hV += 8
                    }
                }
            }
            for (var hP = 0, hN = hQ.length; hP < hN; hP++) {
                for (var hO = 0, hU = hQ[hP].length; hO < hU; hO++) {
                    hQ[hP][hO] /= 100
                }
            }
            return {
                geoType: hS,
                geo: hQ
            }
        }

        function a6(i) {
            var e = -1;
            if (i == hF[1]) {
                e = g4
            } else {
                if (i == hF[2]) {
                    e = cE
                } else {
                    if (i == hF[3]) {
                        e = fs
                    }
                }
            }
            return e
        }

        function aJ(hO, T) {
            var e = 0;
            var hQ = 0;
            var hP = 0;
            for (var hN = 0; hN < 6; hN++) {
                hP = cL(hO.substr(1 + hN, 1));
                if (hP < 0) {
                    return -1 - hN
                }
                e += hP << (6 * hN);
                hP = cL(hO.substr(7 + hN, 1));
                if (hP < 0) {
                    return -7 - hN
                }
                hQ += hP << (6 * hN)
            }
            T.push(e);
            T.push(hQ);
            return 0
        }

        function c3(hP, hN) {
            var T = hN.length;
            if (T < 2) {
                return -1
            }
            var e = 0;
            var hR = 0;
            var hQ = 0;
            for (var hO = 0; hO < 4; hO++) {
                hQ = cL(hP.substr(hO, 1));
                if (hQ < 0) {
                    return -1 - hO
                }
                e += hQ << (6 * hO);
                hQ = cL(hP.substr(4 + hO, 1));
                if (hQ < 0) {
                    return -5 - hO
                }
                hR += hQ << (6 * hO)
            }
            if (e > f0) {
                e = f0 - e
            }
            if (hR > f0) {
                hR = f0 - hR
            }
            hN.push(hN[T - 2] + e);
            hN.push(hN[T - 1] + hR);
            return 0
        }

        function cL(i) {
            var e = i.charCodeAt(0);
            if (i >= "A" && i <= "Z") {
                return e - "A".charCodeAt(0)
            } else {
                if (i >= "a" && i <= "z") {
                    return (26 + e - "a".charCodeAt(0))
                } else {
                    if (i >= "0" && i <= "9") {
                        return (52 + e - "0".charCodeAt(0))
                    } else {
                        if (i == "+") {
                            return 62
                        } else {
                            if (i == "/") {
                                return 63
                            }
                        }
                    }
                }
            }
            return -1
        }
        O.pathToPoints = function (hP) {
            var hN = [];
            if (typeof hP !== "string") {
                return hN
            } else {
                var hO = hP.split(";");
                for (var T = 0; T < hO.length; T++) {
                    var e = hO[T].split(",");
                    hN.push(new ho(e[0], e[1]))
                }
            }
            return hN
        };
        window.BMAP_POI_TYPE_NORMAL = 0;
        window.BMAP_POI_TYPE_BUSSTOP = 1;
        window.BMAP_POI_TYPE_BUSLINE = 2;
        window.BMAP_POI_TYPE_SUBSTOP = 3;
        window.BMAP_POI_TYPE_SUBLINE = 4;
        var hr = 0;
        var fT = 1;
        var c2 = {};
        window.APIPack = c2;

        function fy(i, e) {
            ea.call(this);
            this._loc = {};
            this.setLocation(i);
            e = e || {};
            e.renderOptions = e.renderOptions || {};
            this._opts = {
                renderOptions: {
                    panel: e.renderOptions.panel || null,
                    map: e.renderOptions.map || null,
                    autoViewport: e.renderOptions.autoViewport || true,
                    selectFirstResult: e.renderOptions.selectFirstResult,
                    highlightMode: e.renderOptions.highlightMode,
                    enableDragging: e.renderOptions.enableDragging || false
                },
                onSearchComplete: e.onSearchComplete || function () { },
                onMarkersSet: e.onMarkersSet || function () { },
                onInfoHtmlSet: e.onInfoHtmlSet || function () { },
                onResultsHtmlSet: e.onResultsHtmlSet || function () { },
                onGetBusListComplete: e.onGetBusListComplete || function () { },
                onGetBusLineComplete: e.onGetBusLineComplete || function () { },
                onBusListHtmlSet: e.onBusListHtmlSet || function () { },
                onBusLineHtmlSet: e.onBusLineHtmlSet || function () { },
                onPolylinesSet: e.onPolylinesSet || function () { },
                reqFrom: e.reqFrom || ""
            };
            if (typeof e != "undefined" && typeof e.renderOptions != "undefined" && typeof e.renderOptions["autoViewport"] != "undefined") {
                this._opts.renderOptions.autoViewport = e.renderOptions["autoViewport"]
            } else {
                this._opts.renderOptions.autoViewport = true
            }
            this._opts.renderOptions.panel = C.G(this._opts.renderOptions.panel)
        }
        fy.inherits(ea, "BaseSearch");
        C.extend(fy.prototype, {
            getResults: function () {
                if (!this._isMultiKey) {
                    return this._results
                } else {
                    return this._arrResults
                }
            },
            enableAutoViewport: function () {
                this._opts.renderOptions.autoViewport = true
            },
            disableAutoViewport: function () {
                this._opts.renderOptions.autoViewport = false
            },
            setLocation: function (e) {
                if (!e) {
                    return
                }
                this._loc.src = e
            },
            setSearchCompleteCallback: function (e) {
                this._opts.onSearchComplete = e || function () { }
            },
            setMarkersSetCallback: function (e) {
                this._opts.onMarkersSet = e || function () { }
            },
            setPolylinesSetCallback: function (e) {
                this._opts.onPolylinesSet = e || function () { }
            },
            setInfoHtmlSetCallback: function (e) {
                this._opts.onInfoHtmlSet = e || function () { }
            },
            setResultsHtmlSetCallback: function (e) {
                this._opts.onResultsHtmlSet = e || function () { }
            },
            getStatus: function () {
                return this._status
            }
        });
        var dK = function (T, i) {
            fy.call(this, T, i);
            i = i || {};
            i.renderOptions = i.renderOptions || {};
            this.setPageCapacity(i.pageCapacity);
            if (typeof i.renderOptions["selectFirstResult"] != "undefined" && !i.renderOptions["selectFirstResult"]) {
                this.disableFirstResultSelection()
            } else {
                this.enableFirstResultSelection()
            }
            this._overlays = [];
            this._arrPois = [];
            this._curIndex = -1;
            this._queryList = [];
            var e = this;
            d7.load("localSearch", function () {
                e._check()
            }, true)
        };
        dK.inherits(fy, "LocalSearch");
        dK.DEFAULT_PAGE_CAPACITY = 10;
        dK.MIN_PAGE_CAPACITY = 1;
        dK.MAX_PAGE_CAPACITY = 100;
        dK.DEFAULT_RADIUS = 2000;
        dK.MAX_RADIUS = 100000;
        C.extend(dK.prototype, {
            search: function (e, i) {
                this._queryList.push({
                    method: "search",
                    arguments: [e, i]
                })
            },
            searchInBounds: function (e, T, i) {
                this._queryList.push({
                    method: "searchInBounds",
                    arguments: [e, T, i]
                })
            },
            searchNearby: function (T, i, e, hN) {
                this._queryList.push({
                    method: "searchNearby",
                    arguments: [T, i, e, hN]
                })
            },
            clearResults: function () {
                delete this._json;
                delete this._status;
                delete this._results;
                delete this._ud;
                this._curIndex = -1;
                this._setStatus();
                if (this._opts.renderOptions.panel) {
                    this._opts.renderOptions.panel.innerHTML = ""
                }
            },
            gotoPage: function () { },
            enableFirstResultSelection: function () {
                this._opts.renderOptions.selectFirstResult = true
            },
            disableFirstResultSelection: function () {
                this._opts.renderOptions.selectFirstResult = false
            },
            setPageCapacity: function (e) {
                if (typeof e == "number" && !isNaN(e)) {
                    this._opts.pageCapacity = e < 1 ? dK.DEFAULT_PAGE_CAPACITY : (e > dK.MAX_PAGE_CAPACITY ? dK.DEFAULT_PAGE_CAPACITY : e)
                } else {
                    this._opts.pageCapacity = dK.DEFAULT_PAGE_CAPACITY
                }
            },
            getPageCapacity: function () {
                return this._opts.pageCapacity
            },
            toString: function () {
                return "LocalSearch"
            }
        });

        function V(i) {
            this._opts = {};
            C.extend(this._opts, i);
            this._queryList = [];
            var e = this;
            d7.load("otherSearch", function () {
                e._asyncSearch()
            })
        }
        V.inherits(ea, "Geocoder");
        C.extend(V.prototype, {
            getPoint: function (e, T, i) {
                this._queryList.push({
                    method: "getPoint",
                    arguments: [e, T, i]
                })
            },
            getLocation: function (e, T, i) {
                this._queryList.push({
                    method: "getLocation",
                    arguments: [e, T, i]
                })
            },
            toString: function () {
                return "Geocoder"
            }
        });

        function cP(e) {
            e = e || {};
            this.config = {
                timeout: e.timeout || 1000 * 10,
                maximumAge: e.maximumAge || 0,
                enableHighAccuracy: e.enableHighAccuracy || false,
                SDKLocation: e.SDKLocation || false
            };
            this._pendingCalls = [];
            var i = this;
            d7.load("otherSearch", function () {
                var T = i._pendingCalls.length;
                for (var hN = 0; hN < T; hN++) {
                    var hO = i._pendingCalls[hN];
                    i[hO.method].apply(i, hO.arguments)
                }
            })
        }
        C.extend(cP.prototype, {
            getCurrentPosition: function (e, i) {
                this._pendingCalls.push({
                    method: "getCurrentPosition",
                    arguments: arguments
                })
            },
            getStatus: function () {
                return BMAP_STATUS_UNKNOWN_LOCATION
            },
            enableSDKLocation: function () {
                if (f1()) {
                    this.config.SDKLocation = true
                }
            },
            disableSDKLocation: function () {
                this.config.SDKLocation = false
            }
        });

        function gv() {
            this._queryList = [];
            var e = this;
            d7.load("otherSearch", function () {
                e._asyncSearch()
            })
        }
        gv.inherits(ea, "Boundary");
        C.extend(gv.prototype, {
            get: function (i, e) {
                this._queryList.push({
                    method: "get",
                    arguments: [i, e]
                })
            },
            toString: function () {
                return "Boundary"
            }
        });

        function W(i) {
            i = i || {};
            i.renderOptions = i.renderOptions || {};
            this._opts = {
                renderOptions: {
                    map: i.renderOptions.map || null
                }
            };
            this._queryList = [];
            var e = this;
            d7.load("otherSearch", function () {
                e._asyncSearch()
            })
        }
        W.inherits(ea, "LocalCity");
        C.extend(W.prototype, {
            get: function (e) {
                this._queryList.push({
                    method: "get",
                    arguments: [e]
                })
            },
            toString: function () {
                return "LocalCity"
            }
        });

        function cK(e, T) {
            ea.call(this);
            this.markersList = [];
            this.destList = [];
            this.pointsList = [];
            this._opts = T;
            this.json = e;
            this.map = this._opts.renderOptions.map || null;
            this.sType = this._opts.sType;
            this.infoWindow = null;
            this.curPointIndex = 0;
            this.startName = "";
            this.endIndex = 1;
            this.endName = "";
            this.resCity = [0, 0, 0, 0, 0, 0, 0];
            this.locPois = [];
            this.curPageIndex = [1, 1, 1, 1, 1, 1, 1];
            this.totalPage = [1, 1, 1, 1, 1, 1, 1];
            this.resCount = [0, 0, 0, 0, 0, 0, 0];
            this.resType = [0, 0, 0, 0, 0, 0, 0];
            this.qInfo = [{
                n: "",
                c: 0,
                u: 0,
                x: 0,
                y: 0,
                t: -1
            }, {
                n: "",
                c: 0,
                u: 0,
                x: 0,
                y: 0,
                t: -1
            }, {
                n: "",
                c: 0,
                u: 0,
                x: 0,
                y: 0,
                t: -1
            }, {
                n: "",
                c: 0,
                u: 0,
                x: 0,
                y: 0,
                t: -1
            }, {
                n: "",
                c: 0,
                u: 0,
                x: 0,
                y: 0,
                t: -1
            }, {
                n: "",
                c: 0,
                u: 0,
                x: 0,
                y: 0,
                t: -1
            }, {
                n: "",
                c: 0,
                u: 0,
                x: 0,
                y: 0,
                t: -1
            }];
            this.curSelectedIndex = -1;
            this.tpList = [];
            this.tpListInMap = [];
            var i = this;
            d7.load("route", function () { })
        }
        cK.inherits(ea, "RouteAddr");

        function dZ(T, i) {
            fy.call(this, T, i);
            this.QUERY_TYPE_BUSLIST = g;
            this.RETURN_TYPE_BUSLIST = bN;
            this.QUERY_TYPE_BUSLINE = a9;
            this.RETURN_TYPE_BUSLINE = dG;
            this._queryList = [];
            var e = this;
            d7.load("buslineSearch", function () {
                e._asyncSearch()
            })
        }
        var bk = e0.staticHost + "/wolfman/static/common/images/";
        dZ._iconOpen = e0.apiIMG + "/iw_plus.gif";
        dZ._iconClose = e0.apiIMG + "/iw_minus.gif";
        dZ._stopUrl = bk + "new/bus-stop-1x_ddd4723.png";
        dZ.inherits(fy, "BusLineSearch");
        C.extend(dZ.prototype, {
            getBusList: function (e) {
                this._queryList.push({
                    method: "getBusList",
                    arguments: [e]
                })
            },
            getBusLine: function (e) {
                this._queryList.push({
                    method: "getBusLine",
                    arguments: [e]
                })
            },
            setGetBusListCompleteCallback: function (e) {
                this._opts.onGetBusListComplete = e || function () { }
            },
            setGetBusLineCompleteCallback: function (e) {
                this._opts.onGetBusLineComplete = e || function () { }
            },
            setBusListHtmlSetCallback: function (e) {
                this._opts.onBusListHtmlSet = e || function () { }
            },
            setBusLineHtmlSetCallback: function (e) {
                this._opts.onBusLineHtmlSet = e || function () { }
            },
            setPolylinesSetCallback: function (e) {
                this._opts.onPolylinesSet = e || function () { }
            }
        });

        function gY(i) {
            fy.call(this, i);
            i = i || {};
            this._options = {
                input: i.input || null,
                baseDom: i.baseDom || null,
                types: i.types || [],
                onSearchComplete: i.onSearchComplete || function () { }
            };
            this._loc.src = i.location || "全国";
            this._word = "";
            this._show = false;
            this._suggestion = null;
            this._inputValue = "";
            this._initialize();
            var e = this;
            d7.load("autocomplete", function () {
                e._asyncSearch()
            }, true)
        }
        gY.inherits(fy, "Autocomplete");
        C.extend(gY.prototype, {
            _initialize: function () { },
            show: function () {
                this._show = true
            },
            hide: function () {
                this._show = false
            },
            setTypes: function (e) {
                this._options.types = e
            },
            setLocation: function (e) {
                this._loc.src = e
            },
            search: function (e) {
                this._word = e
            },
            setInputValue: function (e) {
                this._inputValue = e
            },
            setSearchCompleteCallback: function (e) {
                this._options.onSearchComplete = e
            }
        });
        var hb = function (i, e) {
            fy.call(this, i, e)
        };
        C.inherit(hb, fy, "BaseRoute");
        C.extend(hb.prototype, {
            clearResults: function () { }
        });
        window.BMAP_TRANSIT_POLICY_RECOMMEND = 0;
        window.BMAP_TRANSIT_POLICY_LEAST_TIME = 4;
        window.BMAP_TRANSIT_POLICY_LEAST_TRANSFER = 1;
        window.BMAP_TRANSIT_POLICY_LEAST_WALKING = 2;
        window.BMAP_TRANSIT_POLICY_AVOID_SUBWAYS = 3;
        window.BMAP_TRANSIT_POLICY_FIRST_SUBWAYS = 5;
        window.BMAP_LINE_TYPE_BUS = 0;
        window.BMAP_LINE_TYPE_SUBWAY = 1;
        window.BMAP_LINE_TYPE_FERRY = 2;
        window.BMAP_LINE_TYPE_TRAIN = 3;
        window.BMAP_LINE_TYPE_AIRPLANE = 4;
        window.BMAP_LINE_TYPE_COACH = 5;
        var dh = 3;
        var fg = 4;
        var hu = 1;
        var dW = 2;
        var gL = 5;
        var g2 = 6;
        window.BMAP_TRANSIT_TYPE_IN_CITY = 0;
        window.BMAP_TRANSIT_TYPE_CROSS_CITY = 1;
        window.BMAP_TRANSIT_PLAN_TYPE_ROUTE = 0;
        window.BMAP_TRANSIT_PLAN_TYPE_LINE = 1;
        window.BMAP_TRANSIT_TYPE_POLICY_TRAIN = 0;
        window.BMAP_TRANSIT_TYPE_POLICY_AIRPLANE = 1;
        window.BMAP_TRANSIT_TYPE_POLICY_COACH = 2;
        window.BMAP_INTERCITY_POLICY_LEAST_TIME = 0;
        window.BMAP_INTERCITY_POLICY_EARLY_START = 1;
        window.BMAP_INTERCITY_POLICY_CHEAP_PRICE = 2;

        function bF(T, i) {
            hb.call(this, T, i);
            i = i || {};
            this.setPolicy(i.policy);
            this.setIntercityPolicy(i.intercityPolicy);
            this.setTransitTypePolicy(i.transitTypePolicy);
            this.setPageCapacity(i.pageCapacity);
            this.QUERY_TYPE = hE;
            this.RETURN_TYPE = hy;
            this.ROUTE_TYPE = fT;
            this._overlays = [];
            this._curIndex = -1;
            this._opts._enableTraffic = i.enableTraffic || false;
            this._queryList = [];
            var e = this;
            d7.load("route", function () {
                e._asyncSearch()
            }, true)
        }
        bF.MAX_PAGE_CAPACITY = 100;
        bF.LINE_TYPE_MAPPING = [0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1];
        bF.LINE_TYPE_MAPPING_CROSS_CITY = [0, 3, 4, 0, 0, 0, 5];
        C.inherit(bF, hb, "TransitRoute");
        C.extend(bF.prototype, {
            setPolicy: function (e) {
                if (e >= BMAP_TRANSIT_POLICY_RECOMMEND && e <= BMAP_TRANSIT_POLICY_FIRST_SUBWAYS) {
                    this._opts.policy = e
                } else {
                    this._opts.policy = BMAP_TRANSIT_POLICY_RECOMMEND
                }
            },
            setIntercityPolicy: function (e) {
                if (e >= BMAP_INTERCITY_POLICY_LEAST_TIME && e <= BMAP_INTERCITY_POLICY_CHEAP_PRICE) {
                    this._opts.intercityPolicy = e
                } else {
                    this._opts.intercityPolicy = BMAP_INTERCITY_POLICY_LEAST_TIME
                }
            },
            setTransitTypePolicy: function (e) {
                if (e >= BMAP_TRANSIT_TYPE_POLICY_TRAIN && e <= BMAP_TRANSIT_TYPE_POLICY_COACH) {
                    this._opts.transitTypePolicy = e
                } else {
                    this._opts.transitTypePolicy = BMAP_TRANSIT_TYPE_POLICY_TRAIN
                }
            },
            _internalSearch: function (i, e) {
                this._queryList.push({
                    method: "_internalSearch",
                    arguments: [i, e]
                })
            },
            search: function (i, e) {
                this._queryList.push({
                    method: "search",
                    arguments: [i, e]
                })
            },
            setPageCapacity: function (e) {
                if (typeof e === "string") {
                    e = parseInt(e, 10);
                    if (isNaN(e)) {
                        this._opts.pageCapacity = bF.MAX_PAGE_CAPACITY;
                        return
                    }
                }
                if (typeof e !== "number") {
                    this._opts.pageCapacity = bF.MAX_PAGE_CAPACITY;
                    return
                }
                if (e >= 1 && e <= bF.MAX_PAGE_CAPACITY) {
                    this._opts.pageCapacity = Math.round(e)
                } else {
                    this._opts.pageCapacity = bF.MAX_PAGE_CAPACITY
                }
            },
            toString: function () {
                return "TransitRoute"
            },
            _shortTitle: function (e) {
                return e.replace(/\(.*\)/, "")
            }
        });
        window.BMAP_HIGHLIGHT_STEP = 1;
        window.BMAP_HIGHLIGHT_ROUTE = 2;
        var cH = function (e, hN) {
            hb.call(this, e, hN);
            this._overlays = [];
            this._curIndex = -1;
            this._queryList = [];
            var T = this;
            var i = this._opts.renderOptions;
            if (i.highlightMode !== BMAP_HIGHLIGHT_STEP && i.highlightMode !== BMAP_HIGHLIGHT_ROUTE) {
                i.highlightMode = BMAP_HIGHLIGHT_STEP
            }
            this._enableDragging = this._opts.renderOptions.enableDragging ? true : false;
            d7.load("route", function () {
                T._asyncSearch()
            }, true);
            if (this.init_d) {
                this.init_d()
            }
        };
        cH.ROAD_TYPE = ["", "环岛", "无属性道路", "主路", "高速连接路", "交叉点内路段", "连接道路", "停车场内部道路", "服务区内部道路", "桥", "步行街", "辅路", "匝道", "全封闭道路", "未定义交通区域", "POI连接路", "隧道", "步行道", "公交专用道", "提前右转道"];
        C.inherit(cH, hb, "DWRoute");
        C.extend(cH.prototype, {
            search: function (T, e, i) {
                this._queryList.push({
                    method: "search",
                    arguments: [T, e, i]
                })
            }
        });
        window.BMAP_DRIVING_POLICY_DEFAULT = 0;
        window.BMAP_DRIVING_POLICY_AVOID_HIGHWAYS = 3;
        window.BMAP_DRIVING_POLICY_FIRST_HIGHWAYS = 4;
        window.BMAP_DRIVING_POLICY_AVOID_CONGESTION = 5;
        window.BMAP_TRAFFICE_STATUS_NONE = 0;
        window.BMAP_TRAFFICE_STATUS_NORMAL = 1;
        window.BMAP_TRAFFICE_STATUS_SLOW = 2;
        window.BMAP_TRAFFICE_STATUS_JAM = 3;

        function fB(e, i) {
            cH.call(this, e, i);
            i = i || {};
            this._opts._enableTraffic = i.enableTraffic || false;
            this.setPolicy(i.policy);
            this.QUERY_TYPE = cM;
            this.RETURN_TYPE = fb;
            this.ROUTE_TYPE = BMAP_ROUTE_TYPE_DRIVING
        }
        C.inherit(fB, cH, "DrivingRoute");
        fB.prototype.setPolicy = function (e) {
            if (e >= BMAP_DRIVING_POLICY_DEFAULT && e <= BMAP_DRIVING_POLICY_AVOID_CONGESTION) {
                this._opts.policy = e
            } else {
                this._opts.policy = BMAP_DRIVING_POLICY_DEFAULT
            }
        };

        function a7(e, i) {
            cH.call(this, e, i);
            this.QUERY_TYPE = eh;
            this.RETURN_TYPE = ef;
            this.ROUTE_TYPE = BMAP_ROUTE_TYPE_WALKING;
            this._enableDragging = false
        }
        C.inherit(a7, cH, "WalkingRoute");

        function bj(e, i) {
            cH.call(this, e, i);
            this.QUERY_TYPE = R;
            this.ROUTE_TYPE = BMAP_ROUTE_TYPE_RIDING;
            this._enableDragging = false
        }
        C.inherit(bj, cH, "RidingRoute");
        window.BMAP_MODE_DRIVING = "driving";
        window.BMAP_MODE_TRANSIT = "transit";
        window.BMAP_MODE_WALKING = "walking";
        window.BMAP_MODE_NAVIGATION = "navigation";
        var bb = {
            web: "https://api.map.baidu.com/direction?",
            android: "bdapp://map/direction?",
            ios: "baidumap://map/direction?"
        };

        function hp(e) {
            this.opts = e || {}
        }
        C.extend(hp.prototype, {
            routeCall: function (hN, e, T) {
                var i = this;
                d7.load("route", function () {
                    i._asyncSearch(hN, e, T)
                })
            }
        });
        bl.Map = c5;
        bl.MapType = b3;
        bl.Point = ho;
        bl.Pixel = eg;
        bl.Size = d6;
        bl.Bounds = dP;
        bl.TileLayer = cO;
        bl.Copyright = c1;
        bl.Projection = bl.Project = ek;
        bl.Convertor = ax;
        bl.RenderTypeUtils = a5;
        bl.Overlay = bi;
        bl.Label = fM;
        bl.Marker = aA;
        bl.Icon = g7;
        bl.Polyline = ak;
        bl.BezierCurve = fk;
        bl.PolylineMultipart = fi;
        bl.Polygon = g0;
        bl.Prism = cd;
        bl.Marker3D = cs;
        bl.GroundOverlay = cm;
        bl.InfoWindow = an;
        bl.SimpleInfoWindow = hD;
        bl.Circle = dC;
        bl.Control = a4;
        bl.NavigationControl = dq;
        bl.NavigationControl3D = eR;
        bl.CopyrightControl = dE;
        bl.ScaleControl = hd;
        bl.CityListControl = d8;
        bl.MapTypeControl = bz;
        bl.ZoomControl = cv;
        bl.LocationControl = bx;
        bl.LogoControl = af;
        bl.DistanceTool = gH;
        bl.ContextMenu = cc;
        bl.MenuItem = fv;
        bl.OperationMask = ee;
        bl.Animation = o;
        bl.ViewAnimation = cJ;
        bl.Transitions = ck;
        bl.Event = a8;
        bl.trafficLayer = cb;
        bl.Geolocation = cP;
        bl.Geocoder = V;
        bl.Boundary = gv;
        bl.LocalCity = W;
        bl.LocalSearch = dK;
        bl.Autocomplete = gY;
        bl.BusLineSearch = dZ;
        bl.WalkingRoute = a7;
        bl.RidingRoute = bj;
        bl.DrivingRoute = fB;
        bl.TransitRoute = bF;
        bl.RouteSearch = hp;

        function dY(e, i) {
            for (var T in i) {
                e[T] = i[T]
            }
        }
        bl.verify();
        bl.apiLoad();
    }
    var map;
    var BMapGL;
    function loadJScript() {
        window.BMAP_PROTOCOL = "https";
        window.BMapGL_loadScriptTime = (new Date).getTime();
        window.BMapGL = window.BMapGL || {};
        window.BMapGL.apiLoad = function () {
            delete window.BMapGL.apiLoad;
            if (typeof init == "function") {
                init()
            }
        };
        var link = document.createElement('link');
        link.setAttribute('rel', 'stylesheet');
        link.setAttribute('type', 'text/css');
        link.setAttribute('href', 'https://api.map.baidu.com/res/webgl/10/bmap.css');
        document.getElementsByTagName('head')[0].appendChild(link);
        Start(BMapGL, "BMapGL");
    }
    function init() {
        map = new BMapGL.Map('container'); // 创建Map实例
        var point = new BMapGL.Point(116.404, 39.915); // 创建点坐标
        map.centerAndZoom(point, 10);
        map.enableScrollWheelZoom(); // 启用滚轮放大缩小
        var scaleCtrl = new BMapGL.ScaleControl();  // 添加比例尺控件
        map.addControl(scaleCtrl);
        var zoomCtrl = new BMapGL.ZoomControl();  // 添加比例尺控件
        map.addControl(zoomCtrl);
        var menu = new BMapGL.ContextMenu();
        var txtMenuItem = [
            {
                text: '放大一级',
                callback: function () {
                    map.zoomIn();
                }
            }, {
                text: '缩小一级',
                callback: function () {
                    map.zoomOut();
                }
            }
        ];
        for (var i = 0; i < txtMenuItem.length; i++) {
            menu.addItem(new BMapGL.MenuItem(txtMenuItem[i].text, txtMenuItem[i].callback, 100));
        }
        map.addContextMenu(menu);

        set(116.404, 39.925, '故宫博物院', '地址：北京市东城区王府井大街88号乐天银泰百货八层');
    }
    function set(x, y, name, text) {
        var point = new BMapGL.Point(x, y); // 创建点坐标
        // 创建点标记
        var marker = new BMapGL.Marker(point);
        map.addOverlay(marker);
        // 创建信息窗口
        var opts = {
            width: 200,
            height: 100,
            title: name
        };
        var infoWindow = new BMapGL.InfoWindow(text, opts);
        // 点标记添加点击事件
        marker.addEventListener('click', function () {
            map.openInfoWindow(infoWindow, point); // 开启信息窗口
        });
    }
    window.onload = loadJScript; // 异步加载地图
</script>